Array.prototype.remove = function (dx) {
    if (isNaN(dx) || dx > this.length) { return false; }
    for (var i = 0, n = 0; i < this.length; i++) {
        if (this[i] != this[dx]) {
            this[n++] = this[i]
        }
    }
    this.length -= 1
};
String.prototype.format = function (args) {
    var result = this;
    if (arguments.length > 0) {
        if (arguments.length == 1 && typeof (args) == "object") {
            for (var key in args) {
                if (args[key] != undefined) {
                    var reg = new RegExp("({" + key + "})", "g");
                    result = result.replace(reg, args[key]);
                }
            }
        }
        else {
            for (var i = 0; i < arguments.length; i++) {
                if (arguments[i] != undefined) {
                    var reg = new RegExp("({)" + i + "(})", "g");
                    result = result.replace(reg, arguments[i]);
                }
            }
        }
    }
    return result;
};

Date.FromMSJsonString = function (value) {
    var d = eval('new ' + (value.replace(/\//g, '')));
    return d;
};

Date.prototype.Format = function (fmt) { //author: meizz
    var o = {
        "M+": this.getMonth() + 1, //月份
        "d+": this.getDate(), //日
        "h+": this.getHours(), //小时
        "m+": this.getMinutes(), //分
        "s+": this.getSeconds(), //秒
        "q+": Math.floor((this.getMonth() + 3) / 3), //季度
        "S": this.getMilliseconds() //毫秒
    };
    if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
        if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));
    return fmt;
};

function getQueryString(name) {
    var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
    var r = window.location.search.substr(1).match(reg);
    if (r != null) return unescape(r[2]); return null;
}
var Z1e = {
    'M1': 'WEBGL_compressed_texture_etc1',
    'R': 'THREE.WebGLRenderer: ',
    'u0': 'MeshLambertMaterial',
    'E2': 'encodings_pars_fragment',
    'G2': 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',
    'M2': 'SphereGeometry',
    'l1': 0.0,
    'H3': 'number',
    'e4': false,
    'D1': 'meshbasic_vert',
    'V2': "- just use .toArray instead.",
    'P': 'OES_texture_half_float',
    'U1': "1f",
    'G3': 'WEBGL_depth_texture',
    'u4': 'aomap',
    'z4': 255,
    't4': 'points_vert',
    'Q1': 'lightmap',
    'V': 'linedashed_vert',
    'N1': 'normal_vert',
    'l3': null,
    'R2': 'normal',
    'U3': 'SphereBufferGeometry',
    'j4': 100,
    'g0': "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n",
    'C0': 'Geometry',
    'V0': 'bezierCurveTo',
    'T2': 'BufferGeometry',
    'y3': "toneMapping",
    'n3': true,
    'J2': 'RingBufferGeometry',
    'W2': 'lights',
    'a4': 'moveTo',
    'Z1': 'uniform mat4 projectionMatrix;',
    'j0': 'distanceRGBA_frag',
    'E1': 'attribute vec2 uv;',
    'o3': 'meshphong_frag',
    'Y3': 'precision ',
    'L2': 'CircleGeometry',
    'J': 'emissivemap',
    'r3': 'projectionMatrix',
    'R0': 'meshphysical_frag',
    'l0': 'quadraticCurveTo',
    'I1': 'THREE.',
    'V1': 0.99999,
    'I0': 'meshbasic_frag',
    'F1': 'meshlambert_frag',
    'I': 'IcosahedronGeometry',
    'O2': 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
    'J0': "THREE.Matrix3: .flattenToArrayOffset is deprecated ",
    'R3': 'WEBGL_compressed_texture_pvrtc',
    'd0': ' float;',
    'K1': 'LatheGeometry',
    'q3': 'CylinderGeometry',
    'T1': 'meshlambert_vert',
    'Q': 'cube_vert',
    'q0': 'CircleBufferGeometry',
    'U': 'distanceRGBA_vert',
    'M': 'canvas',
    'A0': 'displacementmap',
    'h4': 'OES_element_index_uint',
    'k0': 0.25,
    'r0': 'DodecahedronGeometry',
    'Z3': 'meshphong_vert',
    'T0': 'fog',
    'X1': 'color',
    'e0': 'TorusBufferGeometry',
    'K0': 'CylinderBufferGeometry',
    'k2': 'uniform mat4 modelViewMatrix;',
    'm4': 'THREE.Audio: this Audio has no playback control.',
    'Y0': 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.',
    'Y1': 'HemisphereLight',
    'I2': 'AmbientLight',
    'Y2': 'equirect_frag',
    'a3': 'MeshPhysicalMaterial',
    'J1': 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
    'e2': "t",
    'e1': 'PerspectiveCamera',
    'A1': 'linedashed_frag',
    'z3': 'arraybuffer',
    'O': "sa",
    'j1': 'THREE.Object3D: .eulerOrder is now .rotation.order.',
    'n0': 'EXT_texture_filter_anisotropic',
    'H': 'OrthographicCamera',
    'W3': 'MeshBasicMaterial',
    'W1': 'string',
    'q2': 'THREE.WebGLRenderTarget: .format is now .texture.format.',
    'O1': 'undefined',
    'g1': 'position',
    'C1': 'TetrahedronGeometry',
    'G1': 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
    'q4': 'PlaneGeometry',
    'k1': 0.5,
    'n4': 'TorusGeometry',
    'b4': 'meshphysical_vert',
    'E0': 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',
    'H1': 'XYZ',
    'A3': 'common',
    'X2': 'ANGLE_instanced_arrays',
    'o2': 'DirectionalLight',
    'a0': 'OES_texture_float',
    'O3': 'THREE.WebGLRenderTarget: .offset is now .texture.offset.',
    'd4': 1.0,
    'h3': 'SpotLight',
    'H0': 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
    'S0': 'id',
    'B3': 'MeshStandardMaterial',
    'P3': 65535,
    'Q2': 'LatheBufferGeometry',
    'N0': 'PointLight',
    'k3': 'WEBGL_compressed_texture_s3tc',
    'J3': 'OES_standard_derivatives',
    'M3': 'uv',
    'C3': 'MeshPhongMaterial',
    'l4': 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.',
    'V3': 'RingGeometry',
    'Q0': "c",
    'U2': 'index is out of range: ',
    'I3': 'TorusKnotGeometry',
    's4': 'EXT_blend_minmax',
    'S3': 'equirect_vert',
    'g2': '\n',
    'c4': 'THREE.BufferAttribute: .length has been deprecated. Please use .count.',
    'U0': ': .wrapAround has been removed.',
    'B2': 'tonemapping_pars_fragment',
    'F2': 'BoxGeometry',
    'O0': 'normal_frag',
    'C2': 'round',
    'u2': 'THREE.WebGLRenderTarget: .type is now .texture.type.',
    'K': 'YZX',
    'L3': 'EXT_frag_depth',
    'u3': 'BoxBufferGeometry',
    'T3': 'not supported, using',
    'f1': 'PlaneBufferGeometry',
    'r1': 'TorusKnotBufferGeometry',
    'L0': 'dispose',
    'A2': 'modelViewMatrix',
    'B0': 'points_frag',
    'R1': 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',
    'W': 'physical',
    'j2': 'OctahedronGeometry'
};
var THREE = {REVISION: '76'};
if (typeof define === 'function' && define.amd) {
    define('three', THREE);
} else if (Z1e.O1 !== typeof exports && Z1e.O1 !== typeof module) {
    module.exports = THREE;
}
if (Number.EPSILON === undefined) {
    Number.EPSILON = Math.pow(2, -52);
}
if (Math.sign === undefined) {
    Math.sign = function (d) {
        return (d < 0) ? -1 : (d > 0) ? 1 : +d;
    };
}
if (Function.prototype.name === undefined && Object.defineProperty !== undefined) {
    Object.defineProperty(Function.prototype, 'name', {
        get: function () {
            return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
        }
    });
}
if (Object.assign === undefined) {
    Object.defineProperty(Object, 'assign', {
        writable: Z1e.n3, configurable: Z1e.n3, value: function (d) {
            'use strict';
            if (d === undefined || d === Z1e.l3) {
                throw  new TypeError("Cannot convert first argument to object");
            }
            var e = Object(d);
            for (var f = 1, i = arguments.length; f !== i; ++f) {
                var j = arguments[f];
                if (j === undefined || j === Z1e.l3)continue;
                j = Object(j);
                var k = Object.keys(j);
                for (var m = 0, n = k.length; m !== n; ++m) {
                    var u = k[m], v = Object.getOwnPropertyDescriptor(j, u);
                    if (v !== undefined && v.enumerable) {
                        e[u] = j[u];
                    }
                }
            }
            return e;
        }
    });
}
THREE.MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2};
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.PCSSShadowMap = 3;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = Z1e.j4;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.NoToneMapping = 0;
THREE.LinearToneMapping = 1;
THREE.ReinhardToneMapping = 2;
THREE.Uncharted2ToneMapping = 3;
THREE.CineonToneMapping = 4;
THREE.UVMapping = 300;
THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;
THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;
THREE.SphericalReflectionMapping = 305;
THREE.CubeUVReflectionMapping = 306;
THREE.CubeUVRefractionMapping = 307;
THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGBEFormat = THREE.RGBAFormat;
THREE.DepthFormat = 1026;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
THREE.RGB_ETC1_Format = 2151;
THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPong = 2202;
THREE.InterpolateDiscrete = 2300;
THREE.InterpolateLinear = 2301;
THREE.InterpolateSmooth = 2302;
THREE.ZeroCurvatureEnding = 2400;
THREE.ZeroSlopeEnding = 2401;
THREE.WrapAroundEnding = 2402;
THREE.TrianglesDrawMode = 0;
THREE.TriangleStripDrawMode = 1;
THREE.TriangleFanDrawMode = 2;
THREE.LinearEncoding = 3000;
THREE.sRGBEncoding = 3001;
THREE.GammaEncoding = 3007;
THREE.RGBEEncoding = 3002;
THREE.LogLuvEncoding = 3003;
THREE.RGBM7Encoding = 3004;
THREE.RGBM16Encoding = 3005;
THREE.RGBDEncoding = 3006;
THREE.BasicDepthPacking = 3200;
THREE.RGBADepthPacking = 3201;
THREE.Color = function (d) {
    if (arguments.length === 3) {
        return this.fromArray(arguments);
    }
    return this.set(d);
};
THREE.Color.prototype = {
    constructor: THREE.Color, r: 1, g: 1, b: 1, set: function (d) {
        if (d instanceof THREE.Color) {
            this.copy(d);
        } else if (typeof d === Z1e.H3) {
            this.setHex(d);
        } else if (typeof d === Z1e.W1) {
            this.setStyle(d);
        }
        return this;
    }, setScalar: function (d) {
        this.r = d;
        this.g = d;
        this.b = d;
    }, setHex: function (d) {
        d = Math.floor(d);
        this.r = (d >> 16 & Z1e.z4) / Z1e.z4;
        this.g = (d >> 8 & Z1e.z4) / Z1e.z4;
        this.b = (d & Z1e.z4) / Z1e.z4;
        return this;
    }, setRGB: function (d, e, f) {
        this.r = d;
        this.g = e;
        this.b = f;
        return this;
    }, setHSL: function () {
        function k(d, e, f) {
            if (f < 0) f += 1;
            if (f > 1) f -= 1;
            if (f < 1 / 6)return d + (e - d) * 6 * f;
            if (f < 1 / 2)return e;
            if (f < 2 / 3)return d + (e - d) * 6 * (2 / 3 - f);
            return d;
        }
        return function (d, e, f) {
            d = THREE.Math.euclideanModulo(d, 1);
            e = THREE.Math.clamp(e, 0, 1);
            f = THREE.Math.clamp(f, 0, 1);
            if (e === 0) {
                this.r = this.g = this.b = f;
            } else {
                var i = f <= Z1e.k1 ? f * (1 + e) : f + e - (f * e), j = (2 * f) - i;
                this.r = k(j, i, d + 1 / 3);
                this.g = k(j, i, d);
                this.b = k(j, i, d - 1 / 3);
            }
            return this;
        };
    }(), setStyle: function (e) {
        function f(d) {
            if (d === undefined)return;
            if (parseFloat(d) < 1) {
                console.warn('THREE.Color: Alpha component of ' + e + ' will be ignored.');
            }
        }
        var i;
        if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
            var j, k = i[1], m = i[2];
            switch (k) {
                case 'rgb':
                case 'rgba':
                    if (j = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(m)) {
                        this.r = Math.min(Z1e.z4, parseInt(j[1], 10)) / Z1e.z4;
                        this.g = Math.min(Z1e.z4, parseInt(j[2], 10)) / Z1e.z4;
                        this.b = Math.min(Z1e.z4, parseInt(j[3], 10)) / Z1e.z4;
                        f(j[5]);
                        return this;
                    }
                    if (j = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(m)) {
                        this.r = Math.min(Z1e.j4, parseInt(j[1], 10)) / Z1e.j4;
                        this.g = Math.min(Z1e.j4, parseInt(j[2], 10)) / Z1e.j4;
                        this.b = Math.min(Z1e.j4, parseInt(j[3], 10)) / Z1e.j4;
                        f(j[5]);
                        return this;
                    }
                    break;
                case 'hsl':
                case 'hsla':
                    if (j = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(m)) {
                        var n = parseFloat(j[1]) / 360, u = parseInt(j[2], 10) / Z1e.j4,
                            v = parseInt(j[3], 10) / Z1e.j4;
                        f(j[5]);
                        return this.setHSL(n, u, v);
                    }
                    break;
            }
        } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
            var B = i[1], C = B.length;
            if (C === 3) {
                this.r = parseInt(B.charAt(0) + B.charAt(0), 16) / Z1e.z4;
                this.g = parseInt(B.charAt(1) + B.charAt(1), 16) / Z1e.z4;
                this.b = parseInt(B.charAt(2) + B.charAt(2), 16) / Z1e.z4;
                return this;
            } else if (C === 6) {
                this.r = parseInt(B.charAt(0) + B.charAt(1), 16) / Z1e.z4;
                this.g = parseInt(B.charAt(2) + B.charAt(3), 16) / Z1e.z4;
                this.b = parseInt(B.charAt(4) + B.charAt(5), 16) / Z1e.z4;
                return this;
            }
        }
        if (e && e.length > 0) {
            var B = THREE.ColorKeywords[e];
            if (B !== undefined) {
                this.setHex(B);
            } else {
                console.warn('THREE.Color: Unknown color ' + e);
            }
        }
        return this;
    }, clone: function () {
        return new this.constructor(this.r, this.g, this.b);
    }, copy: function (d) {
        this.r = d.r;
        this.g = d.g;
        this.b = d.b;
        return this;
    }, copyGammaToLinear: function (d, e) {
        if (e === undefined) e = 2.0;
        this.r = Math.pow(d.r, e);
        this.g = Math.pow(d.g, e);
        this.b = Math.pow(d.b, e);
        return this;
    }, copyLinearToGamma: function (d, e) {
        if (e === undefined) e = 2.0;
        var f = (e > 0) ? (Z1e.d4 / e) : Z1e.d4;
        this.r = Math.pow(d.r, f);
        this.g = Math.pow(d.g, f);
        this.b = Math.pow(d.b, f);
        return this;
    }, convertGammaToLinear: function () {
        var d = this.r, e = this.g, f = this.b;
        this.r = d * d;
        this.g = e * e;
        this.b = f * f;
        return this;
    }, convertLinearToGamma: function () {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this;
    }, getHex: function () {
        return (this.r * Z1e.z4) << 16 ^ (this.g * Z1e.z4) << 8 ^ (this.b * Z1e.z4) << 0;
    }, getHexString: function () {
        return ('000000' + this.getHex().toString(16)).slice(-6);
    }, getHSL: function (d) {
        var e = d || {h: 0, s: 0, l: 0}, f = this.r, i = this.g, j = this.b, k = Math.max(f, i, j),
            m = Math.min(f, i, j), n, u, v = (m + k) / 2.0;
        if (m === k) {
            n = 0;
            u = 0;
        } else {
            var B = k - m;
            u = v <= Z1e.k1 ? B / (k + m) : B / (2 - k - m);
            switch (k) {
                case f:
                    n = (i - j) / B + (i < j ? 6 : 0);
                    break;
                case i:
                    n = (j - f) / B + 2;
                    break;
                case j:
                    n = (f - i) / B + 4;
                    break;
            }
            n /= 6;
        }
        e.h = n;
        e.s = u;
        e.l = v;
        return e;
    }, getStyle: function () {
        return 'rgb(' + ((this.r * Z1e.z4) | 0) + ',' + ((this.g * Z1e.z4) | 0) + ',' + ((this.b * Z1e.z4) | 0) + ')';
    }, offsetHSL: function (d, e, f) {
        var i = this.getHSL();
        i.h += d;
        i.s += e;
        i.l += f;
        this.setHSL(i.h, i.s, i.l);
        return this;
    }, add: function (d) {
        this.r += d.r;
        this.g += d.g;
        this.b += d.b;
        return this;
    }, addColors: function (d, e) {
        this.r = d.r + e.r;
        this.g = d.g + e.g;
        this.b = d.b + e.b;
        return this;
    }, addScalar: function (d) {
        this.r += d;
        this.g += d;
        this.b += d;
        return this;
    }, multiply: function (d) {
        this.r *= d.r;
        this.g *= d.g;
        this.b *= d.b;
        return this;
    }, multiplyScalar: function (d) {
        this.r *= d;
        this.g *= d;
        this.b *= d;
        return this;
    }, lerp: function (d, e) {
        this.r += (d.r - this.r) * e;
        this.g += (d.g - this.g) * e;
        this.b += (d.b - this.b) * e;
        return this;
    }, equals: function (d) {
        return (d.r === this.r) && (d.g === this.g) && (d.b === this.b);
    }, fromArray: function (d, e) {
        if (e === undefined) e = 0;
        this.r = d[e];
        this.g = d[e + 1];
        this.b = d[e + 2];
        return this;
    }, toArray: function (d, e) {
        if (d === undefined) d = [];
        if (e === undefined) e = 0;
        d[e] = this.r;
        d[e + 1] = this.g;
        d[e + 2] = this.b;
        return d;
    }
};
THREE.ColorKeywords = {
    'aliceblue': 0xF0F8FF,
    'antiquewhite': 0xFAEBD7,
    'aqua': 0x00FFFF,
    'aquamarine': 0x7FFFD4,
    'azure': 0xF0FFFF,
    'beige': 0xF5F5DC,
    'bisque': 0xFFE4C4,
    'black': 0x000000,
    'blanchedalmond': 0xFFEBCD,
    'blue': 0x0000FF,
    'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A,
    'burlywood': 0xDEB887,
    'cadetblue': 0x5F9EA0,
    'chartreuse': 0x7FFF00,
    'chocolate': 0xD2691E,
    'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED,
    'cornsilk': 0xFFF8DC,
    'crimson': 0xDC143C,
    'cyan': 0x00FFFF,
    'darkblue': 0x00008B,
    'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B,
    'darkgray': 0xA9A9A9,
    'darkgreen': 0x006400,
    'darkgrey': 0xA9A9A9,
    'darkkhaki': 0xBDB76B,
    'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F,
    'darkorange': 0xFF8C00,
    'darkorchid': 0x9932CC,
    'darkred': 0x8B0000,
    'darksalmon': 0xE9967A,
    'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B,
    'darkslategray': 0x2F4F4F,
    'darkslategrey': 0x2F4F4F,
    'darkturquoise': 0x00CED1,
    'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493,
    'deepskyblue': 0x00BFFF,
    'dimgray': 0x696969,
    'dimgrey': 0x696969,
    'dodgerblue': 0x1E90FF,
    'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0,
    'forestgreen': 0x228B22,
    'fuchsia': 0xFF00FF,
    'gainsboro': 0xDCDCDC,
    'ghostwhite': 0xF8F8FF,
    'gold': 0xFFD700,
    'goldenrod': 0xDAA520,
    'gray': 0x808080,
    'green': 0x008000,
    'greenyellow': 0xADFF2F,
    'grey': 0x808080,
    'honeydew': 0xF0FFF0,
    'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C,
    'indigo': 0x4B0082,
    'ivory': 0xFFFFF0,
    'khaki': 0xF0E68C,
    'lavender': 0xE6E6FA,
    'lavenderblush': 0xFFF0F5,
    'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD,
    'lightblue': 0xADD8E6,
    'lightcoral': 0xF08080,
    'lightcyan': 0xE0FFFF,
    'lightgoldenrodyellow': 0xFAFAD2,
    'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90,
    'lightgrey': 0xD3D3D3,
    'lightpink': 0xFFB6C1,
    'lightsalmon': 0xFFA07A,
    'lightseagreen': 0x20B2AA,
    'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899,
    'lightslategrey': 0x778899,
    'lightsteelblue': 0xB0C4DE,
    'lightyellow': 0xFFFFE0,
    'lime': 0x00FF00,
    'limegreen': 0x32CD32,
    'linen': 0xFAF0E6,
    'magenta': 0xFF00FF,
    'maroon': 0x800000,
    'mediumaquamarine': 0x66CDAA,
    'mediumblue': 0x0000CD,
    'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB,
    'mediumseagreen': 0x3CB371,
    'mediumslateblue': 0x7B68EE,
    'mediumspringgreen': 0x00FA9A,
    'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585,
    'midnightblue': 0x191970,
    'mintcream': 0xF5FFFA,
    'mistyrose': 0xFFE4E1,
    'moccasin': 0xFFE4B5,
    'navajowhite': 0xFFDEAD,
    'navy': 0x000080,
    'oldlace': 0xFDF5E6,
    'olive': 0x808000,
    'olivedrab': 0x6B8E23,
    'orange': 0xFFA500,
    'orangered': 0xFF4500,
    'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA,
    'palegreen': 0x98FB98,
    'paleturquoise': 0xAFEEEE,
    'palevioletred': 0xDB7093,
    'papayawhip': 0xFFEFD5,
    'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F,
    'pink': 0xFFC0CB,
    'plum': 0xDDA0DD,
    'powderblue': 0xB0E0E6,
    'purple': 0x800080,
    'red': 0xFF0000,
    'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1,
    'saddlebrown': 0x8B4513,
    'salmon': 0xFA8072,
    'sandybrown': 0xF4A460,
    'seagreen': 0x2E8B57,
    'seashell': 0xFFF5EE,
    'sienna': 0xA0522D,
    'silver': 0xC0C0C0,
    'skyblue': 0x87CEEB,
    'slateblue': 0x6A5ACD,
    'slategray': 0x708090,
    'slategrey': 0x708090,
    'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F,
    'steelblue': 0x4682B4,
    'tan': 0xD2B48C,
    'teal': 0x008080,
    'thistle': 0xD8BFD8,
    'tomato': 0xFF6347,
    'turquoise': 0x40E0D0,
    'violet': 0xEE82EE,
    'wheat': 0xF5DEB3,
    'white': 0xFFFFFF,
    'whitesmoke': 0xF5F5F5,
    'yellow': 0xFFFF00,
    'yellowgreen': 0x9ACD32
};
THREE.Quaternion = function (d, e, f, i) {
    this._x = d || 0;
    this._y = e || 0;
    this._z = f || 0;
    this._w = (i !== undefined) ? i : 1;
};
THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion, get x() {
        return this._x;
    }, set x(value) {
        this._x = value;
        this.onChangeCallback();
    }, get y() {
        return this._y;
    }, set y(value) {
        this._y = value;
        this.onChangeCallback();
    }, get z() {
        return this._z;
    }, set z(value) {
        this._z = value;
        this.onChangeCallback();
    }, get w() {
        return this._w;
    }, set w(value) {
        this._w = value;
        this.onChangeCallback();
    }, set: function (d, e, f, i) {
        this._x = d;
        this._y = e;
        this._z = f;
        this._w = i;
        this.onChangeCallback();
        return this;
    }, clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }, copy: function (d) {
        this._x = d.x;
        this._y = d.y;
        this._z = d.z;
        this._w = d.w;
        this.onChangeCallback();
        return this;
    }, setFromEuler: function (d, e) {
        if (d instanceof THREE.Euler === Z1e.e4) {
            throw  new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var f = Math.cos(d._x / 2), i = Math.cos(d._y / 2), j = Math.cos(d._z / 2), k = Math.sin(d._x / 2),
            m = Math.sin(d._y / 2), n = Math.sin(d._z / 2), u = d.order;
        if (u === Z1e.H1) {
            this._x = k * i * j + f * m * n;
            this._y = f * m * j - k * i * n;
            this._z = f * i * n + k * m * j;
            this._w = f * i * j - k * m * n;
        } else if (u === 'YXZ') {
            this._x = k * i * j + f * m * n;
            this._y = f * m * j - k * i * n;
            this._z = f * i * n - k * m * j;
            this._w = f * i * j + k * m * n;
        } else if (u === 'ZXY') {
            this._x = k * i * j - f * m * n;
            this._y = f * m * j + k * i * n;
            this._z = f * i * n + k * m * j;
            this._w = f * i * j - k * m * n;
        } else if (u === 'ZYX') {
            this._x = k * i * j - f * m * n;
            this._y = f * m * j + k * i * n;
            this._z = f * i * n - k * m * j;
            this._w = f * i * j + k * m * n;
        } else if (u === Z1e.K) {
            this._x = k * i * j + f * m * n;
            this._y = f * m * j + k * i * n;
            this._z = f * i * n - k * m * j;
            this._w = f * i * j - k * m * n;
        } else if (u === 'XZY') {
            this._x = k * i * j - f * m * n;
            this._y = f * m * j - k * i * n;
            this._z = f * i * n + k * m * j;
            this._w = f * i * j + k * m * n;
        }
        if (e !== Z1e.e4) this.onChangeCallback();
        return this;
    }, setFromAxisAngle: function (d, e) {
        var f = e / 2, i = Math.sin(f);
        this._x = d.x * i;
        this._y = d.y * i;
        this._z = d.z * i;
        this._w = Math.cos(f);
        this.onChangeCallback();
        return this;
    }, setFromRotationMatrix: function (d) {
        var e = d.elements, f = e[0], i = e[4], j = e[8], k = e[1], m = e[5], n = e[9], u = e[2], v = e[6], B = e[10],
            C = f + m + B, G;
        if (C > 0) {
            G = Z1e.k1 / Math.sqrt(C + Z1e.d4);
            this._w = Z1e.k0 / G;
            this._x = (v - n) * G;
            this._y = (j - u) * G;
            this._z = (k - i) * G;
        } else if (f > m && f > B) {
            G = 2.0 * Math.sqrt(Z1e.d4 + f - m - B);
            this._w = (v - n) / G;
            this._x = Z1e.k0 * G;
            this._y = (i + k) / G;
            this._z = (j + u) / G;
        } else if (m > B) {
            G = 2.0 * Math.sqrt(Z1e.d4 + m - f - B);
            this._w = (j - u) / G;
            this._x = (i + k) / G;
            this._y = Z1e.k0 * G;
            this._z = (n + v) / G;
        } else {
            G = 2.0 * Math.sqrt(Z1e.d4 + B - f - m);
            this._w = (k - i) / G;
            this._x = (j + u) / G;
            this._y = (n + v) / G;
            this._z = Z1e.k0 * G;
        }
        this.onChangeCallback();
        return this;
    }, setFromUnitVectors: function () {
        var f, i, j = 0.000001;
        return function (d, e) {
            if (f === undefined) f = new THREE.Vector3();
            i = d.dot(e) + 1;
            if (i < j) {
                i = 0;
                if (Math.abs(d.x) > Math.abs(d.z)) {
                    f.set(-d.y, d.x, 0);
                } else {
                    f.set(0, -d.z, d.y);
                }
            } else {
                f.crossVectors(d, e);
            }
            this._x = f.x;
            this._y = f.y;
            this._z = f.z;
            this._w = i;
            this.normalize();
            return this;
        };
    }(), inverse: function () {
        this.conjugate().normalize();
        return this;
    }, conjugate: function () {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this;
    }, dot: function (d) {
        return this._x * d._x + this._y * d._y + this._z * d._z + this._w * d._w;
    }, lengthSq: function () {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }, length: function () {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }, normalize: function () {
        var d = this.length();
        if (d === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            d = 1 / d;
            this._x = this._x * d;
            this._y = this._y * d;
            this._z = this._z * d;
            this._w = this._w * d;
        }
        this.onChangeCallback();
        return this;
    }, multiply: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
            return this.multiplyQuaternions(d, e);
        }
        return this.multiplyQuaternions(this, d);
    }, multiplyQuaternions: function (d, e) {
        var f = d._x, i = d._y, j = d._z, k = d._w, m = e._x, n = e._y, u = e._z, v = e._w;
        this._x = f * v + k * m + i * u - j * n;
        this._y = i * v + k * n + j * m - f * u;
        this._z = j * v + k * u + f * n - i * m;
        this._w = k * v - f * m - i * n - j * u;
        this.onChangeCallback();
        return this;
    }, slerp: function (d, e) {
        if (e === 0)return this;
        if (e === 1)return this.copy(d);
        var f = this._x, i = this._y, j = this._z, k = this._w, m = k * d._w + f * d._x + i * d._y + j * d._z;
        if (m < 0) {
            this._w = -d._w;
            this._x = -d._x;
            this._y = -d._y;
            this._z = -d._z;
            m = -m;
        } else {
            this.copy(d);
        }
        if (m >= Z1e.d4) {
            this._w = k;
            this._x = f;
            this._y = i;
            this._z = j;
            return this;
        }
        var n = Math.sqrt(Z1e.d4 - m * m);
        if (Math.abs(n) < 0.001) {
            this._w = Z1e.k1 * (k + this._w);
            this._x = Z1e.k1 * (f + this._x);
            this._y = Z1e.k1 * (i + this._y);
            this._z = Z1e.k1 * (j + this._z);
            return this;
        }
        var u = Math.atan2(n, m), v = Math.sin((1 - e) * u) / n, B = Math.sin(e * u) / n;
        this._w = (k * v + this._w * B);
        this._x = (f * v + this._x * B);
        this._y = (i * v + this._y * B);
        this._z = (j * v + this._z * B);
        this.onChangeCallback();
        return this;
    }, equals: function (d) {
        return (d._x === this._x) && (d._y === this._y) && (d._z === this._z) && (d._w === this._w);
    }, fromArray: function (d, e) {
        if (e === undefined) e = 0;
        this._x = d[e];
        this._y = d[e + 1];
        this._z = d[e + 2];
        this._w = d[e + 3];
        this.onChangeCallback();
        return this;
    }, toArray: function (d, e) {
        if (d === undefined) d = [];
        if (e === undefined) e = 0;
        d[e] = this._x;
        d[e + 1] = this._y;
        d[e + 2] = this._z;
        d[e + 3] = this._w;
        return d;
    }, onChange: function (d) {
        this.onChangeCallback = d;
        return this;
    }, onChangeCallback: function () {
    }
};
Object.assign(THREE.Quaternion, {
    slerp: function (d, e, f, i) {
        return f.copy(d).slerp(e, i);
    }, slerpFlat: function (d, e, f, i, j, k, m) {
        var n = f[i + 0], u = f[i + 1], v = f[i + 2], B = f[i + 3], C = j[k + 0], G = j[k + 1], L = j[k + 2],
            N = j[k + 3];
        if (B !== N || n !== C || u !== G || v !== L) {
            var T = 1 - m, S = n * C + u * G + v * L + B * N, b0 = (S >= 0 ? 1 : -1), h0 = 1 - S * S;
            if (h0 > Number.EPSILON) {
                var f0 = Math.sqrt(h0), i0 = Math.atan2(f0, S * b0);
                T = Math.sin(T * i0) / f0;
                m = Math.sin(m * i0) / f0;
            }
            var s0 = m * b0;
            n = n * T + C * s0;
            u = u * T + G * s0;
            v = v * T + L * s0;
            B = B * T + N * s0;
            if (T === 1 - m) {
                var t0 = 1 / Math.sqrt(n * n + u * u + v * v + B * B);
                n *= t0;
                u *= t0;
                v *= t0;
                B *= t0;
            }
        }
        d[e] = n;
        d[e + 1] = u;
        d[e + 2] = v;
        d[e + 3] = B;
    }
});
THREE.Vector2 = function (d, e) {
    this.x = d || 0;
    this.y = e || 0;
};
THREE.Vector2.prototype = {
    constructor: THREE.Vector2, get width() {
        return this.x;
    }, set width(value) {
        this.x = value;
    }, get height() {
        return this.y;
    }, set height(value) {
        this.y = value;
    }, set: function (d, e) {
        this.x = d;
        this.y = e;
        return this;
    }, setScalar: function (d) {
        this.x = d;
        this.y = d;
        return this;
    }, setX: function (d) {
        this.x = d;
        return this;
    }, setY: function (d) {
        this.y = d;
        return this;
    }, setComponent: function (d, e) {
        switch (d) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw  new Error(Z1e.U2 + d);
        }
    }, getComponent: function (d) {
        switch (d) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw  new Error(Z1e.U2 + d);
        }
    }, clone: function () {
        return new this.constructor(this.x, this.y);
    }, copy: function (d) {
        this.x = d.x;
        this.y = d.y;
        return this;
    }, add: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(d, e);
        }
        this.x += d.x;
        this.y += d.y;
        return this;
    }, addScalar: function (d) {
        this.x += d;
        this.y += d;
        return this;
    }, addVectors: function (d, e) {
        this.x = d.x + e.x;
        this.y = d.y + e.y;
        return this;
    }, addScaledVector: function (d, e) {
        this.x += d.x * e;
        this.y += d.y * e;
        return this;
    }, sub: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(d, e);
        }
        this.x -= d.x;
        this.y -= d.y;
        return this;
    }, subScalar: function (d) {
        this.x -= d;
        this.y -= d;
        return this;
    }, subVectors: function (d, e) {
        this.x = d.x - e.x;
        this.y = d.y - e.y;
        return this;
    }, multiply: function (d) {
        this.x *= d.x;
        this.y *= d.y;
        return this;
    }, multiplyScalar: function (d) {
        if (isFinite(d)) {
            this.x *= d;
            this.y *= d;
        } else {
            this.x = 0;
            this.y = 0;
        }
        return this;
    }, divide: function (d) {
        this.x /= d.x;
        this.y /= d.y;
        return this;
    }, divideScalar: function (d) {
        return this.multiplyScalar(1 / d);
    }, min: function (d) {
        this.x = Math.min(this.x, d.x);
        this.y = Math.min(this.y, d.y);
        return this;
    }, max: function (d) {
        this.x = Math.max(this.x, d.x);
        this.y = Math.max(this.y, d.y);
        return this;
    }, clamp: function (d, e) {
        this.x = Math.max(d.x, Math.min(e.x, this.x));
        this.y = Math.max(d.y, Math.min(e.y, this.y));
        return this;
    }, clampScalar: function () {
        var f, i;
        return function j(d, e) {
            if (f === undefined) {
                f = new THREE.Vector2();
                i = new THREE.Vector2();
            }
            f.set(d, d);
            i.set(e, e);
            return this.clamp(f, i);
        };
    }(), clampLength: function (d, e) {
        var f = this.length();
        this.multiplyScalar(Math.max(d, Math.min(e, f)) / f);
        return this;
    }, floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }, ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    }, round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }, roundToZero: function () {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    }, negate: function () {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }, dot: function (d) {
        return this.x * d.x + this.y * d.y;
    }, lengthSq: function () {
        return this.x * this.x + this.y * this.y;
    }, length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }, lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y);
    }, normalize: function () {
        return this.divideScalar(this.length());
    }, angle: function () {
        var d = Math.atan2(this.y, this.x);
        if (d < 0) d += 2 * Math.PI;
        return d;
    }, distanceTo: function (d) {
        return Math.sqrt(this.distanceToSquared(d));
    }, distanceToSquared: function (d) {
        var e = this.x - d.x, f = this.y - d.y;
        return e * e + f * f;
    }, setLength: function (d) {
        return this.multiplyScalar(d / this.length());
    }, lerp: function (d, e) {
        this.x += (d.x - this.x) * e;
        this.y += (d.y - this.y) * e;
        return this;
    }, lerpVectors: function (d, e, f) {
        this.subVectors(e, d).multiplyScalar(f).add(d);
        return this;
    }, equals: function (d) {
        return ((d.x === this.x) && (d.y === this.y));
    }, fromArray: function (d, e) {
        if (e === undefined) e = 0;
        this.x = d[e];
        this.y = d[e + 1];
        return this;
    }, toArray: function (d, e) {
        if (d === undefined) d = [];
        if (e === undefined) e = 0;
        d[e] = this.x;
        d[e + 1] = this.y;
        return d;
    }, fromAttribute: function (d, e, f) {
        if (f === undefined) f = 0;
        e = e * d.itemSize + f;
        this.x = d.array[e];
        this.y = d.array[e + 1];
        return this;
    }, rotateAround: function (d, e) {
        var f = Math.cos(e), i = Math.sin(e), j = this.x - d.x, k = this.y - d.y;
        this.x = j * f - k * i + d.x;
        this.y = j * i + k * f + d.y;
        return this;
    }
};
THREE.Vector3 = function (d, e, f) {
    this.x = d || 0;
    this.y = e || 0;
    this.z = f || 0;
};
THREE.Vector3.prototype = {
    constructor: THREE.Vector3, set: function (d, e, f) {
        this.x = d;
        this.y = e;
        this.z = f;
        return this;
    }, setScalar: function (d) {
        this.x = d;
        this.y = d;
        this.z = d;
        return this;
    }, setX: function (d) {
        this.x = d;
        return this;
    }, setY: function (d) {
        this.y = d;
        return this;
    }, setZ: function (d) {
        this.z = d;
        return this;
    }, setComponent: function (d, e) {
        switch (d) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw  new Error(Z1e.U2 + d);
        }
    }, getComponent: function (d) {
        switch (d) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw  new Error(Z1e.U2 + d);
        }
    }, clone: function () {
        return new this.constructor(this.x, this.y, this.z);
    }, copy: function (d) {
        this.x = d.x;
        this.y = d.y;
        this.z = d.z;
        return this;
    }, add: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(d, e);
        }
        this.x += d.x;
        this.y += d.y;
        this.z += d.z;
        return this;
    }, addScalar: function (d) {
        this.x += d;
        this.y += d;
        this.z += d;
        return this;
    }, addVectors: function (d, e) {
        this.x = d.x + e.x;
        this.y = d.y + e.y;
        this.z = d.z + e.z;
        return this;
    }, addScaledVector: function (d, e) {
        this.x += d.x * e;
        this.y += d.y * e;
        this.z += d.z * e;
        return this;
    }, sub: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(d, e);
        }
        this.x -= d.x;
        this.y -= d.y;
        this.z -= d.z;
        return this;
    }, subScalar: function (d) {
        this.x -= d;
        this.y -= d;
        this.z -= d;
        return this;
    }, subVectors: function (d, e) {
        this.x = d.x - e.x;
        this.y = d.y - e.y;
        this.z = d.z - e.z;
        return this;
    }, multiply: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
            return this.multiplyVectors(d, e);
        }
        this.x *= d.x;
        this.y *= d.y;
        this.z *= d.z;
        return this;
    }, multiplyScalar: function (d) {
        if (isFinite(d)) {
            this.x *= d;
            this.y *= d;
            this.z *= d;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }
        return this;
    }, multiplyVectors: function (d, e) {
        this.x = d.x * e.x;
        this.y = d.y * e.y;
        this.z = d.z * e.z;
        return this;
    }, applyEuler: function () {
        var e;
        return function f(d) {
            if (d instanceof THREE.Euler === Z1e.e4) {
                console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
            }
            if (e === undefined) e = new THREE.Quaternion();
            this.applyQuaternion(e.setFromEuler(d));
            return this;
        };
    }(), applyAxisAngle: function () {
        var f;
        return function i(d, e) {
            if (f === undefined) f = new THREE.Quaternion();
            this.applyQuaternion(f.setFromAxisAngle(d, e));
            return this;
        };
    }(), applyMatrix3: function (d) {
        var e = this.x, f = this.y, i = this.z, j = d.elements;
        this.x = j[0] * e + j[3] * f + j[6] * i;
        this.y = j[1] * e + j[4] * f + j[7] * i;
        this.z = j[2] * e + j[5] * f + j[8] * i;
        return this;
    }, applyMatrix4: function (d) {
        var e = this.x, f = this.y, i = this.z, j = d.elements;
        this.x = j[0] * e + j[4] * f + j[8] * i + j[12];
        this.y = j[1] * e + j[5] * f + j[9] * i + j[13];
        this.z = j[2] * e + j[6] * f + j[10] * i + j[14];
        return this;
    }, applyProjection: function (d) {
        var e = this.x, f = this.y, i = this.z, j = d.elements, k = 1 / (j[3] * e + j[7] * f + j[11] * i + j[15]);
        this.x = (j[0] * e + j[4] * f + j[8] * i + j[12]) * k;
        this.y = (j[1] * e + j[5] * f + j[9] * i + j[13]) * k;
        this.z = (j[2] * e + j[6] * f + j[10] * i + j[14]) * k;
        return this;
    }, applyQuaternion: function (d) {
        var e = this.x, f = this.y, i = this.z, j = d.x, k = d.y, m = d.z, n = d.w, u = n * e + k * i - m * f,
            v = n * f + m * e - j * i, B = n * i + j * f - k * e, C = -j * e - k * f - m * i;
        this.x = u * n + C * -j + v * -m - B * -k;
        this.y = v * n + C * -k + B * -j - u * -m;
        this.z = B * n + C * -m + u * -k - v * -j;
        return this;
    }, project: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Matrix4();
            e.multiplyMatrices(d.projectionMatrix, e.getInverse(d.matrixWorld));
            return this.applyProjection(e);
        };
    }(), unproject: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Matrix4();
            e.multiplyMatrices(d.matrixWorld, e.getInverse(d.projectionMatrix));
            return this.applyProjection(e);
        };
    }(), transformDirection: function (d) {
        var e = this.x, f = this.y, i = this.z, j = d.elements;
        this.x = j[0] * e + j[4] * f + j[8] * i;
        this.y = j[1] * e + j[5] * f + j[9] * i;
        this.z = j[2] * e + j[6] * f + j[10] * i;
        this.normalize();
        return this;
    }, divide: function (d) {
        this.x /= d.x;
        this.y /= d.y;
        this.z /= d.z;
        return this;
    }, divideScalar: function (d) {
        return this.multiplyScalar(1 / d);
    }, min: function (d) {
        this.x = Math.min(this.x, d.x);
        this.y = Math.min(this.y, d.y);
        this.z = Math.min(this.z, d.z);
        return this;
    }, max: function (d) {
        this.x = Math.max(this.x, d.x);
        this.y = Math.max(this.y, d.y);
        this.z = Math.max(this.z, d.z);
        return this;
    }, clamp: function (d, e) {
        this.x = Math.max(d.x, Math.min(e.x, this.x));
        this.y = Math.max(d.y, Math.min(e.y, this.y));
        this.z = Math.max(d.z, Math.min(e.z, this.z));
        return this;
    }, clampScalar: function () {
        var f, i;
        return function j(d, e) {
            if (f === undefined) {
                f = new THREE.Vector3();
                i = new THREE.Vector3();
            }
            f.set(d, d, d);
            i.set(e, e, e);
            return this.clamp(f, i);
        };
    }(), clampLength: function (d, e) {
        var f = this.length();
        this.multiplyScalar(Math.max(d, Math.min(e, f)) / f);
        return this;
    }, floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    }, ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    }, round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    }, roundToZero: function () {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    }, negate: function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }, dot: function (d) {
        return this.x * d.x + this.y * d.y + this.z * d.z;
    }, lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }, length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }, lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }, normalize: function () {
        return this.divideScalar(this.length());
    }, setLength: function (d) {
        return this.multiplyScalar(d / this.length());
    }, lerp: function (d, e) {
        this.x += (d.x - this.x) * e;
        this.y += (d.y - this.y) * e;
        this.z += (d.z - this.z) * e;
        return this;
    }, lerpVectors: function (d, e, f) {
        this.subVectors(e, d).multiplyScalar(f).add(d);
        return this;
    }, cross: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
            return this.crossVectors(d, e);
        }
        var f = this.x, i = this.y, j = this.z;
        this.x = i * d.z - j * d.y;
        this.y = j * d.x - f * d.z;
        this.z = f * d.y - i * d.x;
        return this;
    }, crossVectors: function (d, e) {
        var f = d.x, i = d.y, j = d.z, k = e.x, m = e.y, n = e.z;
        this.x = i * n - j * m;
        this.y = j * k - f * n;
        this.z = f * m - i * k;
        return this;
    }, projectOnVector: function () {
        var e, f;
        return function i(d) {
            if (e === undefined) e = new THREE.Vector3();
            e.copy(d).normalize();
            f = this.dot(e);
            return this.copy(e).multiplyScalar(f);
        };
    }(), projectOnPlane: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Vector3();
            e.copy(this).projectOnVector(d);
            return this.sub(e);
        };
    }(), reflect: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Vector3();
            return this.sub(e.copy(d).multiplyScalar(2 * this.dot(d)));
        };
    }(), angleTo: function (d) {
        var e = this.dot(d) / (Math.sqrt(this.lengthSq() * d.lengthSq()));
        return Math.acos(THREE.Math.clamp(e, -1, 1));
    }, distanceTo: function (d) {
        return Math.sqrt(this.distanceToSquared(d));
    }, distanceToSquared: function (d) {
        var e = this.x - d.x, f = this.y - d.y, i = this.z - d.z;
        return e * e + f * f + i * i;
    }, setFromSpherical: function (d) {
        var e = Math.sin(d.phi) * d.radius;
        this.x = e * Math.sin(d.theta);
        this.y = Math.cos(d.phi) * d.radius;
        this.z = e * Math.cos(d.theta);
        return this;
    }, setFromMatrixPosition: function (d) {
        return this.setFromMatrixColumn(d, 3);
    }, setFromMatrixScale: function (d) {
        var e = this.setFromMatrixColumn(d, 0).length(), f = this.setFromMatrixColumn(d, 1).length(),
            i = this.setFromMatrixColumn(d, 2).length();
        this.x = e;
        this.y = f;
        this.z = i;
        return this;
    }, setFromMatrixColumn: function (d, e) {
        if (typeof d === Z1e.H3) {
            console.warn('THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).');
            d = arguments[1];
            e = arguments[0];
        }
        return this.fromArray(d.elements, e * 4);
    }, equals: function (d) {
        return ((d.x === this.x) && (d.y === this.y) && (d.z === this.z));
    }, fromArray: function (d, e) {
        if (e === undefined) e = 0;
        this.x = d[e];
        this.y = d[e + 1];
        this.z = d[e + 2];
        return this;
    }, toArray: function (d, e) {
        if (d === undefined) d = [];
        if (e === undefined) e = 0;
        d[e] = this.x;
        d[e + 1] = this.y;
        d[e + 2] = this.z;
        return d;
    }, fromAttribute: function (d, e, f) {
        if (f === undefined) f = 0;
        e = e * d.itemSize + f;
        this.x = d.array[e];
        this.y = d.array[e + 1];
        this.z = d.array[e + 2];
        return this;
    }
};
THREE.Vector4 = function (d, e, f, i) {
    this.x = d || 0;
    this.y = e || 0;
    this.z = f || 0;
    this.w = (i !== undefined) ? i : 1;
};
THREE.Vector4.prototype = {
    constructor: THREE.Vector4, set: function (d, e, f, i) {
        this.x = d;
        this.y = e;
        this.z = f;
        this.w = i;
        return this;
    }, setScalar: function (d) {
        this.x = d;
        this.y = d;
        this.z = d;
        this.w = d;
        return this;
    }, setX: function (d) {
        this.x = d;
        return this;
    }, setY: function (d) {
        this.y = d;
        return this;
    }, setZ: function (d) {
        this.z = d;
        return this;
    }, setW: function (d) {
        this.w = d;
        return this;
    }, setComponent: function (d, e) {
        switch (d) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw  new Error(Z1e.U2 + d);
        }
    }, getComponent: function (d) {
        switch (d) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw  new Error(Z1e.U2 + d);
        }
    }, clone: function () {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }, copy: function (d) {
        this.x = d.x;
        this.y = d.y;
        this.z = d.z;
        this.w = (d.w !== undefined) ? d.w : 1;
        return this;
    }, add: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(d, e);
        }
        this.x += d.x;
        this.y += d.y;
        this.z += d.z;
        this.w += d.w;
        return this;
    }, addScalar: function (d) {
        this.x += d;
        this.y += d;
        this.z += d;
        this.w += d;
        return this;
    }, addVectors: function (d, e) {
        this.x = d.x + e.x;
        this.y = d.y + e.y;
        this.z = d.z + e.z;
        this.w = d.w + e.w;
        return this;
    }, addScaledVector: function (d, e) {
        this.x += d.x * e;
        this.y += d.y * e;
        this.z += d.z * e;
        this.w += d.w * e;
        return this;
    }, sub: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(d, e);
        }
        this.x -= d.x;
        this.y -= d.y;
        this.z -= d.z;
        this.w -= d.w;
        return this;
    }, subScalar: function (d) {
        this.x -= d;
        this.y -= d;
        this.z -= d;
        this.w -= d;
        return this;
    }, subVectors: function (d, e) {
        this.x = d.x - e.x;
        this.y = d.y - e.y;
        this.z = d.z - e.z;
        this.w = d.w - e.w;
        return this;
    }, multiplyScalar: function (d) {
        if (isFinite(d)) {
            this.x *= d;
            this.y *= d;
            this.z *= d;
            this.w *= d;
        } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 0;
        }
        return this;
    }, applyMatrix4: function (d) {
        var e = this.x, f = this.y, i = this.z, j = this.w, k = d.elements;
        this.x = k[0] * e + k[4] * f + k[8] * i + k[12] * j;
        this.y = k[1] * e + k[5] * f + k[9] * i + k[13] * j;
        this.z = k[2] * e + k[6] * f + k[10] * i + k[14] * j;
        this.w = k[3] * e + k[7] * f + k[11] * i + k[15] * j;
        return this;
    }, divideScalar: function (d) {
        return this.multiplyScalar(1 / d);
    }, setAxisAngleFromQuaternion: function (d) {
        this.w = 2 * Math.acos(d.w);
        var e = Math.sqrt(1 - d.w * d.w);
        if (e < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = d.x / e;
            this.y = d.y / e;
            this.z = d.z / e;
        }
        return this;
    }, setAxisAngleFromRotationMatrix: function (d) {
        var e = 0.707106781, f, i, j, k, m = 0.01, n = 0.1, u = d.elements, v = u[0], B = u[4], C = u[8], G = u[1],
            L = u[5], N = u[9], T = u[2], S = u[6], b0 = u[10];
        if ((Math.abs(B - G) < m) && (Math.abs(C - T) < m) && (Math.abs(N - S) < m)) {
            if ((Math.abs(B + G) < n) && (Math.abs(C + T) < n) && (Math.abs(N + S) < n) && (Math.abs(v + L + b0 - 3) < n)) {
                this.set(1, 0, 0, 0);
                return this;
            }
            f = Math.PI;
            var h0 = (v + 1) / 2, f0 = (L + 1) / 2, i0 = (b0 + 1) / 2, s0 = (B + G) / 4, t0 = (C + T) / 4,
                o0 = (N + S) / 4;
            if ((h0 > f0) && (h0 > i0)) {
                if (h0 < m) {
                    i = 0;
                    j = e;
                    k = e;
                } else {
                    i = Math.sqrt(h0);
                    j = s0 / i;
                    k = t0 / i;
                }
            } else if (f0 > i0) {
                if (f0 < m) {
                    i = e;
                    j = 0;
                    k = e;
                } else {
                    j = Math.sqrt(f0);
                    i = s0 / j;
                    k = o0 / j;
                }
            } else {
                if (i0 < m) {
                    i = e;
                    j = e;
                    k = 0;
                } else {
                    k = Math.sqrt(i0);
                    i = t0 / k;
                    j = o0 / k;
                }
            }
            this.set(i, j, k, f);
            return this;
        }
        var w0 = Math.sqrt((S - N) * (S - N) + (C - T) * (C - T) + (G - B) * (G - B));
        if (Math.abs(w0) < 0.001) w0 = 1;
        this.x = (S - N) / w0;
        this.y = (C - T) / w0;
        this.z = (G - B) / w0;
        this.w = Math.acos((v + L + b0 - 1) / 2);
        return this;
    }, min: function (d) {
        this.x = Math.min(this.x, d.x);
        this.y = Math.min(this.y, d.y);
        this.z = Math.min(this.z, d.z);
        this.w = Math.min(this.w, d.w);
        return this;
    }, max: function (d) {
        this.x = Math.max(this.x, d.x);
        this.y = Math.max(this.y, d.y);
        this.z = Math.max(this.z, d.z);
        this.w = Math.max(this.w, d.w);
        return this;
    }, clamp: function (d, e) {
        this.x = Math.max(d.x, Math.min(e.x, this.x));
        this.y = Math.max(d.y, Math.min(e.y, this.y));
        this.z = Math.max(d.z, Math.min(e.z, this.z));
        this.w = Math.max(d.w, Math.min(e.w, this.w));
        return this;
    }, clampScalar: function () {
        var f, i;
        return function j(d, e) {
            if (f === undefined) {
                f = new THREE.Vector4();
                i = new THREE.Vector4();
            }
            f.set(d, d, d, d);
            i.set(e, e, e, e);
            return this.clamp(f, i);
        };
    }(), floor: function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    }, ceil: function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    }, round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    }, roundToZero: function () {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    }, negate: function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    }, dot: function (d) {
        return this.x * d.x + this.y * d.y + this.z * d.z + this.w * d.w;
    }, lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }, length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }, lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }, normalize: function () {
        return this.divideScalar(this.length());
    }, setLength: function (d) {
        return this.multiplyScalar(d / this.length());
    }, lerp: function (d, e) {
        this.x += (d.x - this.x) * e;
        this.y += (d.y - this.y) * e;
        this.z += (d.z - this.z) * e;
        this.w += (d.w - this.w) * e;
        return this;
    }, lerpVectors: function (d, e, f) {
        this.subVectors(e, d).multiplyScalar(f).add(d);
        return this;
    }, equals: function (d) {
        return ((d.x === this.x) && (d.y === this.y) && (d.z === this.z) && (d.w === this.w));
    }, fromArray: function (d, e) {
        if (e === undefined) e = 0;
        this.x = d[e];
        this.y = d[e + 1];
        this.z = d[e + 2];
        this.w = d[e + 3];
        return this;
    }, toArray: function (d, e) {
        if (d === undefined) d = [];
        if (e === undefined) e = 0;
        d[e] = this.x;
        d[e + 1] = this.y;
        d[e + 2] = this.z;
        d[e + 3] = this.w;
        return d;
    }, fromAttribute: function (d, e, f) {
        if (f === undefined) f = 0;
        e = e * d.itemSize + f;
        this.x = d.array[e];
        this.y = d.array[e + 1];
        this.z = d.array[e + 2];
        this.w = d.array[e + 3];
        return this;
    }
};
THREE.Euler = function (d, e, f, i) {
    this._x = d || 0;
    this._y = e || 0;
    this._z = f || 0;
    this._order = i || THREE.Euler.DefaultOrder;
};
THREE.Euler.RotationOrders = [Z1e.H1, Z1e.K, 'ZXY', 'XZY', 'YXZ', 'ZYX'];
THREE.Euler.DefaultOrder = Z1e.H1;
THREE.Euler.prototype = {
    constructor: THREE.Euler, get x() {
        return this._x;
    }, set x(value) {
        this._x = value;
        this.onChangeCallback();
    }, get y() {
        return this._y;
    }, set y(value) {
        this._y = value;
        this.onChangeCallback();
    }, get z() {
        return this._z;
    }, set z(value) {
        this._z = value;
        this.onChangeCallback();
    }, get order() {
        return this._order;
    }, set order(value) {
        this._order = value;
        this.onChangeCallback();
    }, set: function (d, e, f, i) {
        this._x = d;
        this._y = e;
        this._z = f;
        this._order = i || this._order;
        this.onChangeCallback();
        return this;
    }, clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }, copy: function (d) {
        this._x = d._x;
        this._y = d._y;
        this._z = d._z;
        this._order = d._order;
        this.onChangeCallback();
        return this;
    }, setFromRotationMatrix: function (d, e, f) {
        var i = THREE.Math.clamp, j = d.elements, k = j[0], m = j[4], n = j[8], u = j[1], v = j[5], B = j[9], C = j[2],
            G = j[6], L = j[10];
        e = e || this._order;
        if (e === Z1e.H1) {
            this._y = Math.asin(i(n, -1, 1));
            if (Math.abs(n) < Z1e.V1) {
                this._x = Math.atan2(-B, L);
                this._z = Math.atan2(-m, k);
            } else {
                this._x = Math.atan2(G, v);
                this._z = 0;
            }
        } else if (e === 'YXZ') {
            this._x = Math.asin(-i(B, -1, 1));
            if (Math.abs(B) < Z1e.V1) {
                this._y = Math.atan2(n, L);
                this._z = Math.atan2(u, v);
            } else {
                this._y = Math.atan2(-C, k);
                this._z = 0;
            }
        } else if (e === 'ZXY') {
            this._x = Math.asin(i(G, -1, 1));
            if (Math.abs(G) < Z1e.V1) {
                this._y = Math.atan2(-C, L);
                this._z = Math.atan2(-m, v);
            } else {
                this._y = 0;
                this._z = Math.atan2(u, k);
            }
        } else if (e === 'ZYX') {
            this._y = Math.asin(-i(C, -1, 1));
            if (Math.abs(C) < Z1e.V1) {
                this._x = Math.atan2(G, L);
                this._z = Math.atan2(u, k);
            } else {
                this._x = 0;
                this._z = Math.atan2(-m, v);
            }
        } else if (e === Z1e.K) {
            this._z = Math.asin(i(u, -1, 1));
            if (Math.abs(u) < Z1e.V1) {
                this._x = Math.atan2(-B, v);
                this._y = Math.atan2(-C, k);
            } else {
                this._x = 0;
                this._y = Math.atan2(n, L);
            }
        } else if (e === 'XZY') {
            this._z = Math.asin(-i(m, -1, 1));
            if (Math.abs(m) < Z1e.V1) {
                this._x = Math.atan2(G, v);
                this._y = Math.atan2(n, k);
            } else {
                this._x = Math.atan2(-B, L);
                this._y = 0;
            }
        } else {
            console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + e);
        }
        this._order = e;
        if (f !== Z1e.e4) this.onChangeCallback();
        return this;
    }, setFromQuaternion: function () {
        var i;
        return function (d, e, f) {
            if (i === undefined) i = new THREE.Matrix4();
            i.makeRotationFromQuaternion(d);
            this.setFromRotationMatrix(i, e, f);
            return this;
        };
    }(), setFromVector3: function (d, e) {
        return this.set(d.x, d.y, d.z, e || this._order);
    }, reorder: function () {
        var e = new THREE.Quaternion();
        return function (d) {
            e.setFromEuler(this);
            this.setFromQuaternion(e, d);
        };
    }(), equals: function (d) {
        return (d._x === this._x) && (d._y === this._y) && (d._z === this._z) && (d._order === this._order);
    }, fromArray: function (d) {
        this._x = d[0];
        this._y = d[1];
        this._z = d[2];
        if (d[3] !== undefined) this._order = d[3];
        this.onChangeCallback();
        return this;
    }, toArray: function (d, e) {
        if (d === undefined) d = [];
        if (e === undefined) e = 0;
        d[e] = this._x;
        d[e + 1] = this._y;
        d[e + 2] = this._z;
        d[e + 3] = this._order;
        return d;
    }, toVector3: function (d) {
        if (d) {
            return d.set(this._x, this._y, this._z);
        } else {
            return new THREE.Vector3(this._x, this._y, this._z);
        }
    }, onChange: function (d) {
        this.onChangeCallback = d;
        return this;
    }, onChangeCallback: function () {
    }
};
THREE.Line3 = function (d, e) {
    this.start = (d !== undefined) ? d : new THREE.Vector3();
    this.end = (e !== undefined) ? e : new THREE.Vector3();
};
THREE.Line3.prototype = {
    constructor: THREE.Line3, set: function (d, e) {
        this.start.copy(d);
        this.end.copy(e);
        return this;
    }, clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.start.copy(d.start);
        this.end.copy(d.end);
        return this;
    }, center: function (d) {
        var e = d || new THREE.Vector3();
        return e.addVectors(this.start, this.end).multiplyScalar(Z1e.k1);
    }, delta: function (d) {
        var e = d || new THREE.Vector3();
        return e.subVectors(this.end, this.start);
    }, distanceSq: function () {
        return this.start.distanceToSquared(this.end);
    }, distance: function () {
        return this.start.distanceTo(this.end);
    }, at: function (d, e) {
        var f = e || new THREE.Vector3();
        return this.delta(f).multiplyScalar(d).add(this.start);
    }, closestPointToPointParameter: function () {
        var k = new THREE.Vector3(), m = new THREE.Vector3();
        return function (d, e) {
            k.subVectors(d, this.start);
            m.subVectors(this.end, this.start);
            var f = m.dot(m), i = m.dot(k), j = i / f;
            if (e) {
                j = THREE.Math.clamp(j, 0, 1);
            }
            return j;
        };
    }(), closestPointToPoint: function (d, e, f) {
        var i = this.closestPointToPointParameter(d, e), j = f || new THREE.Vector3();
        return this.delta(j).multiplyScalar(i).add(this.start);
    }, applyMatrix4: function (d) {
        this.start.applyMatrix4(d);
        this.end.applyMatrix4(d);
        return this;
    }, equals: function (d) {
        return d.start.equals(this.start) && d.end.equals(this.end);
    }
};
THREE.Box2 = function (d, e) {
    this.min = (d !== undefined) ? d : new THREE.Vector2(+Infinity, +Infinity);
    this.max = (e !== undefined) ? e : new THREE.Vector2(-Infinity, -Infinity);
};
THREE.Box2.prototype = {
    constructor: THREE.Box2, set: function (d, e) {
        this.min.copy(d);
        this.max.copy(e);
        return this;
    }, setFromPoints: function (d) {
        this.makeEmpty();
        for (var e = 0, f = d.length; e < f; e++) {
            this.expandByPoint(d[e]);
        }
        return this;
    }, setFromCenterAndSize: function () {
        var i = new THREE.Vector2();
        return function (d, e) {
            var f = i.copy(e).multiplyScalar(Z1e.k1);
            this.min.copy(d).sub(f);
            this.max.copy(d).add(f);
            return this;
        };
    }(), clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.min.copy(d.min);
        this.max.copy(d.max);
        return this;
    }, makeEmpty: function () {
        this.min.x = this.min.y = +Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    }, isEmpty: function () {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y);
    }, center: function (d) {
        var e = d || new THREE.Vector2();
        return e.addVectors(this.min, this.max).multiplyScalar(Z1e.k1);
    }, size: function (d) {
        var e = d || new THREE.Vector2();
        return e.subVectors(this.max, this.min);
    }, expandByPoint: function (d) {
        this.min.min(d);
        this.max.max(d);
        return this;
    }, expandByVector: function (d) {
        this.min.sub(d);
        this.max.add(d);
        return this;
    }, expandByScalar: function (d) {
        this.min.addScalar(-d);
        this.max.addScalar(d);
        return this;
    }, containsPoint: function (d) {
        if (d.x < this.min.x || d.x > this.max.x || d.y < this.min.y || d.y > this.max.y) {
            return Z1e.e4;
        }
        return Z1e.n3;
    }, containsBox: function (d) {
        if ((this.min.x <= d.min.x) && (d.max.x <= this.max.x) && (this.min.y <= d.min.y) && (d.max.y <= this.max.y)) {
            return Z1e.n3;
        }
        return Z1e.e4;
    }, getParameter: function (d, e) {
        var f = e || new THREE.Vector2();
        return f.set((d.x - this.min.x) / (this.max.x - this.min.x), (d.y - this.min.y) / (this.max.y - this.min.y));
    }, intersectsBox: function (d) {
        if (d.max.x < this.min.x || d.min.x > this.max.x || d.max.y < this.min.y || d.min.y > this.max.y) {
            return Z1e.e4;
        }
        return Z1e.n3;
    }, clampPoint: function (d, e) {
        var f = e || new THREE.Vector2();
        return f.copy(d).clamp(this.min, this.max);
    }, distanceToPoint: function () {
        var f = new THREE.Vector2();
        return function (d) {
            var e = f.copy(d).clamp(this.min, this.max);
            return e.sub(d).length();
        };
    }(), intersect: function (d) {
        this.min.max(d.min);
        this.max.min(d.max);
        return this;
    }, union: function (d) {
        this.min.min(d.min);
        this.max.max(d.max);
        return this;
    }, translate: function (d) {
        this.min.add(d);
        this.max.add(d);
        return this;
    }, equals: function (d) {
        return d.min.equals(this.min) && d.max.equals(this.max);
    }
};
THREE.Box3 = function (d, e) {
    this.min = (d !== undefined) ? d : new THREE.Vector3(+Infinity, +Infinity, +Infinity);
    this.max = (e !== undefined) ? e : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
};
THREE.Box3.prototype = {
    constructor: THREE.Box3, set: function (d, e) {
        this.min.copy(d);
        this.max.copy(e);
        return this;
    }, setFromArray: function (d) {
        var e = +Infinity, f = +Infinity, i = +Infinity, j = -Infinity, k = -Infinity, m = -Infinity;
        for (var n = 0, u = d.length; n < u; n += 3) {
            var v = d[n], B = d[n + 1], C = d[n + 2];
            if (v < e) e = v;
            if (B < f) f = B;
            if (C < i) i = C;
            if (v > j) j = v;
            if (B > k) k = B;
            if (C > m) m = C;
        }
        this.min.set(e, f, i);
        this.max.set(j, k, m);
    }, setFromPoints: function (d) {
        this.makeEmpty();
        for (var e = 0, f = d.length; e < f; e++) {
            this.expandByPoint(d[e]);
        }
        return this;
    }, setFromCenterAndSize: function () {
        var i = new THREE.Vector3();
        return function (d, e) {
            var f = i.copy(e).multiplyScalar(Z1e.k1);
            this.min.copy(d).sub(f);
            this.max.copy(d).add(f);
            return this;
        };
    }(), setFromObject: function () {
        var u = new THREE.Vector3();
        return function (m) {
            var n = this;
            m.updateMatrixWorld(Z1e.n3);
            this.makeEmpty();
            m.traverse(function (d) {
                var e = d.geometry;
                if (e !== undefined) {
                    if (e instanceof THREE.Geometry) {
                        var f = e.vertices;
                        for (var i = 0, j = f.length; i < j; i++) {
                            u.copy(f[i]);
                            u.applyMatrix4(d.matrixWorld);
                            n.expandByPoint(u);
                        }
                    } else if (e instanceof THREE.BufferGeometry && e.attributes[Z1e.g1] !== undefined) {
                        var k = e.attributes[Z1e.g1].array;
                        for (var i = 0, j = k.length; i < j; i += 3) {
                            u.fromArray(k, i);
                            u.applyMatrix4(d.matrixWorld);
                            n.expandByPoint(u);
                        }
                    }
                }
            });
            return this;
        };
    }(), clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.min.copy(d.min);
        this.max.copy(d.max);
        return this;
    }, makeEmpty: function () {
        this.min.x = this.min.y = this.min.z = +Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    }, isEmpty: function () {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
    }, center: function (d) {
        var e = d || new THREE.Vector3();
        return e.addVectors(this.min, this.max).multiplyScalar(Z1e.k1);
    }, size: function (d) {
        var e = d || new THREE.Vector3();
        return e.subVectors(this.max, this.min);
    }, expandByPoint: function (d) {
        this.min.min(d);
        this.max.max(d);
        return this;
    }, expandByVector: function (d) {
        this.min.sub(d);
        this.max.add(d);
        return this;
    }, expandByScalar: function (d) {
        this.min.addScalar(-d);
        this.max.addScalar(d);
        return this;
    }, containsPoint: function (d) {
        if (d.x < this.min.x || d.x > this.max.x || d.y < this.min.y || d.y > this.max.y || d.z < this.min.z || d.z > this.max.z) {
            return Z1e.e4;
        }
        return Z1e.n3;
    }, containsBox: function (d) {
        if ((this.min.x <= d.min.x) && (d.max.x <= this.max.x) && (this.min.y <= d.min.y) && (d.max.y <= this.max.y) && (this.min.z <= d.min.z) && (d.max.z <= this.max.z)) {
            return Z1e.n3;
        }
        return Z1e.e4;
    }, getParameter: function (d, e) {
        var f = e || new THREE.Vector3();
        return f.set((d.x - this.min.x) / (this.max.x - this.min.x), (d.y - this.min.y) / (this.max.y - this.min.y), (d.z - this.min.z) / (this.max.z - this.min.z));
    }, intersectsBox: function (d) {
        if (d.max.x < this.min.x || d.min.x > this.max.x || d.max.y < this.min.y || d.min.y > this.max.y || d.max.z < this.min.z || d.min.z > this.max.z) {
            return Z1e.e4;
        }
        return Z1e.n3;
    }, intersectsSphere: (function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Vector3();
            this.clampPoint(d.center, e);
            return e.distanceToSquared(d.center) <= (d.radius * d.radius);
        };
    })(), intersectsPlane: function (d) {
        var e, f;
        if (d.normal.x > 0) {
            e = d.normal.x * this.min.x;
            f = d.normal.x * this.max.x;
        } else {
            e = d.normal.x * this.max.x;
            f = d.normal.x * this.min.x;
        }
        if (d.normal.y > 0) {
            e += d.normal.y * this.min.y;
            f += d.normal.y * this.max.y;
        } else {
            e += d.normal.y * this.max.y;
            f += d.normal.y * this.min.y;
        }
        if (d.normal.z > 0) {
            e += d.normal.z * this.min.z;
            f += d.normal.z * this.max.z;
        } else {
            e += d.normal.z * this.max.z;
            f += d.normal.z * this.min.z;
        }
        return (e <= d.constant && f >= d.constant);
    }, clampPoint: function (d, e) {
        var f = e || new THREE.Vector3();
        return f.copy(d).clamp(this.min, this.max);
    }, distanceToPoint: function () {
        var f = new THREE.Vector3();
        return function (d) {
            var e = f.copy(d).clamp(this.min, this.max);
            return e.sub(d).length();
        };
    }(), getBoundingSphere: function () {
        var f = new THREE.Vector3();
        return function (d) {
            var e = d || new THREE.Sphere();
            e.center = this.center();
            e.radius = this.size(f).length() * Z1e.k1;
            return e;
        };
    }(), intersect: function (d) {
        this.min.max(d.min);
        this.max.min(d.max);
        if (this.isEmpty()) this.makeEmpty();
        return this;
    }, union: function (d) {
        this.min.min(d.min);
        this.max.max(d.max);
        return this;
    }, applyMatrix4: function () {
        var e = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
        return function (d) {
            if (this.isEmpty())return this;
            e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(d);
            e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(d);
            e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(d);
            e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(d);
            e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(d);
            e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(d);
            e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(d);
            e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(d);
            this.setFromPoints(e);
            return this;
        };
    }(), translate: function (d) {
        this.min.add(d);
        this.max.add(d);
        return this;
    }, equals: function (d) {
        return d.min.equals(this.min) && d.max.equals(this.max);
    }
};
THREE.Matrix3 = function () {
    this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    if (arguments.length > 0) {
        console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
};
THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3, set: function (d, e, f, i, j, k, m, n, u) {
        var v = this.elements;
        v[0] = d;
        v[1] = i;
        v[2] = m;
        v[3] = e;
        v[4] = j;
        v[5] = n;
        v[6] = f;
        v[7] = k;
        v[8] = u;
        return this;
    }, identity: function () {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    }, clone: function () {
        return new this.constructor().fromArray(this.elements);
    }, copy: function (d) {
        var e = d.elements;
        this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]);
        return this;
    }, setFromMatrix4: function (d) {
        var e = d.elements;
        this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]);
        return this;
    }, applyToVector3Array: function () {
        var k;
        return function (d, e, f) {
            if (k === undefined) k = new THREE.Vector3();
            if (e === undefined) e = 0;
            if (f === undefined) f = d.length;
            for (var i = 0, j = e; i < f; i += 3, j += 3) {
                k.fromArray(d, j);
                k.applyMatrix3(this);
                k.toArray(d, j);
            }
            return d;
        };
    }(), applyToBuffer: function () {
        var k;
        return function m(d, e, f) {
            if (k === undefined) k = new THREE.Vector3();
            if (e === undefined) e = 0;
            if (f === undefined) f = d.length / d.itemSize;
            for (var i = 0, j = e; i < f; i++, j++) {
                k.x = d.getX(j);
                k.y = d.getY(j);
                k.z = d.getZ(j);
                k.applyMatrix3(this);
                d.setXYZ(k.x, k.y, k.z);
            }
            return d;
        };
    }(), multiplyScalar: function (d) {
        var e = this.elements;
        e[0] *= d;
        e[3] *= d;
        e[6] *= d;
        e[1] *= d;
        e[4] *= d;
        e[7] *= d;
        e[2] *= d;
        e[5] *= d;
        e[8] *= d;
        return this;
    }, determinant: function () {
        var d = this.elements, e = d[0], f = d[1], i = d[2], j = d[3], k = d[4], m = d[5], n = d[6], u = d[7], v = d[8];
        return e * k * v - e * m * u - f * j * v + f * m * n + i * j * u - i * k * n;
    }, getInverse: function (d, e) {
        if (d instanceof THREE.Matrix4) {
            console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
        }
        var f = d.elements, i = this.elements, j = f[0], k = f[1], m = f[2], n = f[3], u = f[4], v = f[5], B = f[6],
            C = f[7], G = f[8], L = G * u - v * C, N = v * B - G * n, T = C * n - u * B, S = j * L + k * N + m * T;
        if (S === 0) {
            var b0 = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
            if (e || Z1e.e4) {
                throw  new Error(b0);
            } else {
                console.warn(b0);
            }
            return this.identity();
        }
        i[0] = L;
        i[1] = m * C - G * k;
        i[2] = v * k - m * u;
        i[3] = N;
        i[4] = G * j - m * B;
        i[5] = m * n - v * j;
        i[6] = T;
        i[7] = k * B - C * j;
        i[8] = u * j - k * n;
        return this.multiplyScalar(1 / S);
    }, transpose: function () {
        var d, e = this.elements;
        d = e[1];
        e[1] = e[3];
        e[3] = d;
        d = e[2];
        e[2] = e[6];
        e[6] = d;
        d = e[5];
        e[5] = e[7];
        e[7] = d;
        return this;
    }, flattenToArrayOffset: function (d, e) {
        console.warn(Z1e.J0 + Z1e.V2);
        return this.toArray(d, e);
    }, getNormalMatrix: function (d) {
        return this.setFromMatrix4(d).getInverse(this).transpose();
    }, transposeIntoArray: function (d) {
        var e = this.elements;
        d[0] = e[0];
        d[1] = e[3];
        d[2] = e[6];
        d[3] = e[1];
        d[4] = e[4];
        d[5] = e[7];
        d[6] = e[2];
        d[7]

= e[5];
        d[8] = e[8];
        return this;
    }, fromArray: function (d) {
        this.elements.set(d);
        return this;
    }, toArray: function (d, e) {
        if (d === undefined) d = [];
        if (e === undefined) e = 0;
        var f = this.elements;
        d[e] = f[0];
        d[e + 1] = f[1];
        d[e + 2] = f[2];
        d[e + 3] = f[3];
        d[e + 4] = f[4];
        d[e + 5] = f[5];
        d[e + 6] = f[6];
        d[e + 7] = f[7];
        d[e + 8] = f[8];
        return d;
    }
};
THREE.Matrix4 = function () {
    this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    if (arguments.length > 0) {
        console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
};
THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4, set: function (d, e, f, i, j, k, m, n, u, v, B, C, G, L, N, T) {
        var S = this.elements;
        S[0] = d;
        S[4] = e;
        S[8] = f;
        S[12] = i;
        S[1] = j;
        S[5] = k;
        S[9] = m;
        S[13] = n;
        S[2] = u;
        S[6] = v;
        S[10] = B;
        S[14] = C;
        S[3] = G;
        S[7] = L;
        S[11] = N;
        S[15] = T;
        return this;
    }, identity: function () {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }, clone: function () {
        return new THREE.Matrix4().fromArray(this.elements);
    }, copy: function (d) {
        this.elements.set(d.elements);
        return this;
    }, copyPosition: function (d) {
        var e = this.elements, f = d.elements;
        e[12] = f[12];
        e[13] = f[13];
        e[14] = f[14];
        return this;
    }, extractBasis: function (d, e, f) {
        d.setFromMatrixColumn(this, 0);
        e.setFromMatrixColumn(this, 1);
        f.setFromMatrixColumn(this, 2);
        return this;
    }, makeBasis: function (d, e, f) {
        this.set(d.x, e.x, f.x, 0, d.y, e.y, f.y, 0, d.z, e.z, f.z, 0, 0, 0, 0, 1);
        return this;
    }, extractRotation: function () {
        var m;
        return function (d) {
            if (m === undefined) m = new THREE.Vector3();
            var e = this.elements, f = d.elements, i = 1 / m.setFromMatrixColumn(d, 0).length(),
                j = 1 / m.setFromMatrixColumn(d, 1).length(), k = 1 / m.setFromMatrixColumn(d, 2).length();
            e[0] = f[0] * i;
            e[1] = f[1] * i;
            e[2] = f[2] * i;
            e[4] = f[4] * j;
            e[5] = f[5] * j;
            e[6] = f[6] * j;
            e[8] = f[8] * k;
            e[9] = f[9] * k;
            e[10] = f[10] * k;
            return this;
        };
    }(), makeRotationFromEuler: function (d) {
        if (d instanceof THREE.Euler === Z1e.e4) {
            console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var e = this.elements, f = d.x, i = d.y, j = d.z, k = Math.cos(f), m = Math.sin(f), n = Math.cos(i),
            u = Math.sin(i), v = Math.cos(j), B = Math.sin(j);
        if (d.order === Z1e.H1) {
            var C = k * v, G = k * B, L = m * v, N = m * B;
            e[0] = n * v;
            e[4] = -n * B;
            e[8] = u;
            e[1] = G + L * u;
            e[5] = C - N * u;
            e[9] = -m * n;
            e[2] = N - C * u;
            e[6] = L + G * u;
            e[10] = k * n;
        } else if (d.order === 'YXZ') {
            var T = n * v, S = n * B, b0 = u * v, h0 = u * B;
            e[0] = T + h0 * m;
            e[4] = b0 * m - S;
            e[8] = k * u;
            e[1] = k * B;
            e[5] = k * v;
            e[9] = -m;
            e[2] = S * m - b0;
            e[6] = h0 + T * m;
            e[10] = k * n;
        } else if (d.order === 'ZXY') {
            var T = n * v, S = n * B, b0 = u * v, h0 = u * B;
            e[0] = T - h0 * m;
            e[4] = -k * B;
            e[8] = b0 + S * m;
            e[1] = S + b0 * m;
            e[5] = k * v;
            e[9] = h0 - T * m;
            e[2] = -k * u;
            e[6] = m;
            e[10] = k * n;
        } else if (d.order === 'ZYX') {
            var C = k * v, G = k * B, L = m * v, N = m * B;
            e[0] = n * v;
            e[4] = L * u - G;
            e[8] = C * u + N;
            e[1] = n * B;
            e[5] = N * u + C;
            e[9] = G * u - L;
            e[2] = -u;
            e[6] = m * n;
            e[10] = k * n;
        } else if (d.order === Z1e.K) {
            var f0 = k * n, i0 = k * u, s0 = m * n, t0 = m * u;
            e[0] = n * v;
            e[4] = t0 - f0 * B;
            e[8] = s0 * B + i0;
            e[1] = B;
            e[5] = k * v;
            e[9] = -m * v;
            e[2] = -u * v;
            e[6] = i0 * B + s0;
            e[10] = f0 - t0 * B;
        } else if (d.order === 'XZY') {
            var f0 = k * n, i0 = k * u, s0 = m * n, t0 = m * u;
            e[0] = n * v;
            e[4] = -B;
            e[8] = u * v;
            e[1] = f0 * B + t0;
            e[5] = k * v;
            e[9] = i0 * B - s0;
            e[2] = s0 * B - i0;
            e[6] = m * v;
            e[10] = t0 * B + f0;
        }
        e[3] = 0;
        e[7] = 0;
        e[11] = 0;
        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
        return this;
    }, makeRotationFromQuaternion: function (d) {
        var e = this.elements, f = d.x, i = d.y, j = d.z, k = d.w, m = f + f, n = i + i, u = j + j, v = f * m,
            B = f * n, C = f * u, G = i * n, L = i * u, N = j * u, T = k * m, S = k * n, b0 = k * u;
        e[0] = 1 - (G + N);
        e[4] = B - b0;
        e[8] = C + S;
        e[1] = B + b0;
        e[5] = 1 - (v + N);
        e[9] = L - T;
        e[2] = C - S;
        e[6] = L + T;
        e[10] = 1 - (v + G);
        e[3] = 0;
        e[7] = 0;
        e[11] = 0;
        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
        return this;
    }, lookAt: function () {
        var j, k, m;
        return function (d, e, f) {
            if (j === undefined) j = new THREE.Vector3();
            if (k === undefined) k = new THREE.Vector3();
            if (m === undefined) m = new THREE.Vector3();
            var i = this.elements;
            m.subVectors(d, e).normalize();
            if (m.lengthSq() === 0) {
                m.z = 1;
            }
            j.crossVectors(f, m).normalize();
            if (j.lengthSq() === 0) {
                m.x += 0.0001;
                j.crossVectors(f, m).normalize();
            }
            k.crossVectors(m, j);
            i[0] = j.x;
            i[4] = k.x;
            i[8] = m.x;
            i[1] = j.y;
            i[5] = k.y;
            i[9] = m.y;
            i[2] = j.z;
            i[6] = k.z;
            i[10] = m.z;
            return this;
        };
    }(), multiply: function (d, e) {
        if (e !== undefined) {
            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
            return this.multiplyMatrices(d, e);
        }
        return this.multiplyMatrices(this, d);
    }, premultiply: function (d) {
        return this.multiplyMatrices(d, this);
    }, multiplyMatrices: function (d, e) {
        var f = d.elements, i = e.elements, j = this.elements, k = f[0], m = f[4], n = f[8], u = f[12], v = f[1],
            B = f[5], C = f[9], G = f[13], L = f[2], N = f[6], T = f[10], S = f[14], b0 = f[3], h0 = f[7], f0 = f[11],
            i0 = f[15], s0 = i[0], t0 = i[4], o0 = i[8], w0 = i[12], x0 = i[1], D0 = i[5], F0 = i[9], m0 = i[13],
            W0 = i[2], y0 = i[6], P0 = i[10], M0 = i[14], G0 = i[3], a1 = i[7], b1 = i[11], X0 = i[15];
        j[0] = k * s0 + m * x0 + n * W0 + u * G0;
        j[4] = k * t0 + m * D0 + n * y0 + u * a1;
        j[8] = k * o0 + m * F0 + n * P0 + u * b1;
        j[12] = k * w0 + m * m0 + n * M0 + u * X0;
        j[1] = v * s0 + B * x0 + C * W0 + G * G0;
        j[5] = v * t0 + B * D0 + C * y0 + G * a1;
        j[9] = v * o0 + B * F0 + C * P0 + G * b1;
        j[13] = v * w0 + B * m0 + C * M0 + G * X0;
        j[2] = L * s0 + N * x0 + T * W0 + S * G0;
        j[6] = L * t0 + N * D0 + T * y0 + S * a1;
        j[10] = L * o0 + N * F0 + T * P0 + S * b1;
        j[14] = L * w0 + N * m0 + T * M0 + S * X0;
        j[3] = b0 * s0 + h0 * x0 + f0 * W0 + i0 * G0;
        j[7] = b0 * t0 + h0 * D0 + f0 * y0 + i0 * a1;
        j[11] = b0 * o0 + h0 * F0 + f0 * P0 + i0 * b1;
        j[15] = b0 * w0 + h0 * m0 + f0 * M0 + i0 * X0;
        return this;
    }, multiplyToArray: function (d, e, f) {
        var i = this.elements;
        this.multiplyMatrices(d, e);
        f[0] = i[0];
        f[1] = i[1];
        f[2] = i[2];
        f[3] = i[3];
        f[4] = i[4];
        f[5] = i[5];
        f[6] = i[6];
        f[7] = i[7];
        f[8] = i[8];
        f[9] = i[9];
        f[10] = i[10];
        f[11] = i[11];
        f[12] = i[12];
        f[13] = i[13];
        f[14] = i[14];
        f[15] = i[15];
        return this;
    }, multiplyScalar: function (d) {
        var e = this.elements;
        e[0] *= d;
        e[4] *= d;
        e[8] *= d;
        e[12] *= d;
        e[1] *= d;
        e[5] *= d;
        e[9] *= d;
        e[13] *= d;
        e[2] *= d;
        e[6] *= d;
        e[10] *= d;
        e[14] *= d;
        e[3] *= d;
        e[7] *= d;
        e[11] *= d;
        e[15] *= d;
        return this;
    }, applyToVector3Array: function () {
        var k;
        return function (d, e, f) {
            if (k === undefined) k = new THREE.Vector3();
            if (e === undefined) e = 0;
            if (f === undefined) f = d.length;
            for (var i = 0, j = e; i < f; i += 3, j += 3) {
                k.fromArray(d, j);
                k.applyMatrix4(this);
                k.toArray(d, j);
            }
            return d;
        };
    }(), applyToBuffer: function () {
        var k;
        return function m(d, e, f) {
            if (k === undefined) k = new THREE.Vector3();
            if (e === undefined) e = 0;
            if (f === undefined) f = d.length / d.itemSize;
            for (var i = 0, j = e; i < f; i++, j++) {
                k.x = d.getX(j);
                k.y = d.getY(j);
                k.z = d.getZ(j);
                k.applyMatrix4(this);
                d.setXYZ(k.x, k.y, k.z);
            }
            return d;
        };
    }(), determinant: function () {
        var d = this.elements, e = d[0], f = d[4], i = d[8], j = d[12], k = d[1], m = d[5], n = d[9], u = d[13],
            v = d[2], B = d[6], C = d[10], G = d[14], L = d[3], N = d[7], T = d[11], S = d[15];
        return (L * (+j * n * B - i * u * B - j * m * C + f * u * C + i * m * G - f * n * G) + N * (+e * n * G - e * u * C + j * k * C - i * k * G + i * u * v - j * n * v) + T * (+e * u * B - e * m * G - j * k * B + f * k * G + j * m * v - f * u * v) + S * (-i * m * v - e * n * B + e * m * C + i * k * B - f * k * C + f * n * v));
    }, transpose: function () {
        var d = this.elements, e;
        e = d[1];
        d[1] = d[4];
        d[4] = e;
        e = d[2];
        d[2] = d[8];
        d[8] = e;
        e = d[6];
        d[6] = d[9];
        d[9] = e;
        e = d[3];
        d[3] = d[12];
        d[12] = e;
        e = d[7];
        d[7] = d[13];
        d[13] = e;
        e = d[11];
        d[11] = d[14];
        d[14] = e;
        return this;
    }, flattenToArrayOffset: function (d, e) {
        console.warn(Z1e.J0 + Z1e.V2);
        return this.toArray(d, e);
    }, getPosition: function () {
        var d;
        return function () {
            if (d === undefined) d = new THREE.Vector3();
            console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
            return d.setFromMatrixColumn(this, 3);
        };
    }(), setPosition: function (d) {
        var e = this.elements;
        e[12] = d.x;
        e[13] = d.y;
        e[14] = d.z;
        return this;
    }, getInverse: function (d, e) {
        var f = this.elements, i = d.elements, j = i[0], k = i[1], m = i[2], n = i[3], u = i[4], v = i[5], B = i[6],
            C = i[7], G = i[8], L = i[9], N = i[10], T = i[11], S = i[12], b0 = i[13], h0 = i[14], f0 = i[15],
            i0 = L * h0 * C - b0 * N * C + b0 * B * T - v * h0 * T - L * B * f0 + v * N * f0,
            s0 = S * N * C - G * h0 * C - S * B * T + u * h0 * T + G * B * f0 - u * N * f0,
            t0 = G * b0 * C - S * L * C + S * v * T - u * b0 * T - G * v * f0 + u * L * f0,
            o0 = S * L * B - G * b0 * B - S * v * N + u * b0 * N + G * v * h0 - u * L * h0,
            w0 = j * i0 + k * s0 + m * t0 + n * o0;
        if (w0 === 0) {
            var x0 = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
            if (e || Z1e.e4) {
                throw  new Error(x0);
            } else {
                console.warn(x0);
            }
            return this.identity();
        }
        f[0] = i0;
        f[1] = b0 * N * n - L * h0 * n - b0 * m * T + k * h0 * T + L * m * f0 - k * N * f0;
        f[2] = v * h0 * n - b0 * B * n + b0 * m * C - k * h0 * C - v * m * f0 + k * B * f0;
        f[3] = L * B * n - v * N * n - L * m * C + k * N * C + v * m * T - k * B * T;
        f[4] = s0;
        f[5] = G * h0 * n - S * N * n + S * m * T - j * h0 * T - G * m * f0 + j * N * f0;
        f[6] = S * B * n - u * h0 * n - S * m * C + j * h0 * C + u * m * f0 - j * B * f0;
        f[7] = u * N * n - G * B * n + G * m * C - j * N * C - u * m * T + j * B * T;
        f[8] = t0;
        f[9] = S * L * n - G * b0 * n - S * k * T + j * b0 * T + G * k * f0 - j * L * f0;
        f[10] = u * b0 * n - S * v * n + S * k * C - j * b0 * C - u * k * f0 + j * v * f0;
        f[11] = G * v * n - u * L * n - G * k * C + j * L * C + u * k * T - j * v * T;
        f[12] = o0;
        f[13] = G * b0 * m - S * L * m + S * k * N - j * b0 * N - G * k * h0 + j * L * h0;
        f[14] = S * v * m - u * b0 * m - S * k * B + j * b0 * B + u * k * h0 - j * v * h0;
        f[15] = u * L * m - G * v * m + G * k * B - j * L * B - u * k * N + j * v * N;
        return this.multiplyScalar(1 / w0);
    }, scale: function (d) {
        var e = this.elements, f = d.x, i = d.y, j = d.z;
        e[0] *= f;
        e[4] *= i;
        e[8] *= j;
        e[1] *= f;
        e[5] *= i;
        e[9] *= j;
        e[2] *= f;
        e[6] *= i;
        e[10] *= j;
        e[3] *= f;
        e[7] *= i;
        e[11] *= j;
        return this;
    }, getMaxScaleOnAxis: function () {
        var d = this.elements, e = d[0] * d[0] + d[1] * d[1] + d[2] * d[2], f = d[4] * d[4] + d[5] * d[5] + d[6] * d[6],
            i = d[8] * d[8] + d[9] * d[9] + d[10] * d[10];
        return Math.sqrt(Math.max(e, f, i));
    }, makeTranslation: function (d, e, f) {
        this.set(1, 0, 0, d, 0, 1, 0, e, 0, 0, 1, f, 0, 0, 0, 1);
        return this;
    }, makeRotationX: function (d) {
        var e = Math.cos(d), f = Math.sin(d);
        this.set(1, 0, 0, 0, 0, e, -f, 0, 0, f, e, 0, 0, 0, 0, 1);
        return this;
    }, makeRotationY: function (d) {
        var e = Math.cos(d), f = Math.sin(d);
        this.set(e, 0, f, 0, 0, 1, 0, 0, -f, 0, e, 0, 0, 0, 0, 1);
        return this;
    }, makeRotationZ: function (d) {
        var e = Math.cos(d), f = Math.sin(d);
        this.set(e, -f, 0, 0, f, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }, makeRotationAxis: function (d, e) {
        var f = Math.cos(e), i = Math.sin(e), j = 1 - f, k = d.x, m = d.y, n = d.z, u = j * k, v = j * m;
        this.set(u * k + f, u * m - i * n, u * n + i * m, 0, u * m + i * n, v * m + f, v * n - i * k, 0, u * n - i * m, v * n + i * k, j * n * n + f, 0, 0, 0, 0, 1);
        return this;
    }, makeScale: function (d, e, f) {
        this.set(d, 0, 0, 0, 0, e, 0, 0, 0, 0, f, 0, 0, 0, 0, 1);
        return this;
    }, compose: function (d, e, f) {
        this.makeRotationFromQuaternion(e);
        this.scale(f);
        this.setPosition(d);
        return this;
    }, decompose: function () {
        var C, G;
        return function (d, e, f) {
            if (C === undefined) C = new THREE.Vector3();
            if (G === undefined) G = new THREE.Matrix4();
            var i = this.elements, j = C.set(i[0], i[1], i[2]).length(), k = C.set(i[4], i[5], i[6]).length(),
                m = C.set(i[8], i[9], i[10]).length(), n = this.determinant();
            if (n < 0) {
                j = -j;
            }
            d.x = i[12];
            d.y = i[13];
            d.z = i[14];
            G.elements.set(this.elements);
            var u = 1 / j, v = 1 / k, B = 1 / m;
            G.elements[0] *= u;
            G.elements[1] *= u;
            G.elements[2] *= u;
            G.elements[4] *= v;
            G.elements[5] *= v;
            G.elements[6] *= v;
            G.elements[8] *= B;
            G.elements[9] *= B;
            G.elements[10] *= B;
            e.setFromRotationMatrix(G);
            f.x = j;
            f.y = k;
            f.z = m;
            return this;
        };
    }(), makeFrustum: function (d, e, f, i, j, k) {
        var m = this.elements, n = 2 * j / (e - d), u = 2 * j / (i - f), v = (e + d) / (e - d), B = (i + f) / (i - f),
            C = -(k + j) / (k - j), G = -2 * k * j / (k - j);
        m[0] = n;
        m[4] = 0;
        m[8] = v;
        m[12] = 0;
        m[1] = 0;
        m[5] = u;
        m[9] = B;
        m[13] = 0;
        m[2] = 0;
        m[6] = 0;
        m[10] = C;
        m[14] = G;
        m[3] = 0;
        m[7] = 0;
        m[11] = -1;
        m[15] = 0;
        return this;
    }, makePerspective: function (d, e, f, i) {
        var j = f * Math.tan(THREE.Math.DEG2RAD * d * Z1e.k1), k = -j, m = k * e, n = j * e;
        return this.makeFrustum(m, n, k, j, f, i);
    }, makeOrthographic: function (d, e, f, i, j, k) {
        var m = this.elements, n = Z1e.d4 / (e - d), u = Z1e.d4 / (f - i), v = Z1e.d4 / (k - j), B = (e + d) * n,
            C = (f + i) * u, G = (k + j) * v;
        m[0] = 2 * n;
        m[4] = 0;
        m[8] = 0;
        m[12] = -B;
        m[1] = 0;
        m[5] = 2 * u;
        m[9] = 0;
        m[13] = -C;
        m[2] = 0;
        m[6] = 0;
        m[10] = -2 * v;
        m[14] = -G;
        m[3] = 0;
        m[7] = 0;
        m[11] = 0;
        m[15] = 1;
        return this;
    }, equals: function (d) {
        var e = this.elements, f = d.elements;
        for (var i = 0; i < 16; i++) {
            if (e[i] !== f[i])return Z1e.e4;
        }
        return Z1e.n3;
    }, fromArray: function (d) {
        this.elements.set(d);
        return this;
    }, toArray: function (d, e) {
        if (d === undefined) d = [];
        if (e === undefined) e = 0;
        var f = this.elements;
        d[e] = f[0];
        d[e + 1] = f[1];
        d[e + 2] = f[2];
        d[e + 3] = f[3];
        d[e + 4] = f[4];
        d[e + 5] = f[5];
        d[e + 6] = f[6];
        d[e + 7] = f[7];
        d[e + 8] = f[8];
        d[e + 9] = f[9];
        d[e + 10] = f[10];
        d[e + 11] = f[11];
        d[e + 12] = f[12];
        d[e + 13] = f[13];
        d[e + 14] = f[14];
        d[e + 15] = f[15];
        return d;
    }
};
THREE.Ray = function (d, e) {
    this.origin = (d !== undefined) ? d : new THREE.Vector3();
    this.direction = (e !== undefined) ? e : new THREE.Vector3();
};
THREE.Ray.prototype = {
    constructor: THREE.Ray, set: function (d, e) {
        this.origin.copy(d);
        this.direction.copy(e);
        return this;
    }, clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.origin.copy(d.origin);
        this.direction.copy(d.direction);
        return this;
    }, at: function (d, e) {
        var f = e || new THREE.Vector3();
        return f.copy(this.direction).multiplyScalar(d).add(this.origin);
    }, lookAt: function (d) {
        this.direction.copy(d).sub(this.origin).normalize();
    }, recast: function () {
        var e = new THREE.Vector3();
        return function (d) {
            this.origin.copy(this.at(d, e));
            return this;
        };
    }(), closestPointToPoint: function (d, e) {
        var f = e || new THREE.Vector3();
        f.subVectors(d, this.origin);
        var i = f.dot(this.direction);
        if (i < 0) {
            return f.copy(this.origin);
        }
        return f.copy(this.direction).multiplyScalar(i).add(this.origin);
    }, distanceToPoint: function (d) {
        return Math.sqrt(this.distanceSqToPoint(d));
    }, distanceSqToPoint: function () {
        var f = new THREE.Vector3();
        return function (d) {
            var e = f.subVectors(d, this.origin).dot(this.direction);
            if (e < 0) {
                return this.origin.distanceToSquared(d);
            }
            f.copy(this.direction).multiplyScalar(e).add(this.origin);
            return f.distanceToSquared(d);
        };
    }(), distanceSqToSegment: function () {
        var T = new THREE.Vector3(), S = new THREE.Vector3(), b0 = new THREE.Vector3();
        return function (d, e, f, i) {
            T.copy(d).add(e).multiplyScalar(Z1e.k1);
            S.copy(e).sub(d).normalize();
            b0.copy(this.origin).sub(T);
            var j = d.distanceTo(e) * Z1e.k1, k = -this.direction.dot(S), m = b0.dot(this.direction), n = -b0.dot(S),
                u = b0.lengthSq(), v = Math.abs(1 - k * k), B, C, G, L;
            if (v > 0) {
                B = k * n - m;
                C = k * m - n;
                L = j * v;
                if (B >= 0) {
                    if (C >= -L) {
                        if (C <= L) {
                            var N = 1 / v;
                            B *= N;
                            C *= N;
                            G = B * (B + k * C + 2 * m) + C * (k * B + C + 2 * n) + u;
                        } else {
                            C = j;
                            B = Math.max(0, -(k * C + m));
                            G = -B * B + C * (C + 2 * n) + u;
                        }
                    } else {
                        C = -j;
                        B = Math.max(0, -(k * C + m));
                        G = -B * B + C * (C + 2 * n) + u;
                    }
                } else {
                    if (C <= -L) {
                        B = Math.max(0, -(-k * j + m));
                        C = (B > 0) ? -j : Math.min(Math.max(-j, -n), j);
                        G = -B * B + C * (C + 2 * n) + u;
                    } else if (C <= L) {
                        B = 0;
                        C = Math.min(Math.max(-j, -n), j);
                        G = C * (C + 2 * n) + u;
                    } else {
                        B = Math.max(0, -(k * j + m));
                        C = (B > 0) ? j : Math.min(Math.max(-j, -n), j);
                        G = -B * B + C * (C + 2 * n) + u;
                    }
                }
            } else {
                C = (k > 0) ? -j : j;
                B = Math.max(0, -(k * C + m));
                G = -B * B + C * (C + 2 * n) + u;
            }
            if (f) {
                f.copy(this.direction).multiplyScalar(B).add(this.origin);
            }
            if (i) {
                i.copy(S).multiplyScalar(C).add(T);
            }
            return G;
        };
    }(), intersectSphere: function () {
        var u = new THREE.Vector3();
        return function (d, e) {
            u.subVectors(d.center, this.origin);
            var f = u.dot(this.direction), i = u.dot(u) - f * f, j = d.radius * d.radius;
            if (i > j)return Z1e.l3;
            var k = Math.sqrt(j - i), m = f - k, n = f + k;
            if (m < 0 && n < 0)return Z1e.l3;
            if (m < 0)return this.at(n, e);
            return this.at(m, e);
        };
    }(), intersectsSphere: function (d) {
        return this.distanceToPoint(d.center) <= d.radius;
    }, distanceToPlane: function (d) {
        var e = d.normal.dot(this.direction);
        if (e === 0) {
            if (d.distanceToPoint(this.origin) === 0) {
                return 0;
            }
            return Z1e.l3;
        }
        var f = -(this.origin.dot(d.normal) + d.constant) / e;
        return f >= 0 ? f : Z1e.l3;
    }, intersectPlane: function (d, e) {
        var f = this.distanceToPlane(d);
        if (f === Z1e.l3) {
            return Z1e.l3;
        }
        return this.at(f, e);
    }, intersectsPlane: function (d) {
        var e = d.distanceToPoint(this.origin);
        if (e === 0) {
            return Z1e.n3;
        }
        var f = d.normal.dot(this.direction);
        if (f * e < 0) {
            return Z1e.n3;
        }
        return Z1e.e4;
    }, intersectBox: function (d, e) {
        var f, i, j, k, m, n, u = 1 / this.direction.x, v = 1 / this.direction.y, B = 1 / this.direction.z,
            C = this.origin;
        if (u >= 0) {
            f = (d.min.x - C.x) * u;
            i = (d.max.x - C.x) * u;
        } else {
            f = (d.max.x - C.x) * u;
            i = (d.min.x - C.x) * u;
        }
        if (v >= 0) {
            j = (d.min.y - C.y) * v;
            k = (d.max.y - C.y) * v;
        } else {
            j = (d.max.y - C.y) * v;
            k = (d.min.y - C.y) * v;
        }
        if ((f > k) || (j > i))return Z1e.l3;
        if (j > f || f !== f) f = j;
        if (k < i || i !== i) i = k;
        if (B >= 0) {
            m = (d.min.z - C.z) * B;
            n = (d.max.z - C.z) * B;
        } else {
            m = (d.max.z - C.z) * B;
            n = (d.min.z - C.z) * B;
        }
        if ((f > n) || (m > i))return Z1e.l3;
        if (m > f || f !== f) f = m;
        if (n < i || i !== i) i = n;
        if (i < 0)return Z1e.l3;
        return this.at(f >= 0 ? f : i, e);
    }, intersectsBox: (function () {
        var e = new THREE.Vector3();
        return function (d) {
            return this.intersectBox(d, e) !== Z1e.l3;
        };
    })(), intersectTriangle: function () {
        var B = new THREE.Vector3(), C = new THREE.Vector3(), G = new THREE.Vector3(), L = new THREE.Vector3();
        return function (d, e, f, i, j) {
            C.subVectors(e, d);
            G.subVectors(f, d);
            L.crossVectors(C, G);
            var k = this.direction.dot(L), m;
            if (k > 0) {
                if (i)return Z1e.l3;
                m = 1;
            } else if (k < 0) {
                m = -1;
                k = -k;
            } else {
                return Z1e.l3;
            }
            B.subVectors(this.origin, d);
            var n = m * this.direction.dot(G.crossVectors(B, G));
            if (n < 0) {
                return Z1e.l3;
            }
            var u = m * this.direction.dot(C.cross(B));
            if (u < 0) {
                return Z1e.l3;
            }
            if (n + u > k) {
                return Z1e.l3;
            }
            var v = -m * B.dot(L);
            if (v < 0) {
                return Z1e.l3;
            }
            return this.at(v / k, j);
        };
    }(), applyMatrix4: function (d) {
        this.direction.add(this.origin).applyMatrix4(d);
        this.origin.applyMatrix4(d);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this;
    }, equals: function (d) {
        return d.origin.equals(this.origin) && d.direction.equals(this.direction);
    }
};
THREE.Sphere = function (d, e) {
    this.center = (d !== undefined) ? d : new THREE.Vector3();
    this.radius = (e !== undefined) ? e : 0;
};
THREE.Sphere.prototype = {
    constructor: THREE.Sphere, set: function (d, e) {
        this.center.copy(d);
        this.radius = e;
        return this;
    }, setFromPoints: function () {
        var m = new THREE.Box3();
        return function (d, e) {
            var f = this.center;
            if (e !== undefined) {
                f.copy(e);
            } else {
                m.setFromPoints(d).center(f);
            }
            var i = 0;
            for (var j = 0, k = d.length; j < k; j++) {
                i = Math.max(i, f.distanceToSquared(d[j]));
            }
            this.radius = Math.sqrt(i);
            return this;
        };
    }(), clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.center.copy(d.center);
        this.radius = d.radius;
        return this;
    }, empty: function () {
        return (this.radius <= 0);
    }, containsPoint: function (d) {
        return (d.distanceToSquared(this.center) <= (this.radius * this.radius));
    }, distanceToPoint: function (d) {
        return (d.distanceTo(this.center) - this.radius);
    }, intersectsSphere: function (d) {
        var e = this.radius + d.radius;
        return d.center.distanceToSquared(this.center) <= (e * e);
    }, intersectsBox: function (d) {
        return d.intersectsSphere(this);
    }, intersectsPlane: function (d) {
        return Math.abs(this.center.dot(d.normal) - d.constant) <= this.radius;
    }, clampPoint: function (d, e) {
        var f = this.center.distanceToSquared(d), i = e || new THREE.Vector3();
        i.copy(d);
        if (f > (this.radius * this.radius)) {
            i.sub(this.center).normalize();
            i.multiplyScalar(this.radius).add(this.center);
        }
        return i;
    }, getBoundingBox: function (d) {
        var e = d || new THREE.Box3();
        e.set(this.center, this.center);
        e.expandByScalar(this.radius);
        return e;
    }, applyMatrix4: function (d) {
        this.center.applyMatrix4(d);
        this.radius = this.radius * d.getMaxScaleOnAxis();
        return this;
    }, translate: function (d) {
        this.center.add(d);
        return this;
    }, equals: function (d) {
        return d.center.equals(this.center) && (d.radius === this.radius);
    }
};
THREE.Frustum = function (d, e, f, i, j, k) {
    this.planes = [(d !== undefined) ? d : new THREE.Plane(), (e !== undefined) ? e : new THREE.Plane(), (f !== undefined) ? f : new THREE.Plane(), (i !== undefined) ? i : new THREE.Plane(), (j !== undefined) ? j : new THREE.Plane(), (k !== undefined) ? k : new THREE.Plane()];
};
THREE.Frustum.prototype = {
    constructor: THREE.Frustum, set: function (d, e, f, i, j, k) {
        var m = this.planes;
        m[0].copy(d);
        m[1].copy(e);
        m[2].copy(f);
        m[3].copy(i);
        m[4].copy(j);
        m[5].copy(k);
        return this;
    }, clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        var e = this.planes;
        for (var f = 0; f < 6; f++) {
            e[f].copy(d.planes[f]);
        }
        return this;
    }, setFromMatrix: function (d) {
        var e = this.planes, f = d.elements, i = f[0], j = f[1], k = f[2], m = f[3], n = f[4], u = f[5], v = f[6],
            B = f[7], C = f[8], G = f[9], L = f[10], N = f[11], T = f[12], S = f[13], b0 = f[14], h0 = f[15];
        e[0].setComponents(m - i, B - n, N - C, h0 - T).normalize();
        e[1].setComponents(m + i, B + n, N + C, h0 + T).normalize();
        e[2].setComponents(m + j, B + u, N + G, h0 + S).normalize();
        e[3].setComponents(m - j, B - u, N - G, h0 - S).normalize();
        e[4].setComponents(m - k, B - v, N - L, h0 - b0).normalize();
        e[5].setComponents(m + k, B + v, N + L, h0 + b0).normalize();
        return this;
    }, intersectsObject: function () {
        var f = new THREE.Sphere();
        return function (d) {
            var e = d.geometry;
            if (e.boundingSphere === Z1e.l3) e.computeBoundingSphere();
            f.copy(e.boundingSphere);
            f.applyMatrix4(d.matrixWorld);
            return this.intersectsSphere(f);
        };
    }(), intersectsSphere: function (d) {
        var e = this.planes, f = d.center, i = -d.radius;
        for (var j = 0; j < 6; j++) {
            var k = e[j].distanceToPoint(f);
            if (k < i) {
                return Z1e.e4;
            }
        }
        return Z1e.n3;
    }, intersectsBox: function () {
        var m = new THREE.Vector3(), n = new THREE.Vector3();
        return function (d) {
            var e = this.planes;
            for (var f = 0; f < 6; f++) {
                var i = e[f];
                m.x = i.normal.x > 0 ? d.min.x : d.max.x;
                n.x = i.normal.x > 0 ? d.max.x : d.min.x;
                m.y = i.normal.y > 0 ? d.min.y : d.max.y;
                n.y = i.normal.y > 0 ? d.max.y : d.min.y;
                m.z = i.normal.z > 0 ? d.min.z : d.max.z;
                n.z = i.normal.z > 0 ? d.max.z : d.min.z;
                var j = i.distanceToPoint(m), k = i.distanceToPoint(n);
                if (j < 0 && k < 0) {
                    return Z1e.e4;
                }
            }
            return Z1e.n3;
        };
    }(), containsPoint: function (d) {
        var e = this.planes;
        for (var f = 0; f < 6; f++) {
            if (e[f].distanceToPoint(d) < 0) {
                return Z1e.e4;
            }
        }
        return Z1e.n3;
    }
};
THREE.Plane = function (d, e) {
    this.normal = (d !== undefined) ? d : new THREE.Vector3(1, 0, 0);
    this.constant = (e !== undefined) ? e : 0;
};
THREE.Plane.prototype = {
    constructor: THREE.Plane, set: function (d, e) {
        this.normal.copy(d);
        this.constant = e;
        return this;
    }, setComponents: function (d, e, f, i) {
        this.normal.set(d, e, f);
        this.constant = i;
        return this;
    }, setFromNormalAndCoplanarPoint: function (d, e) {
        this.normal.copy(d);
        this.constant = -e.dot(this.normal);
        return this;
    }, setFromCoplanarPoints: function () {
        var j = new THREE.Vector3(), k = new THREE.Vector3();
        return function (d, e, f) {
            var i = j.subVectors(f, e).cross(k.subVectors(d, e)).normalize();
            this.setFromNormalAndCoplanarPoint(i, d);
            return this;
        };
    }(), clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.normal.copy(d.normal);
        this.constant = d.constant;
        return this;
    }, normalize: function () {
        var d = Z1e.d4 / this.normal.length();
        this.normal.multiplyScalar(d);
        this.constant *= d;
        return this;
    }, negate: function () {
        this.constant *= -1;
        this.normal.negate();
        return this;
    }, distanceToPoint: function (d) {
        return this.normal.dot(d) + this.constant;
    }, distanceToSphere: function (d) {
        return this.distanceToPoint(d.center) - d.radius;
    }, projectPoint: function (d, e) {
        return this.orthoPoint(d, e).sub(d).negate();
    }, orthoPoint: function (d, e) {
        var f = this.distanceToPoint(d), i = e || new THREE.Vector3();
        return i.copy(this.normal).multiplyScalar(f);
    }, intersectLine: function () {
        var m = new THREE.Vector3();
        return function (d, e) {
            var f = e || new THREE.Vector3(), i = d.delta(m), j = this.normal.dot(i);
            if (j === 0) {
                if (this.distanceToPoint(d.start) === 0) {
                    return f.copy(d.start);
                }
                return undefined;
            }
            var k = -(d.start.dot(this.normal) + this.constant) / j;
            if (k < 0 || k > 1) {
                return undefined;
            }
            return f.copy(i).multiplyScalar(k).add(d.start);
        };
    }(), intersectsLine: function (d) {
        var e = this.distanceToPoint(d.start), f = this.distanceToPoint(d.end);
        return (e < 0 && f > 0) || (f < 0 && e > 0);
    }, intersectsBox: function (d) {
        return d.intersectsPlane(this);
    }, intersectsSphere: function (d) {
        return d.intersectsPlane(this);
    }, coplanarPoint: function (d) {
        var e = d || new THREE.Vector3();
        return e.copy(this.normal).multiplyScalar(-this.constant);
    }, applyMatrix4: function () {
        var k = new THREE.Vector3(), m = new THREE.Matrix3();
        return function (d, e) {
            var f = this.coplanarPoint(k).applyMatrix4(d), i = e || m.getNormalMatrix(d),
                j = this.normal.applyMatrix3(i).normalize();
            this.constant = -f.dot(j);
            return this;
        };
    }(), translate: function (d) {
        this.constant = this.constant - d.dot(this.normal);
        return this;
    }, equals: function (d) {
        return d.normal.equals(this.normal) && (d.constant === this.constant);
    }
};
THREE.Spherical = function (d, e, f) {
    this.radius = (d !== undefined) ? d : Z1e.d4;
    this.phi = (e !== undefined) ? e : 0;
    this.theta = (f !== undefined) ? f : 0;
    return this;
};
THREE.Spherical.prototype = {
    constructor: THREE.Spherical, set: function (d, e, f) {
        this.radius = d;
        this.phi = e;
        this.theta = f;
    }, clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.radius.copy(d.radius);
        this.phi.copy(d.phi);
        this.theta.copy(d.theta);
        return this;
    }, makeSafe: function () {
        var d = 0.000001;
        this.phi = Math.max(d, Math.min(Math.PI - d, this.phi));
    }, setFromVector3: function (d) {
        this.radius = d.length();
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2(d.x, d.z);
            this.phi = Math.acos(THREE.Math.clamp(d.y / this.radius, -1, 1));
        }
        return this;
    },
};
THREE.Math = {
    DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {
        var e = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''), f = new Array(36), i = 0, j;
        return function () {
            for (var d = 0; d < 36; d++) {
                if (d === 8 || d === 13 || d === 18 || d === 23) {
                    f[d] = '-';
                } else if (d === 14) {
                    f[d] = '4';
                } else {
                    if (i <= 0x02) i = 0x2000000 + (Math.random() * 0x1000000) | 0;
                    j = i & 0xf;
                    i = i >> 4;
                    f[d] = e[(d === 19) ? (j & 0x3) | 0x8 : j];
                }
            }
            return f.join('');
        };
    }(), clamp: function (d, e, f) {
        return Math.max(e, Math.min(f, d));
    }, euclideanModulo: function (d, e) {
        return ((d % e) + e) % e;
    }, mapLinear: function (d, e, f, i, j) {
        return i + (d - e) * (j - i) / (f - e);
    }, smoothstep: function (d, e, f) {
        if (d <= e)return 0;
        if (d >= f)return 1;
        d = (d - e) / (f - e);
        return d * d * (3 - 2 * d);
    }, smootherstep: function (d, e, f) {
        if (d <= e)return 0;
        if (d >= f)return 1;
        d = (d - e) / (f - e);
        return d * d * d * (d * (d * 6 - 15) + 10);
    }, random16: function () {
        console.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');
        return Math.random();
    }, randInt: function (d, e) {
        return d + Math.floor(Math.random() * (e - d + 1));
    }, randFloat: function (d, e) {
        return d + Math.random() * (e - d);
    }, randFloatSpread: function (d) {
        return d * (Z1e.k1 - Math.random());
    }, degToRad: function (d) {
        return d * THREE.Math.DEG2RAD;
    }, radToDeg: function (d) {
        return d * THREE.Math.RAD2DEG;
    }, isPowerOfTwo: function (d) {
        return (d & (d - 1)) === 0 && d !== 0;
    }, nearestPowerOfTwo: function (d) {
        return Math.pow(2, Math.round(Math.log(d) / Math.LN2));
    }, nextPowerOfTwo: function (d) {
        d--;
        d |= d >> 1;
        d |= d >> 2;
        d |= d >> 4;
        d |= d >> 8;
        d |= d >> 16;
        d++;
        return d;
    }
};
THREE.Spline = function (G) {
    this.points = G;
    var L = [], N = {x: 0, y: 0, z: 0}, T, S, b0, h0, f0, i0, s0, t0, o0;
    this.initFromArray = function (d) {
        this.points = [];
        for (var e = 0; e < d.length; e++) {
            this.points[e] = {x: d[e][0], y: d[e][1], z: d[e][2]};
        }
    };
    this.getPoint = function (d) {
        T = (this.points.length - 1) * d;
        S = Math.floor(T);
        b0 = T - S;
        L[0] = S === 0 ? S : S - 1;
        L[1] = S;
        L[2] = S > this.points.length - 2 ? this.points.length - 1 : S + 1;
        L[3] = S > this.points.length - 3 ? this.points.length - 1 : S + 2;
        i0 = this.points[L[0]];
        s0 = this.points[L[1]];
        t0 = this.points[L[2]];
        o0 = this.points[L[3]];
        h0 = b0 * b0;
        f0 = b0 * h0;
        N.x = w0(i0.x, s0.x, t0.x, o0.x, b0, h0, f0);
        N.y = w0(i0.y, s0.y, t0.y, o0.y, b0, h0, f0);
        N.z = w0(i0.z, s0.z, t0.z, o0.z, b0, h0, f0);
        return N;
    };
    this.getControlPointsArray = function () {
        var d, e, f = this.points.length, i = [];
        for (d = 0; d < f; d++) {
            e = this.points[d];
            i[d] = [e.x, e.y, e.z];
        }
        return i;
    };
    this.getLength = function (d) {
        var e, f, i, j, k = 0, m = 0, n = 0, u = new THREE.Vector3(), v = new THREE.Vector3(), B = [], C = 0;
        B[0] = 0;
        if (!d) d = Z1e.j4;
        i = this.points.length * d;
        u.copy(this.points[0]);
        for (e = 1; e < i; e++) {
            f = e / i;
            j = this.getPoint(f);
            v.copy(j);
            C += v.distanceTo(u);
            u.copy(j);
            k = (this.points.length - 1) * f;
            m = Math.floor(k);
            if (m !== n) {
                B[m] = C;
                n = m;
            }
        }
        B[B.length] = C;
        return {chunks: B, total: C};
    };
    this.reparametrizeByArcLength = function (d) {
        var e, f, i, j, k, m, n, u, v = [], B = new THREE.Vector3(), C = this.getLength();
        v.push(B.copy(this.points[0]).clone());
        for (e = 1; e < this.points.length; e++) {
            m = C.chunks[e] - C.chunks[e - 1];
            n = Math.ceil(d * m / C.total);
            j = (e - 1) / (this.points.length - 1);
            k = e / (this.points.length - 1);
            for (f = 1; f < n - 1; f++) {
                i = j + f * (1 / n) * (k - j);
                u = this.getPoint(i);
                v.push(B.copy(u).clone());
            }
            v.push(B.copy(this.points[e]).clone());
        }
        this.points = v;
    };
    function w0(d, e, f, i, j, k, m) {
        var n = (f - d) * Z1e.k1, u = (i - e) * Z1e.k1;
        return (2 * (e - f) + n + u) * m + (-3 * (e - f) - 2 * n - u) * k + n * j + e;
    }
};
THREE.Triangle = function (d, e, f) {
    this.a = (d !== undefined) ? d : new THREE.Vector3();
    this.b = (e !== undefined) ? e : new THREE.Vector3();
    this.c = (f !== undefined) ? f : new THREE.Vector3();
};
THREE.Triangle.normal = function () {
    var m = new THREE.Vector3();
    return function (d, e, f, i) {
        var j = i || new THREE.Vector3();
        j.subVectors(f, e);
        m.subVectors(d, e);
        j.cross(m);
        var k = j.lengthSq();
        if (k > 0) {
            return j.multiplyScalar(1 / Math.sqrt(k));
        }
        return j.set(0, 0, 0);
    };
}();
THREE.Triangle.barycoordFromPoint = function () {
    var T = new THREE.Vector3(), S = new THREE.Vector3(), b0 = new THREE.Vector3();
    return function (d, e, f, i, j) {
        T.subVectors(i, e);
        S.subVectors(f, e);
        b0.subVectors(d, e);
        var k = T.dot(T), m = T.dot(S), n = T.dot(b0), u = S.dot(S), v = S.dot(b0), B = (k * u - m * m),
            C = j || new THREE.Vector3();
        if (B === 0) {
            return C.set(-2, -1, -1);
        }
        var G = 1 / B, L = (u * n - m * v) * G, N = (k * v - m * n) * G;
        return C.set(1 - L - N, N, L);
    };
}();
THREE.Triangle.containsPoint = function () {
    var k = new THREE.Vector3();
    return function (d, e, f, i) {
        var j = THREE.Triangle.barycoordFromPoint(d, e, f, i, k);
        return (j.x >= 0) && (j.y >= 0) && ((j.x + j.y) <= 1);
    };
}();
THREE.Triangle.prototype = {
    constructor: THREE.Triangle, set: function (d, e, f) {
        this.a.copy(d);
        this.b.copy(e);
        this.c.copy(f);
        return this;
    }, setFromPointsAndIndices: function (d, e, f, i) {
        this.a.copy(d[e]);
        this.b.copy(d[f]);
        this.c.copy(d[i]);
        return this;
    }, clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.a.copy(d.a);
        this.b.copy(d.b);
        this.c.copy(d.c);
        return this;
    }, area: function () {
        var d = new THREE.Vector3(), e = new THREE.Vector3();
        return function () {
            d.subVectors(this.c, this.b);
            e.subVectors(this.a, this.b);
            return d.cross(e).length() * Z1e.k1;
        };
    }(), midpoint: function (d) {
        var e = d || new THREE.Vector3();
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }, normal: function (d) {
        return THREE.Triangle.normal(this.a, this.b, this.c, d);
    }, plane: function (d) {
        var e = d || new THREE.Plane();
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }, barycoordFromPoint: function (d, e) {
        return THREE.Triangle.barycoordFromPoint(d, this.a, this.b, this.c, e);
    }, containsPoint: function (d) {
        return THREE.Triangle.containsPoint(d, this.a, this.b, this.c);
    }, closestPointToPoint: function () {
        var m, n, u, v;
        return function B(d, e) {
            if (m === undefined) {
                m = new THREE.Plane();
                n = [new THREE.Line3(), new THREE.Line3(), new THREE.Line3()];
                u = new THREE.Vector3();
                v = new THREE.Vector3();
            }
            var f = e || new THREE.Vector3(), i = Infinity;
            m.setFromCoplanarPoints(this.a, this.b, this.c);
            m.projectPoint(d, u);
            if (this.containsPoint(u) === Z1e.n3) {
                f.copy(u);
            } else {
                n[0].set(this.a, this.b);
                n[1].set(this.b, this.c);
                n[2].set(this.c, this.a);
                for (var j = 0; j < n.length; j++) {
                    n[j].closestPointToPoint(u, Z1e.n3, v);
                    var k = u.distanceToSquared(v);
                    if (k < i) {
                        i = k;
                        f.copy(v);
                    }
                }
            }
            return f;
        };
    }(), equals: function (d) {
        return d.a.equals(this.a) && d.b.equals(this.b) && d.c.equals(this.c);
    }
};
THREE.Interpolant = function (d, e, f, i) {
    this.parameterPositions = d;
    this._cachedIndex = 0;
    this.resultBuffer = i !== undefined ? i : new e.constructor(f);
    this.sampleValues = e;
    this.valueSize = f;
};
THREE.Interpolant.prototype = {
    constructor: THREE.Interpolant, evaluate: function (d) {
        var e = this.parameterPositions, f = this._cachedIndex, i = e[f], j = e[f - 1];
        validate_interval:{
            seek:{
                var k;
                linear_scan:{
                    forward_scan:if (!(d < i)) {
                        for (var m = f + 2; ;) {
                            if (i === undefined) {
                                if (d < j)break forward_scan;
                                f = e.length;
                                this._cachedIndex = f;
                                return this.afterEnd_(f - 1, d, j);
                            }
                            if (f === m)break;
                            j = i;
                            i = e[++f];
                            if (d < i) {
                                break seek;
                            }
                        }
                        k = e.length;
                        break linear_scan;
                    }
                    if (!(d >= j)) {
                        var n = e[1];
                        if (d < n) {
                            f = 2;
                            j = n;
                        }
                        for (var m = f - 2; ;) {
                            if (j === undefined) {
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, d, i);
                            }
                            if (f === m)break;
                            i = j;
                            j = e[--f - 1];
                            if (d >= j) {
                                break seek;
                            }
                        }
                        k = f;
                        f = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                }
                while (f < k) {
                    var u = (f + k) >>> 1;
                    if (d < e[u]) {
                        k = u;
                    } else {
                        f = u + 1;
                    }
                }
                i = e[f];
                j = e[f - 1];
                if (j === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, d, i);
                }
                if (i === undefined) {
                    f = e.length;
                    this._cachedIndex = f;
                    return this.afterEnd_(f - 1, j, d);
                }
            }
            this._cachedIndex = f;
            this.intervalChanged_(f, j, i);
        }
        return this.interpolate_(f, j, d, i);
    }, settings: Z1e.l3, DefaultSettings_: {}, getSettings_: function () {
        return this.settings || this.DefaultSettings_;
    }, copySampleValue_: function (d) {
        var e = this.resultBuffer, f = this.sampleValues, i = this.valueSize, j = d * i;
        for (var k = 0; k !== i; ++k) {
            e[k] = f[j + k];
        }
        return e;
    }, interpolate_: function (d, e, f, i) {
        throw  new Error("call to abstract method");
    }, intervalChanged_: function (d, e, f) {
    }
};
Object.assign(THREE.Interpolant.prototype, {
    beforeStart_: THREE.Interpolant.prototype.copySampleValue_,
    afterEnd_: THREE.Interpolant.prototype.copySampleValue_
});
THREE.CubicInterpolant = function (d, e, f, i) {
    THREE.Interpolant.call(this, d, e, f, i);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
};
THREE.CubicInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.CubicInterpolant,
    DefaultSettings_: {endingStart: THREE.ZeroCurvatureEnding, endingEnd: THREE.ZeroCurvatureEnding},
    intervalChanged_: function (d, e, f) {
        var i = this.parameterPositions, j = d - 2, k = d + 1, m = i[j], n = i[k];
        if (m === undefined) {
            switch (this.getSettings_().endingStart) {
                case THREE.ZeroSlopeEnding:
                    j = d;
                    m = 2 * e - f;
                    break;
                case THREE.WrapAroundEnding:
                    j = i.length - 2;
                    m = e + i[j] - i[j + 1];
                    break;
                default:
                    j = d;
                    m = f;
            }
        }
        if (n === undefined) {
            switch (this.getSettings_().endingEnd) {
                case THREE.ZeroSlopeEnding:
                    k = d;
                    n = 2 * f - e;
                    break;
                case THREE.WrapAroundEnding:
                    k = 1;
                    n = f + i[1] - i[0];
                    break;
                default:
                    k = d - 1;
                    n = e;
            }
        }
        var u = (f - e) * Z1e.k1, v = this.valueSize;
        this._weightPrev = u / (e - m);
        this._weightNext = u / (n - f);
        this._offsetPrev = j * v;
        this._offsetNext = k * v;
    },
    interpolate_: function (d, e, f, i) {
        var j = this.resultBuffer, k = this.sampleValues, m = this.valueSize, n = d * m, u = n - m,
            v = this._offsetPrev, B = this._offsetNext, C = this._weightPrev, G = this._weightNext,
            L = (f - e) / (i - e), N = L * L, T = N * L, S = -C * T + 2 * C * N - C * L,
            b0 = (1 + C) * T + (-1.5 - 2 * C) * N + (-Z1e.k1 + C) * L + 1,
            h0 = (-1 - G) * T + (1.5 + G) * N + Z1e.k1 * L, f0 = G * T - G * N;
        for (var i0 = 0; i0 !== m; ++i0) {
            j[i0] = S * k[v + i0] + b0 * k[u + i0] + h0 * k[n + i0] + f0 * k[B + i0];
        }
        return j;
    }
});
THREE.DiscreteInterpolant = function (d, e, f, i) {
    THREE.Interpolant.call(this, d, e, f, i);
};
THREE.DiscreteInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.DiscreteInterpolant,
    interpolate_: function (d, e, f, i) {
        return this.copySampleValue_(d - 1);
    }
});
THREE.LinearInterpolant = function (d, e, f, i) {
    THREE.Interpolant.call(this, d, e, f, i);
};
THREE.LinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.LinearInterpolant,
    interpolate_: function (d, e, f, i) {
        var j = this.resultBuffer, k = this.sampleValues, m = this.valueSize, n = d * m, u = n - m,
            v = (f - e) / (i - e), B = 1 - v;
        for (var C = 0; C !== m; ++C) {
            j[C] = k[u + C] * B + k[n + C] * v;
        }
        return j;
    }
});
THREE.QuaternionLinearInterpolant = function (d, e, f, i) {
    THREE.Interpolant.call(this, d, e, f, i);
};
THREE.QuaternionLinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.QuaternionLinearInterpolant,
    interpolate_: function (d, e, f, i) {
        var j = this.resultBuffer, k = this.sampleValues, m = this.valueSize, n = d * m, u = (f - e) / (i - e);
        for (var v = n + m; n !== v; n += 4) {
            THREE.Quaternion.slerpFlat(j, 0, k, n - m, k, n, u);
        }
        return j;
    }
});
THREE.Clock = function (d) {
    this.autoStart = (d !== undefined) ? d : Z1e.n3;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = Z1e.e4;
};
THREE.Clock.prototype = {
    constructor: THREE.Clock, start: function () {
        this.startTime = (performance || Date).now();
        this.oldTime = this.startTime;
        this.running = Z1e.n3;
    }, stop: function () {
        this.getElapsedTime();
        this.running = Z1e.e4;
    }, getElapsedTime: function () {
        this.getDelta();
        return this.elapsedTime;
    }, getDelta: function () {
        var d = 0;
        if (this.autoStart && !this.running) {
            this.start();
        }
        if (this.running) {
            var e = (performance || Date).now();
            d = (e - this.oldTime) / 1000;
            this.oldTime = e;
            this.elapsedTime += d;
        }
        return d;
    }
};
THREE.EventDispatcher = function () {
};
THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher, apply: function (d) {
        d.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        d.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        d.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        d.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
    }, addEventListener: function (d, e) {
        if (this._listeners === undefined) this._listeners = {};
        var f = this._listeners;
        if (f[d] === undefined) {
            f[d] = [];
        }
        if (f[d].indexOf(e) === -1) {
            f[d].push(e);
        }
    }, hasEventListener: function (d, e) {
        if (this._listeners === undefined)return Z1e.e4;
        var f = this._listeners;
        if (f[d] !== undefined && f[d].indexOf(e) !== -1) {
            return Z1e.n3;
        }
        return Z1e.e4;
    }, removeEventListener: function (d, e) {
        if (this._listeners === undefined)return;
        var f = this._listeners, i = f[d];
        if (i !== undefined) {
            var j = i.indexOf(e);
            if (j !== -1) {
                i.splice(j, 1);
            }
        }
    }, dispatchEvent: function (d) {
        if (this._listeners === undefined)return;
        var e = this._listeners, f = e[d.type];
        if (f !== undefined) {
            d.target = this;
            var i = [], j = f.length;
            for (var k = 0; k < j; k++) {
                i[k] = f[k];
            }
            for (var k = 0; k < j; k++) {
                i[k].call(this, d);
            }
        }
    }
};
THREE.Layers = function () {
    this.mask = 1;
};
THREE.Layers.prototype = {
    constructor: THREE.Layers, set: function (d) {
        this.mask = 1 << d;
    }, enable: function (d) {
        this.mask |= 1 << d;
    }, toggle: function (d) {
        this.mask ^= 1 << d;
    }, disable: function (d) {
        this.mask &= ~(1 << d);
    }, test: function (d) {
        return (this.mask & d.mask) !== 0;
    }
};
(function (n) {
    n.Raycaster = function (d, e, f, i) {
        this.ray = new n.Ray(d, e);
        this.near = f || 0;
        this.far = i || Infinity;
        this.params = {Mesh: {}, Line: {}, LOD: {}, Points: {threshold: 1}, Sprite: {}};
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function () {
                    console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                    return this.Points;
                }
            }
        });
    };
    function u(d, e) {
        return d.distance - e.distance;
    }
    function v(d, e, f, i) {
        if (d.visible === Z1e.e4)return;
        d.raycast(e, f);
        if (i === Z1e.n3) {
            var j = d.children;
            for (var k = 0, m = j.length; k < m; k++) {
                v(j[k], e, f, Z1e.n3);
            }
        }
    }
    n.Raycaster.prototype = {
        constructor: n.Raycaster, linePrecision: 1, set: function (d, e) {
            this.ray.set(d, e);
        }, setFromCamera: function (d, e) {
            if (e instanceof n.PerspectiveCamera) {
                this.ray.origin.setFromMatrixPosition(e.matrixWorld);
                this.ray.direction.set(d.x, d.y, Z1e.k1).unproject(e).sub(this.ray.origin).normalize();
            } else if (e instanceof n.OrthographicCamera) {
                this.ray.origin.set(d.x, d.y, -1).unproject(e);
                this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld);
            } else {
                console.error('THREE.Raycaster: Unsupported camera type.');
            }
        }, intersectObject: function (d, e) {
            var f = [];
            v(d, this, f, e);
            f.sort(u);
            return f;
        }, intersectObjects: function (d, e) {
            var f = [];
            if (Array.isArray(d) === Z1e.e4) {
                console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                return f;
            }
            for (var i = 0, j = d.length; i < j; i++) {
                v(d[i], this, f, e);
            }
            f.sort(u);
            return f;
        }
    };
}(THREE));
THREE.Object3D = function () {
    Object.defineProperty(this, Z1e.S0, {value: THREE.Object3DIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = Z1e.l3;
    this.children = [];
    this.up = THREE.Object3D.DefaultUp.clone();
    var d = new THREE.Vector3(), e = new THREE.Euler(), f = new THREE.Quaternion(), i = new THREE.Vector3(1, 1, 1);
    function j() {
        f.setFromEuler(e, Z1e.e4);
    }
    function k() {
        e.setFromQuaternion(f, undefined, Z1e.e4);
    }
    e.onChange(j);
    f.onChange(k);
    Object.defineProperties(this, {
        position: {enumerable: Z1e.n3, value: d},
        rotation: {enumerable: Z1e.n3, value: e},
        quaternion: {enumerable: Z1e.n3, value: f},
        scale: {enumerable: Z1e.n3, value: i},
        modelViewMatrix: {value: new THREE.Matrix4()},
        normalMatrix: {value: new THREE.Matrix3()}
    });
    this.rotationAutoUpdate = Z1e.n3;
    this.matrix = new THREE.Matrix4();
    this.matrixWorld = new THREE.Matrix4();
    this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = Z1e.e4;
    this.layers = new THREE.Layers();
    this.visible = Z1e.n3;
    this.castShadow = Z1e.e4;
    this.receiveShadow = Z1e.e4;
    this.frustumCulled = Z1e.n3;
    this.renderOrder = 0;
    this.userData = {};
};
THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
THREE.Object3D.DefaultMatrixAutoUpdate = Z1e.n3;
THREE.Object3D.prototype = {
    constructor: THREE.Object3D, applyMatrix: function (d) {
        this.matrix.multiplyMatrices(d, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }, setMatrix: function (d) {
        this.matrix.copy(d);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }, setRotationFromAxisAngle: function (d, e) {
        this.quaternion.setFromAxisAngle(d, e);
    }, setRotationFromEuler: function (d) {
        this.quaternion.setFromEuler(d, Z1e.n3);
    }, setRotationFromMatrix: function (d) {
        this.quaternion.setFromRotationMatrix(d);
    }, setRotationFromQuaternion: function (d) {
        this.quaternion.copy(d);
    }, rotateOnAxis: function () {
        var f = new THREE.Quaternion();
        return function (d, e) {
            f.setFromAxisAngle(d, e);
            this.quaternion.multiply(f);
            return this;
        };
    }(), rotateX: function () {
        var e = new THREE.Vector3(1, 0, 0);
        return function (d) {
            return this.rotateOnAxis(e, d);
        };
    }(), rotateY: function () {
        var e = new THREE.Vector3(0, 1, 0);
        return function (d) {
            return this.rotateOnAxis(e, d);
        };
    }(), rotateZ: function () {
        var e = new THREE.Vector3(0, 0, 1);
        return function (d) {
            return this.rotateOnAxis(e, d);
        };
    }(), translateOnAxis: function () {
        var f = new THREE.Vector3();
        return function (d, e) {
            f.copy(d).applyQuaternion(this.quaternion);
            this.position.add(f.multiplyScalar(e));
            return this;
        };
    }(), translateX: function () {
        var e = new THREE.Vector3(1, 0, 0);
        return function (d) {
            return this.translateOnAxis(e, d);
        };
    }(), translateY: function () {
        var e = new THREE.Vector3(0, 1, 0);
        return function (d) {
            return this.translateOnAxis(e, d);
        };
    }(), translateZ: function () {
        var e = new THREE.Vector3(0, 0, 1);
        return function (d) {
            return this.translateOnAxis(e, d);
        };
    }(), localToWorld: function (d) {
        return d.applyMatrix4(this.matrixWorld);
    }, worldToLocal: function () {
        var e = new THREE.Matrix4();
        return function (d) {
            return d.applyMatrix4(e.getInverse(this.matrixWorld));
        };
    }(), lookAt: function () {
        var e = new THREE.Matrix4();
        return function (d) {
            e.lookAt(d, this.position, this.up);
            this.quaternion.setFromRotationMatrix(e);
        };
    }(), add: function (d) {
        if (arguments.length > 1) {
            for (var e = 0; e < arguments.length; e++) {
                this.add(arguments[e]);
            }
            return this;
        }
        if (d === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", d);
            return this;
        }
        if (d instanceof THREE.Object3D) {
            if (d.parent !== Z1e.l3) {
                d.parent.remove(d);
            }
            d.parent = this;
            d.dispatchEvent({type: 'added'});
            this.children.push(d);
        } else {
            console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", d);
        }
        return this;
    }, remove: function (d) {
        if (arguments.length > 1) {
            for (var e = 0; e < arguments.length; e++) {
                this.remove(arguments[e]);
            }
        }
        var f = this.children.indexOf(d);
        if (f !== -1) {
            d.parent = Z1e.l3;
            d.dispatchEvent({type: 'removed'});
            this.children.splice(f, 1);
        }
    }, getObjectById: function (d) {
        return this.getObjectByProperty(Z1e.S0, d);
    }, getObjectByName: function (d) {
        return this.getObjectByProperty('name', d);
    }, getObjectByProperty: function (d, e) {
        if (this[d] === e)return this;
        for (var f = 0, i = this.children.length; f < i; f++) {
            var j = this.children[f], k = j.getObjectByProperty(d, e);
            if (k !== undefined) {
                return k;
            }
        }
        return undefined;
    }, getWorldPosition: function (d) {
        var e = d || new THREE.Vector3();
        this.updateMatrixWorld(Z1e.n3);
        return e.setFromMatrixPosition(this.matrixWorld);
    }, getWorldQuaternion: function () {
        var f = new THREE.Vector3(), i = new THREE.Vector3();
        return function (d) {
            var e = d || new THREE.Quaternion();
            this.updateMatrixWorld(Z1e.n3);
            this.matrixWorld.decompose(f, e, i);
            return e;
        };
    }(), getWorldRotation: function () {
        var f = new THREE.Quaternion();
        return function (d) {
            var e = d || new THREE.Euler();
            this.getWorldQuaternion(f);
            return e.setFromQuaternion(f, this.rotation.order, Z1e.e4);
        };
    }(), getWorldScale: function () {
        var f = new THREE.Vector3(), i = new THREE.Quaternion();
        return function (d) {
            var e = d || new THREE.Vector3();
            this.updateMatrixWorld(Z1e.n3);
            this.matrixWorld.decompose(f, i, e);
            return e;
        };
    }(), getWorldDirection: function () {
        var f = new THREE.Quaternion();
        return function (d) {
            var e = d || new THREE.Vector3();
            this.getWorldQuaternion(f);
            return e.set(0, 0, 1).applyQuaternion(f);
        };
    }(), raycast: function () {
    }, traverse: function (d) {
        d(this);
        var e = this.children;
        for (var f = 0, i = e.length; f < i; f++) {
            e[f].traverse(d);
        }
    }, traverseVisible: function (d) {
        if (this.visible === Z1e.e4)return;
        d(this);
        var e = this.children;
        for (var f = 0, i = e.length; f < i; f++) {
            e[f].traverseVisible(d);
        }
    }, traverseAncestors: function (d) {
        var e = this.parent;
        if (e !== Z1e.l3) {
            d(e);
            e.traverseAncestors(d);
        }
    }, updateMatrix: function () {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = Z1e.n3;
    }, updateMatrixWorld: function (d) {
        if (this.matrixAutoUpdate === Z1e.n3) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === Z1e.n3 || d === Z1e.n3) {
            if (this.parent === Z1e.l3) {
                this.matrixWorld.copy(this.matrix);
            } else {
                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = Z1e.e4;
            d = Z1e.n3;
        }
        for (var e = 0, f = this.children.length; e < f; e++) {
            this.children[e].updateMatrixWorld(d);
        }
    }, toJSON: function (j) {
        var k = (j === undefined || j === ''), m = {};
        if (k) {
            j = {geometries: {}, materials: {}, textures: {}, images: {}};
            m.metadata = {version: 4.4, type: 'Object', generator: 'Object3D.toJSON'};
        }
        var n = {};
        n.uuid = this.uuid;
        n.type = this.type;
        if (this.name !== '') n.name = this.name;
        if (JSON.stringify(this.userData) !== '{}') n.userData = this.userData;
        if (this.castShadow === Z1e.n3) n.castShadow = Z1e.n3;
        if (this.receiveShadow === Z1e.n3) n.receiveShadow = Z1e.n3;
        if (this.visible === Z1e.e4) n.visible = Z1e.e4;
        n.matrix = this.matrix.toArray();
        if (this.geometry !== undefined) {
            if (j.geometries[this.geometry.uuid] === undefined) {
                j.geometries[this.geometry.uuid] = this.geometry.toJSON(j);
            }
            n.geometry = this.geometry.uuid;
        }
        if (this.material !== undefined) {
            if (j.materials[this.material.uuid] === undefined) {
                j.materials[this.material.uuid] = this.material.toJSON(j);
            }
            n.material = this.material.uuid;
        }
        if (this.children.length > 0) {
            n.children = [];
            for (var u = 0; u < this.children.length; u++) {
                n.children.push(this.children[u].toJSON(j).object);
            }
        }
        if (k) {
            var v = L(j.geometries), B = L(j.materials), C = L(j.textures), G = L(j.images);
            if (v.length > 0) m.geometries = v;
            if (B.length > 0) m.materials = B;
            if (C.length > 0) m.textures = C;
            if (G.length > 0) m.images = G;
        }
        m.object = n;
        return m;
        function L(d) {
            var e = [];
            for (var f in d) {
                var i = d[f];
                delete  i.metadata;
                e.push(i);
            }
            return e;
        }
    }, clone: function (d) {
        return new this.constructor().copy(this, d);
    }, copy: function (d, e) {
        if (e === undefined) e = Z1e.n3;
        this.name = d.name;
        this.up.copy(d.up);
        this.position.copy(d.position);
        this.quaternion.copy(d.quaternion);
        this.scale.copy(d.scale);
        this.rotationAutoUpdate = d.rotationAutoUpdate;
        this.matrix.copy(d.matrix);
        this.matrixWorld.copy(d.matrixWorld);
        this.matrixAutoUpdate = d.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = d.matrixWorldNeedsUpdate;
        this.visible = d.visible;
        this.castShadow = d.castShadow;
        this.receiveShadow = d.receiveShadow;
        this.frustumCulled = d.frustumCulled;
        this.renderOrder = d.renderOrder;
        this.userData = JSON.parse(JSON.stringify(d.userData));
        if (e === Z1e.n3) {
            for (var f = 0; f < d.children.length; f++) {
                var i = d.children[f];
                this.add(i.clone());
            }
        }
        return this;
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Face3 = function (d, e, f, i, j, k) {
    this.a = d;
    this.b = e;
    this.c = f;
    this.normal = i instanceof THREE.Vector3 ? i : new THREE.Vector3();
    this.vertexNormals = Array.isArray(i) ? i : [];
    this.color = j instanceof THREE.Color ? j : new THREE.Color();
    this.vertexColors = Array.isArray(j) ? j : [];
    this.materialIndex = k !== undefined ? k : 0;
};
THREE.Face3.prototype = {
    constructor: THREE.Face3, clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.a = d.a;
        this.b = d.b;
        this.c = d.c;
        this.normal.copy(d.normal);
        this.color.copy(d.color);
        this.materialIndex = d.materialIndex;
        for (var e = 0, f = d.vertexNormals.length; e < f; e++) {
            this.vertexNormals[e] = d.vertexNormals[e].clone();
        }
        for (var e = 0, f = d.vertexColors.length; e < f; e++) {
            this.vertexColors[e] = d.vertexColors[e].clone();
        }
        return this;
    }
};
THREE.BufferAttribute = function (d, e, f) {
    this.uuid = THREE.Math.generateUUID();
    this.array = d;
    this.itemSize = e;
    this.dynamic = Z1e.e4;
    this.updateRange = {offset: 0, count: -1};
    this.version = 0;
    this.normalized = f === Z1e.n3;
};
THREE.BufferAttribute.prototype = {
    constructor: THREE.BufferAttribute, get count() {
        return this.array.length / this.itemSize;
    }, set needsUpdate(value) {
        if (value === Z1e.n3) this.version++;
    }, setDynamic: function (d) {
        this.dynamic = d;
        return this;
    }, copy: function (d) {
        this.array = new d.array.constructor(d.array);
        this.itemSize = d.itemSize;
        this.dynamic = d.dynamic;
        return this;
    }, copyAt: function (d, e, f) {
        d *= this.itemSize;
        f *= e.itemSize;
        for (var i = 0, j = this.itemSize; i < j; i++) {
            this.array[d + i] = e.array[f + i];
        }
        return this;
    }, copyArray: function (d) {
        this.array.set(d);
        return this;
    }, copyColorsArray: function (d) {
        var e = this.array, f = 0;
        for (var i = 0, j = d.length; i < j; i++) {
            var k = d[i];
            if (k === undefined) {
                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                k = new THREE.Color();
            }
            e[f++] = k.r;
            e[f++] = k.g;
            e[f++] = k.b;
        }
        return this;
    }, copyIndicesArray: function (d) {
        var e = this.array, f = 0;
        for (var i = 0, j = d.length; i < j; i++) {
            var k = d[i];
            e[f++] = k.a;
            e[f++] = k.b;
            e[f++] = k.c;
        }
        return this;
    }, copyVector2sArray: function (d) {
        var e = this.array, f = 0;
        for (var i = 0, j = d.length; i < j; i++) {
            var k = d[i];
            if (k === undefined) {
                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                k = new THREE.Vector2();
            }
            e[f++] = k.x;
            e[f++] = k.y;
        }
        return this;
    }, copyVector3sArray: function (d) {
        var e = this.array, f = 0;
        for (var i = 0, j = d.length; i < j; i++) {
            var k = d[i];
            if (k === undefined) {
                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                k = new THREE.Vector3();
            }
            e[f++] = k.x;
            e[f++] = k.y;
            e[f++] = k.z;
        }
        return this;
    }, copyVector4sArray: function (d) {
        var e = this.array, f = 0;
        for (var i = 0, j = d.length; i < j; i++) {
            var k = d[i];
            if (k === undefined) {
                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                k = new THREE.Vector4();
            }
            e[f++] = k.x;
            e[f++] = k.y;
            e[f++] = k.z;
            e[f++] = k.w;
        }
        return this;
    }, set: function (d, e) {
        if (e === undefined) e = 0;
        this.array.set(d, e);
        return this;
    }, getX: function (d) {
        return this.array[d * this.itemSize];
    }, setX: function (d, e) {
        this.array[d * this.itemSize] = e;
        return this;
    }, getY: function (d) {
        return this.array[d * this.itemSize + 1];
    }, setY: function (d, e) {
        this.array[d * this.itemSize + 1] = e;
        return this;
    }, getZ: function (d) {
        return this.array[d * this.itemSize + 2];
    }, setZ: function (d, e) {
        this.array[d * this.itemSize + 2] = e;
        return this;
    }, getW: function (d) {
        return this.array[d * this.itemSize + 3];
    }, setW: function (d, e) {
        this.array[d * this.itemSize + 3] = e;
        return this;
    }, setXY: function (d, e, f) {
        d *= this.itemSize;
        this.array[d + 0] = e;
        this.array[d + 1] = f;
        return this;
    }, setXYZ: function (d, e, f, i) {
        d *= this.itemSize;
        this.array[d + 0] = e;
        this.array[d + 1] = f;
        this.array[d + 2] = i;
        return this;
    }, setXYZW: function (d, e, f, i, j) {
        d *= this.itemSize;
        this.array[d + 0] = e;
        this.array[d + 1] = f;
        this.array[d + 2] = i;
        this.array[d + 3] = j;
        return this;
    }, clone: function () {
        return new this.constructor().copy(this);
    }
};
THREE.Int8Attribute = function (d, e) {
    return new THREE.BufferAttribute(new Int8Array(d), e);
};
THREE.Uint8Attribute = function (d, e) {
    return new THREE.BufferAttribute(new Uint8Array(d), e);
};
THREE.Uint8ClampedAttribute = function (d, e) {
    return new THREE.BufferAttribute(new Uint8ClampedArray(d), e);
};
THREE.Int16Attribute = function (d, e) {
    return new THREE.BufferAttribute(new Int16Array(d), e);
};
THREE.Uint16Attribute = function (d, e) {
    return new THREE.BufferAttribute(new Uint16Array(d), e);
};
THREE.Int32Attribute = function (d, e) {
    return new THREE.BufferAttribute(new Int32Array(d), e);
};
THREE.Uint32Attribute = function (d, e) {
    return new THREE.BufferAttribute(new Uint32Array(d), e);
};
THREE.Float32Attribute = function (d, e) {
    return new THREE.BufferAttribute(new Float32Array(d), e);
};
THREE.Float64Attribute = function (d, e) {
    return new THREE.BufferAttribute(new Float64Array(d), e);
};
THREE.DynamicBufferAttribute = function (d, e) {
    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
    return new THREE.BufferAttribute(d, e).setDynamic(Z1e.n3);
};
THREE.InstancedBufferAttribute = function (d, e, f) {
    THREE.BufferAttribute.call(this, d, e);
    this.meshPerAttribute = f || 1;
};
THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
THREE.InstancedBufferAttribute.prototype.copy = function (d) {
    THREE.BufferAttribute.prototype.copy.call(this, d);
    this.meshPerAttribute = d.meshPerAttribute;
    return this;
};
THREE.InterleavedBuffer = function (d, e) {
    this.uuid = THREE.Math.generateUUID();
    this.array = d;
    this.stride = e;
    this.dynamic = Z1e.e4;
    this.updateRange = {offset: 0, count: -1};
    this.version = 0;
};
THREE.InterleavedBuffer.prototype = {
    constructor: THREE.InterleavedBuffer, get length() {
        return this.array.length;
    }, get count() {
        return this.array.length / this.stride;
    }, set needsUpdate(value) {
        if (value === Z1e.n3) this.version++;
    }, setDynamic: function (d) {
        this.dynamic = d;
        return this;
    }, copy: function (d) {
        this.array = new d.array.constructor(d.array);
        this.stride = d.stride;
        this.dynamic = d.dynamic;
        return this;
    }, copyAt: function (d, e, f) {
        d *= this.stride;
        f *= e.stride;
        for (var i = 0, j = this.stride; i < j; i++) {
            this.array[d + i] = e.array[f + i];
        }
        return this;
    }, set: function (d, e) {
        if (e === undefined) e = 0;
        this.array.set(d, e);
        return this;
    }, clone: function () {
        return new this.constructor().copy(this);
    }
};
THREE.InstancedInterleavedBuffer = function (d, e, f) {
    THREE.InterleavedBuffer.call(this, d, e);
    this.meshPerAttribute = f || 1;
};
THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype);
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
THREE.InstancedInterleavedBuffer.prototype.copy = function (d) {
    THREE.InterleavedBuffer.prototype.copy.call(this, d);
    this.meshPerAttribute = d.meshPerAttribute;
    return this;
};
THREE.InterleavedBufferAttribute = function (d, e, f) {
    this.uuid = THREE.Math.generateUUID();
    this.data = d;
    this.itemSize = e;
    this.offset = f;
};
THREE.InterleavedBufferAttribute.prototype = {
    constructor: THREE.InterleavedBufferAttribute, get length() {
        console.warn(Z1e.c4);
        return this.array.length;
    }, get count() {
        return this.data.count;
    }, setX: function (d, e) {
        this.data.array[d * this.data.stride + this.offset] = e;
        return this;
    }, setY: function (d, e) {
        this.data.array[d * this.data.stride + this.offset + 1] = e;
        return this;
    }, setZ: function (d, e) {
        this.data.array[d * this.data.stride + this.offset + 2] = e;
        return this;
    }, setW: function (d, e) {
        this.data.array[d * this.data.stride + this.offset + 3] = e;
        return this;
    }, getX: function (d) {
        return this.data.array[d * this.data.stride + this.offset];
    }, getY: function (d) {
        return this.data.array[d * this.data.stride + this.offset + 1];
    }, getZ: function (d) {
        return this.data.array[d * this.data.stride + this.offset + 2];
    }, getW: function (d) {
        return this.data.array[d * this.data.stride + this.offset + 3];
    }, setXY: function (d, e, f) {
        d = d * this.data.stride + this.offset;
        this.data.array[d + 0] = e;
        this.data.array[d + 1] = f;
        return this;
    }, setXYZ: function (d, e, f, i) {
        d = d * this.data.stride + this.offset;
        this.data.array[d + 0] = e;
        this.data.array[d + 1] = f;
        this.data.array[d + 2] = i;
        return this;
    }, setXYZW: function (d, e, f, i, j) {
        d = d * this.data.stride + this.offset;
        this.data.array[d + 0] = e;
        this.data.array[d + 1] = f;
        this.data.array[d + 2] = i;
        this.data.array[d + 3] = j;
        return this;
    }
};
THREE.Geometry = function () {
    Object.defineProperty(this, Z1e.S0, {value: THREE.GeometryIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = Z1e.C0;
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = Z1e.l3;
    this.boundingSphere = Z1e.l3;
    this.verticesNeedUpdate = Z1e.e4;
    this.elementsNeedUpdate = Z1e.e4;
    this.uvsNeedUpdate = Z1e.e4;
    this.normalsNeedUpdate = Z1e.e4;
    this.colorsNeedUpdate = Z1e.e4;
    this.lineDistancesNeedUpdate = Z1e.e4;
    this.groupsNeedUpdate = Z1e.e4;
};
THREE.Geometry.prototype = {
    constructor: THREE.Geometry, applyMatrix: function (d) {
        var e = new THREE.Matrix3().getNormalMatrix(d);
        for (var f = 0, i = this.vertices.length; f < i; f++) {
            var j = this.vertices[f];
            j.applyMatrix4(d);
        }
        for (var f = 0, i = this.faces.length; f < i; f++) {
            var k = this.faces[f];
            k.normal.applyMatrix3(e).normalize();
            for (var m = 0, n = k.vertexNormals.length; m < n; m++) {
                k.vertexNormals[m].applyMatrix3(e).normalize();
            }
        }
        if (this.boundingBox !== Z1e.l3) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== Z1e.l3) {
            this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = Z1e.n3;
        this.normalsNeedUpdate = Z1e.n3;
        return this;
    }, rotateX: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Matrix4();
            e.makeRotationX(d);
            this.applyMatrix(e);
            return this;
        };
    }(), rotateY: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Matrix4();
            e.makeRotationY(d);
            this.applyMatrix(e);
            return this;
        };
    }(), rotateZ: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Matrix4();
            e.makeRotationZ(d);
            this.applyMatrix(e);
            return this;
        };
    }(), translate: function () {
        var i;
        return function j(d, e, f) {
            if (i === undefined) i = new THREE.Matrix4();
            i.makeTranslation(d, e, f);
            this.applyMatrix(i);
            return this;
        };
    }(), scale: function () {
        var i;
        return function j(d, e, f) {
            if (i === undefined) i = new THREE.Matrix4();
            i.makeScale(d, e, f);
            this.applyMatrix(i);
            return this;
        };
    }(), lookAt: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Object3D();
            e.lookAt(d);
            e.updateMatrix();
            this.applyMatrix(e.matrix);
        };
    }(), fromBufferGeometry: function (n) {
        var u = this, v = n.index !== Z1e.l3 ? n.index.array : undefined, B = n.attributes, C = B.position.array,
            G = B.normal !== undefined ? B.normal.array : undefined,
            L = B.color !== undefined ? B.color.array : undefined, N = B.uv !== undefined ? B.uv.array : undefined,
            T = B.uv2 !== undefined ? B.uv2.array : undefined;
        if (T !== undefined) this.faceVertexUvs[1] = [];
        var S = [], b0 = [], h0 = [];
        for (var f0 = 0, i0 = 0; f0 < C.length; f0 += 3, i0 += 2) {
            u.vertices.push(new THREE.Vector3(C[f0], C[f0 + 1], C[f0 + 2]));
            if (G !== undefined) {
                S.push(new THREE.Vector3(G[f0], G[f0 + 1], G[f0 + 2]));
            }
            if (L !== undefined) {
                u.colors.push(new THREE.Color(L[f0], L[f0 + 1], L[f0 + 2]));
            }
            if (N !== undefined) {
                b0.push(new THREE.Vector2(N[i0], N[i0 + 1]));
            }
            if (T !== undefined) {
                h0.push(new THREE.Vector2(T[i0], T[i0 + 1]));
            }
        }
        function s0(d, e, f, i) {
            var j = G !== undefined ? [S[d].clone(), S[e].clone(), S[f].clone()] : [],
                k = L !== undefined ? [u.colors[d].clone(), u.colors[e].clone(), u.colors[f].clone()] : [],
                m = new THREE.Face3(d, e, f, j, k, i);
            u.faces.push(m);
            if (N !== undefined) {
                u.faceVertexUvs[0].push([b0[d].clone(), b0[e].clone(), b0[f].clone()]);
            }
            if (T !== undefined) {
                u.faceVertexUvs[1].push([h0[d].clone(), h0[e].clone(), h0[f].clone()]);
            }
        }
        if (v !== undefined) {
            var t0 = n.groups;
            if (t0.length > 0) {
                for (var f0 = 0; f0 < t0.length; f0++) {
                    var o0 = t0[f0], w0 = o0.start, x0 = o0.count;
                    for (var i0 = w0, D0 = w0 + x0; i0 < D0; i0 += 3) {
                        s0(v[i0], v[i0 + 1], v[i0 + 2], o0.materialIndex);
                    }
                }
            } else {
                for (var f0 = 0; f0 < v.length; f0 += 3) {
                    s0(v[f0], v[f0 + 1], v[f0 + 2]);
                }
            }
        } else {
            for (var f0 = 0; f0 < C.length / 3; f0 += 3) {
                s0(f0, f0 + 1, f0 + 2);
            }
        }
        this.computeFaceNormals();
        if (n.boundingBox !== Z1e.l3) {
            this.boundingBox = n.boundingBox.clone();
        }
        if (n.boundingSphere !== Z1e.l3) {
            this.boundingSphere = n.boundingSphere.clone();
        }
        return this;
    }, center: function () {
        this.computeBoundingBox();
        var d = this.boundingBox.center().negate();
        this.translate(d.x, d.y, d.z);
        return d;
    }, normalize: function () {
        this.computeBoundingSphere();
        var d = this.boundingSphere.center, e = this.boundingSphere.radius, f = e === 0 ? 1 : Z1e.d4 / e,
            i = new THREE.Matrix4();
        i.set(f, 0, 0, -f * d.x, 0, f, 0, -f * d.y, 0, 0, f, -f * d.z, 0, 0, 0, 1);
        this.applyMatrix(i);
        return this;
    }, computeFaceNormals: function () {
        var d = new THREE.Vector3(), e = new THREE.Vector3();
        for (var f = 0, i = this.faces.length; f < i; f++) {
            var j = this.faces[f], k = this.vertices[j.a], m = this.vertices[j.b], n = this.vertices[j.c];
            d.subVectors(n, m);
            e.subVectors(k, m);
            d.cross(e);
            d.normalize();
            j.normal.copy(d);
        }
    }, computeVertexNormals: function (d) {
        if (d === undefined) d = Z1e.n3;
        var e, f, i, j, k, m;
        m = new Array(this.vertices.length);
        for (e = 0, f = this.vertices.length; e < f; e++) {
            m[e] = new THREE.Vector3();
        }
        if (d) {
            var n, u, v, B = new THREE.Vector3(), C = new THREE.Vector3();
            for (i = 0, j = this.faces.length; i < j; i++) {
                k = this.faces[i];
                n = this.vertices[k.a];
                u = this.vertices[k.b];
                v = this.vertices[k.c];
                B.subVectors(v, u);
                C.subVectors(n, u);
                B.cross(C);
                m[k.a].add(B);
                m[k.b].add(B);
                m[k.c].add(B);
            }
        } else {
            for (i = 0, j = this.faces.length; i < j; i++) {
                k = this.faces[i];
                m[k.a].add(k.normal);
                m[k.b].add(k.normal);
                m[k.c].add(k.normal);
            }
        }
        for (e = 0, f = this.vertices.length; e < f; e++) {
            m[e].normalize();
        }
        for (i = 0, j = this.faces.length; i < j; i++) {
            k = this.faces[i];
            var G = k.vertexNormals;
            if (G.length === 3) {
                G[0].copy(m[k.a]);
                G[1].copy(m[k.b]);
                G[2].copy(m[k.c]);
            } else {
                G[0] = m[k.a].clone();
                G[1] = m[k.b].clone();
                G[2] = m[k.c].clone();
            }
        }
        if (this.faces.length > 0) {
            this.normalsNeedUpdate = Z1e.n3;
        }
    }, computeMorphNormals: function () {
        var d, e, f, i, j;
        for (f = 0, i = this.faces.length; f < i; f++) {
            j = this.faces[f];
            if (!j.__originalFaceNormal) {
                j.__originalFaceNormal = j.normal.clone();
            } else {
                j.__originalFaceNormal.copy(j.normal);
            }
            if (!j.__originalVertexNormals) j.__originalVertexNormals = [];
            for (d = 0, e = j.vertexNormals.length; d < e; d++) {
                if (!j.__originalVertexNormals[d]) {
                    j.__originalVertexNormals[d] = j.vertexNormals[d].clone();
                } else {
                    j.__originalVertexNormals[d].copy(j.vertexNormals[d]);
                }
            }
        }
        var k = new THREE.Geometry();
        k.faces = this.faces;
        for (d = 0, e = this.morphTargets.length; d < e; d++) {
            if (!this.morphNormals[d]) {
                this.morphNormals[d] = {};
                this.morphNormals[d].faceNormals = [];
                this.morphNormals[d].vertexNormals = [];
                var m = this.morphNormals[d].faceNormals, n = this.morphNormals[d].vertexNormals, u, v;
                for (f = 0, i = this.faces.length; f < i; f++) {
                    u = new THREE.Vector3();
                    v = {a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3()};
                    m.push(u);
                    n.push(v);
                }
            }
            var B = this.morphNormals[d];
            k.vertices = this.morphTargets[d].vertices;
            k.computeFaceNormals();
            k.computeVertexNormals();
            var u, v;
            for (f = 0, i = this.faces.length; f < i; f++) {
                j = this.faces[f];
                u = B.faceNormals[f];
                v = B.vertexNormals[f];
                u.copy(j.normal);
                v.a.copy(j.vertexNormals[0]);
                v.b.copy(j.vertexNormals[1]);
                v.c.copy(j.vertexNormals[2]);
            }
        }
        for (f = 0, i = this.faces.length; f < i; f++) {
            j = this.faces[f];
            j.normal = j.__originalFaceNormal;
            j.vertexNormals = j.__originalVertexNormals;
        }
    }, computeTangents: function () {
        console.warn('THREE.Geometry: .computeTangents() has been removed.');
    }, computeLineDistances: function () {
        var d = 0, e = this.vertices;
        for (var f = 0, i = e.length; f < i; f++) {
            if (f > 0) {
                d += e[f].distanceTo(e[f - 1]);
            }
            this.lineDistances[f] = d;
        }
    }, computeBoundingBox: function () {
        if (this.boundingBox === Z1e.l3) {
            this.boundingBox = new THREE.Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
    }, computeBoundingSphere: function () {
        if (this.boundingSphere === Z1e.l3) {
            this.boundingSphere = new THREE.Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
    }, merge: function (d, e, f) {
        if (d instanceof THREE.Geometry === Z1e.e4) {
            console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', d);
            return;
        }
        var i, j = this.vertices.length, k = this.vertices, m = d.vertices, n = this.faces, u = d.faces,
            v = this.faceVertexUvs[0], B = d.faceVertexUvs[0];
        if (f === undefined) f = 0;
        if (e !== undefined) {
            i = new THREE.Matrix3().getNormalMatrix(e);
        }
        for (var C = 0, G = m.length; C < G; C++) {
            var L = m[C], N = L.clone();
            if (e !== undefined) N.applyMatrix4(e);
            k.push(N);
        }
        for (C = 0, G = u.length; C < G; C++) {
            var T = u[C], S, b0, h0, f0 = T.vertexNormals, i0 = T.vertexColors;
            S = new THREE.Face3(T.a + j, T.b + j, T.c + j);
            S.normal.copy(T.normal);
            if (i !== undefined) {
                S.normal.applyMatrix3(i).normalize();
            }
            for (var s0 = 0, t0 = f0.length; s0 < t0; s0++) {
                b0 = f0[s0].clone();
                if (i !== undefined) {
                    b0.applyMatrix3(i).normalize();
                }
                S.vertexNormals.push(b0);
            }
            S.color.copy(T.color);
            for (var s0 = 0, t0 = i0.length; s0 < t0; s0++) {
                h0 = i0[s0];
                S.vertexColors.push(h0.clone());
            }
            S.materialIndex = T.materialIndex + f;
            n.push(S);
        }
        for (C = 0, G = B.length; C < G; C++) {
            var o0 = B[C], w0 = [];
            if (o0 === undefined) {
                continue;
            }
            for (var s0 = 0, t0 = o0.length; s0 < t0; s0++) {
                w0.push(o0[s0].clone());
            }
            v.push(w0);
        }
    }, mergeMesh: function (d) {
        if (d instanceof THREE.Mesh === Z1e.e4) {
            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', d);
            return;
        }
        d.matrixAutoUpdate && d.updateMatrix();
        this.merge(d.geometry, d.matrix);
    }, mergeVertices: function () {
        var d = {}, e = [], f = [], i, j, k = 4, m = Math.pow(10, k), n, u, v, B, C, G;
        for (n = 0, u = this.vertices.length; n < u; n++) {
            i = this.vertices[n];
            j = Math.round(i.x * m) + '_' + Math.round(i.y * m) + '_' + Math.round(i.z * m);
            if (d[j] === undefined) {
                d[j] = n;
                e.push(this.vertices[n]);
                f[n] = e.length - 1;
            } else {
                f[n] = f[d[j]];
            }
        }
        var L = [];
        for (n = 0, u = this.faces.length; n < u; n++) {
            v = this.faces[n];
            v.a = f[v.a];
            v.b = f[v.b];
            v.c = f[v.c];
            B = [v.a, v.b, v.c];
            var N = -1;
            for (var T = 0; T < 3; T++) {
                if (B[T] === B[(T + 1) % 3]) {
                    N = T;
                    L.push(n);
                    break;
                }
            }
        }
        for (n = L.length - 1; n >= 0; n--) {
            var S = L[n];
            this.faces.splice(S, 1);
            for (C = 0, G = this.faceVertexUvs.length; C < G; C++) {
                this.faceVertexUvs[C].splice(S, 1);
            }
        }
        var b0 = this.vertices.length - e.length;
        this.vertices = e;
        return b0;
    }, sortFacesByMaterialIndex: function () {
        var f = this.faces, i = f.length;
        for (var j = 0; j < i; j++) {
            f[j]._id = j;
        }
        function k(d, e) {
            return d.materialIndex - e.materialIndex;
        }
        f.sort(k);
        var m = this.faceVertexUvs[0], n = this.faceVertexUvs[1], u, v;
        if (m && m.length === i) u = [];
        if (n && n.length === i) v = [];
        for (var j = 0; j < i; j++) {
            var B = f[j]._id;
            if (u) u.push(m[B]);
            if (v) v.push(n[B]);
        }
        if (u) this.faceVertexUvs[0] = u;
        if (v) this.faceVertexUvs[1] = v;
    }, toJSON: function () {
        var i = {metadata: {version: 4.4, type: Z1e.C0, generator: 'Geometry.toJSON'}};
        i.uuid = this.uuid;
        i.type = this.type;
        if (this.name !== '') i.name = this.name;
        if (this.parameters !== undefined) {
            var j = this.parameters;
            for (var k in j) {
                if (j[k] !== undefined) i[k] = j[k];
            }
            return i;
        }
        var m = [];
        for (var n = 0; n < this.vertices.length; n++) {
            var u = this.vertices[n];
            m.push(u.x, u.y, u.z);
        }
        var v = [], B = [], C = {}, G = [], L = {}, N = [], T = {};
        for (var n = 0; n < this.faces.length; n++) {
            var S = this.faces[n], b0 = Z1e.n3, h0 = Z1e.e4, f0 = this.faceVertexUvs[0][n] !== undefined,
                i0 = S.normal.length() > 0, s0 = S.vertexNormals.length > 0,
                t0 = S.color.r !== 1 || S.color.g !== 1 || S.color.b !== 1, o0 = S.vertexColors.length > 0, w0 = 0;
            w0 = m0(w0, 0, 0);
            w0 = m0(w0, 1, b0);
            w0 = m0(w0, 2, h0);
            w0 = m0(w0, 3, f0);
            w0 = m0(w0, 4, i0);
            w0 = m0(w0, 5, s0);
            w0 = m0(w0, 6, t0);
            w0 = m0(w0, 7, o0);
            v.push(w0);
            v.push(S.a, S.b, S.c);
            v.push(S.materialIndex);
            if (f0) {
                var x0 = this.faceVertexUvs[0][n];
                v.push(P0(x0[0]), P0(x0[1]), P0(x0[2]));
            }
            if (i0) {
                v.push(W0(S.normal));
            }
            if (s0) {
                var D0 = S.vertexNormals;
                v.push(W0(D0[0]), W0(D0[1]), W0(D0[2]));
            }
            if (t0) {
                v.push(y0(S.color));
            }
            if (o0) {
                var F0 = S.vertexColors;
                v.push(y0(F0[0]), y0(F0[1]), y0(F0[2]));
            }
        }
        function m0(d, e, f) {
            return f ? d | (1 << e) : d & (~(1 << e));
        }
        function W0(d) {
            var e = d.x.toString() + d.y.toString() + d.z.toString();
            if (C[e] !== undefined) {
                return C[e];
            }
            C[e] = B.length / 3;
            B.push(d.x, d.y, d.z);
            return C[e];
        }
        function y0(d) {
            var e = d.r.toString() + d.g.toString() + d.b.toString();
            if (L[e] !== undefined) {
                return L[e];
            }
            L[e] = G.length;
            G.push(d.getHex());
            return L[e];
        }
        function P0(d) {
            var e = d.x.toString() + d.y.toString();
            if (T[e] !== undefined) {
                return T[e];
            }
            T[e] = N.length / 2;
            N.push(d.x, d.y);
            return T[e];
        }
        i.data = {};
        i.data.vertices = m;
        i.data.normals = B;
        if (G.length > 0) i.data.colors = G;
        if (N.length > 0) i.data.uvs = [N];
        i.data.faces = v;
        return i;
    }, clone: function () {
        return new THREE.Geometry().copy(this);
    }, copy: function (d) {
        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        var e = d.vertices;
        for (var f = 0, i = e.length; f < i; f++) {
            this.vertices.push(e[f].clone());
        }
        var j = d.faces;
        for (var f = 0, i = j.length; f < i; f++) {
            this.faces.push(j[f].clone());
        }
        for (var f = 0, i = d.faceVertexUvs.length; f < i; f++) {
            var k = d.faceVertexUvs[f];
            if (this.faceVertexUvs[f] === undefined) {
                this.faceVertexUvs[f] = [];
            }
            for (var m = 0, n = k.length; m < n; m++) {
                var u = k[m], v = [];
                for (var B = 0, C = u.length; B < C; B++) {
                    var G = u[B];
                    v.push(G.clone());
                }
                this.faceVertexUvs[f].push(v);
            }
        }
        return this;
    }, dispose: function () {
        this.dispatchEvent({type: Z1e.L0});
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.DirectGeometry = function () {
    Object.defineProperty(this, Z1e.S0, {value: THREE.GeometryIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = 'DirectGeometry';
    this.indices = [];
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingBox = Z1e.l3;
    this.boundingSphere = Z1e.l3;
    this.verticesNeedUpdate = Z1e.e4;
    this.normalsNeedUpdate = Z1e.e4;
    this.colorsNeedUpdate = Z1e.e4;
    this.uvsNeedUpdate = Z1e.e4;
    this.groupsNeedUpdate = Z1e.e4;
};
THREE.DirectGeometry.prototype = {
    constructor: THREE.DirectGeometry,
    computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
    computeFaceNormals: function () {
        console.warn('THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.');
    },
    computeVertexNormals: function () {
        console.warn('THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.');
    },
    computeGroups: function (d) {
        var e, f = [], i, j = d.faces;
        for (var k = 0; k < j.length; k++) {
            var m = j[k];
            if (m.materialIndex !== i) {
                i = m.materialIndex;
                if (e !== undefined) {
                    e.count = (k * 3) - e.start;
                    f.push(e);
                }
                e = {start: k * 3, materialIndex: i};
            }
        }
        if (e !== undefined) {
            e.count = (k * 3) - e.start;
            f.push(e);
        }
        this.groups = f;
    },
    fromGeometry: function (d) {
        var e = d.faces, f = d.vertices, i = d.faceVertexUvs, j = i[0] && i[0].length > 0, k = i[1] && i[1].length > 0,
            m = d.morphTargets, n = m.length, u;
        if (n > 0) {
            u = [];
            for (var v = 0; v < n; v++) {
                u[v] = [];
            }
            this.morphTargets.position = u;
        }
        var B = d.morphNormals, C = B.length, G;
        if (C > 0) {
            G = [];
            for (var v = 0; v < C; v++) {
                G[v] = [];
            }
            this.morphTargets.normal = G;
        }
        var L = d.skinIndices, N = d.skinWeights, T = L.length === f.length, S = N.length === f.length;
        for (var v = 0; v < e.length; v++) {
            var b0 = e[v];
            this.vertices.push(f[b0.a], f[b0.b], f[b0.c]);
            var h0 = b0.vertexNormals;
            if (h0.length === 3) {
                this.normals.push(h0[0], h0[1], h0[2]);
            } else {
                var f0 = b0.normal;
                this.normals.push(f0, f0, f0);
            }
            var i0 = b0.vertexColors;
            if (i0.length === 3) {
                this.colors.push(i0[0], i0[1], i0[2]);
            } else {
                var s0 = b0.color;
                this.colors.push(s0, s0, s0);
            }
            if (j === Z1e.n3) {
                var t0 = i[0][v];
                if (t0 !== undefined) {
                    this.uvs.push(t0[0], t0[1], t0[2]);
                } else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', v);
                    this.uvs.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
                }
            }
            if (k === Z1e.n3) {
                var t0 = i[1][v];
                if (t0 !== undefined) {
                    this.uvs2.push(t0[0], t0[1], t0[2]);
                } else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', v);
                    this.uvs2.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
                }
            }
            for (var o0 = 0; o0 < n; o0++) {
                var w0 = m[o0].vertices;
                u[o0].push(w0[b0.a], w0[b0.b], w0[b0.c]);
            }
            for (var o0 = 0; o0 < C; o0++) {
                var x0 = B[o0].vertexNormals[v];
                G[o0].push(x0.a, x0.b, x0.c);
            }
            if (T) {
                this.skinIndices.push(L[b0.a], L[b0.b], L[b0.c]);
            }
            if (S) {
                this.skinWeights.push(N[b0.a], N[b0.b], N[b0.c]);
            }
        }
        this.computeGroups(d);
        this.verticesNeedUpdate = d.verticesNeedUpdate;
        this.normalsNeedUpdate = d.normalsNeedUpdate;
        this.colorsNeedUpdate = d.colorsNeedUpdate;
        this.uvsNeedUpdate = d.uvsNeedUpdate;
        this.groupsNeedUpdate = d.groupsNeedUpdate;
        return this;
    },
    dispose: function () {
        this.dispatchEvent({type: Z1e.L0});
    }
};
THREE.EventDispatcher.prototype.apply(THREE.DirectGeometry.prototype);
THREE.BufferGeometry = function () {
    Object.defineProperty(this, Z1e.S0, {value: THREE.GeometryIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = Z1e.T2;
    this.index = Z1e.l3;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = Z1e.l3;
    this.boundingSphere = Z1e.l3;
    this.drawRange = {start: 0, count: Infinity};
};
THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry, getIndex: function () {
        return this.index;
    }, setIndex: function (d) {
        this.index = d;
    }, addAttribute: function (d, e) {
        if (e instanceof THREE.BufferAttribute === Z1e.e4 && e instanceof THREE.InterleavedBufferAttribute === Z1e.e4) {
            console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
            this.addAttribute(d, new THREE.BufferAttribute(arguments[1], arguments[2]));
            return;
        }
        if (d === 'index') {
            console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
            this.setIndex(e);
            return;
        }
        this.attributes[d] = e;
        return this;
    }, getAttribute: function (d) {
        return this.attributes[d];
    }, removeAttribute: function (d) {
        delete  this.attributes[d];
        return this;
    }, addGroup: function (d, e, f) {
        this.groups.push({start: d, count: e, materialIndex: f !== undefined ? f : 0});
    }, clearGroups: function () {
        this.groups = [];
    }, setDrawRange: function (d, e) {
        this.drawRange.start = d;
        this.drawRange.count = e;
    }, applyMatrix: function (d) {
        var e = this.attributes.position;
        if (e !== undefined) {
            d.applyToVector3Array(e.array);
            e.needsUpdate = Z1e.n3;
        }
        var f = this.attributes.normal;
        if (f !== undefined) {
            var i = new THREE.Matrix3().getNormalMatrix(d);
            i.applyToVector3Array(f.array);
            f.needsUpdate = Z1e.n3;
        }
        if (this.boundingBox !== Z1e.l3) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere !== Z1e.l3) {
            this.computeBoundingSphere();
        }
        return this;
    }, rotateX: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Matrix4();
            e.makeRotationX(d);
            this.applyMatrix(e);
            return this;
        };
    }(), rotateY: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Matrix4();
            e.makeRotationY(d);
            this.applyMatrix(e);
            return this;
        };
    }(), rotateZ: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Matrix4();
            e.makeRotationZ(d);
            this.applyMatrix(e);
            return this;
        };
    }(), translate: function () {
        var i;
        return function j(d, e, f) {
            if (i === undefined) i = new THREE.Matrix4();
            i.makeTranslation(d, e, f);
            this.applyMatrix(i);
            return this;
        };
    }(), scale: function () {
        var i;
        return function j(d, e, f) {
            if (i === undefined) i = new THREE.Matrix4();
            i.makeScale(d, e, f);
            this.applyMatrix(i);
            return this;
        };
    }(), lookAt: function () {
        var e;
        return function f(d) {
            if (e === undefined) e = new THREE.Object3D();
            e.lookAt(d);
            e.updateMatrix();
            this.applyMatrix(e.matrix);
        };
    }(), center: function () {
        this.computeBoundingBox();
        var d = this.boundingBox.center().negate();
        this.translate(d.x, d.y, d.z);
        return d;
    }, setFromObject: function (d) {
        var e = d.geometry;
        if (d instanceof THREE.Points || d instanceof THREE.Line) {
            var f = new THREE.Float32Attribute(e.vertices.length * 3, 3),
                i = new THREE.Float32Attribute(e.colors.length * 3, 3);
            this.addAttribute(Z1e.g1, f.copyVector3sArray(e.vertices));
            this.addAttribute(Z1e.X1, i.copyColorsArray(e.colors));
            if (e.lineDistances && e.lineDistances.length === e.vertices.length) {
                var j = new THREE.Float32Attribute(e.lineDistances.length, 1);
                this.addAttribute('lineDistance', j.copyArray(e.lineDistances));
            }
            if (e.boundingSphere !== Z1e.l3) {
                this.boundingSphere = e.boundingSphere.clone();
            }
            if (e.boundingBox !== Z1e.l3) {
                this.boundingBox = e.boundingBox.clone();
            }
        } else if (d instanceof THREE.Mesh) {
            if (e instanceof THREE.Geometry) {
                this.fromGeometry(e);
            }
        }
        return this;
    }, updateFromObject: function (d) {
        var e = d.geometry;
        if (d instanceof THREE.Mesh) {
            var f = e.__directGeometry;
            if (f === undefined) {
                return this.fromGeometry(e);
            }
            f.verticesNeedUpdate = e.verticesNeedUpdate;
            f.normalsNeedUpdate = e.normalsNeedUpdate;
            f.colorsNeedUpdate = e.colorsNeedUpdate;
            f.uvsNeedUpdate = e.uvsNeedUpdate;
            f.groupsNeedUpdate = e.groupsNeedUpdate;
            e.verticesNeedUpdate = Z1e.e4;
            e.normalsNeedUpdate = Z1e.e4;
            e.colorsNeedUpdate = Z1e.e4;
            e.uvsNeedUpdate = Z1e.e4;
            e.groupsNeedUpdate = Z1e.e4;
            e = f;
        }
        if (e.verticesNeedUpdate === Z1e.n3) {
            var i = this.attributes.position;
            if (i !== undefined) {
                i.copyVector3sArray(e.vertices);
                i.needsUpdate = Z1e.n3;
            }
            e.verticesNeedUpdate = Z1e.e4;
        }
        if (e.normalsNeedUpdate === Z1e.n3) {
            var i = this.attributes.normal;
            if (i !== undefined) {
                i.copyVector3sArray(e.normals);
                i.needsUpdate = Z1e.n3;
            }
            e.normalsNeedUpdate = Z1e.e4;
        }
        if (e.colorsNeedUpdate === Z1e.n3) {
            var i = this.attributes.color;
            if (i !== undefined) {
                i.copyColorsArray(e.colors);
                i.needsUpdate = Z1e.n3;
            }
            e.colorsNeedUpdate = Z1e.e4;
        }
        if (e.uvsNeedUpdate) {
            var i = this.attributes.uv;
            if (i !== undefined) {
                i.copyVector2sArray(e.uvs);
                i.needsUpdate = Z1e.n3;
            }
            e.uvsNeedUpdate = Z1e.e4;
        }
        if (e.lineDistancesNeedUpdate) {
            var i = this.attributes.lineDistance;
            if (i !== undefined) {
                i.copyArray(e.lineDistances);
                i.needsUpdate = Z1e.n3;
            }
            e.lineDistancesNeedUpdate = Z1e.e4;
        }
        if (e.groupsNeedUpdate) {
            e.computeGroups(d.geometry);
            this.groups = e.groups;
            e.groupsNeedUpdate = Z1e.e4;
        }
        return this;
    }, fromGeometry: function (d) {
        d.__directGeometry = new THREE.DirectGeometry().fromGeometry(d);
        return this.fromDirectGeometry(d.__directGeometry);
    }, fromDirectGeometry: function (d) {
        var e = new Float32Array(d.vertices.length * 3);
        this.addAttribute(Z1e.g1, new THREE.BufferAttribute(e, 3).copyVector3sArray(d.vertices));
        if (d.normals.length > 0) {
            var f = new Float32Array(d.normals.length * 3);
            this.addAttribute(Z1e.R2, new THREE.BufferAttribute(f, 3).copyVector3sArray(d.normals));
        }
        if (d.colors.length > 0) {
            var i = new Float32Array(d.colors.length * 3);
            this.addAttribute(Z1e.X1, new THREE.BufferAttribute(i, 3).copyColorsArray(d.colors));
        }
        if (d.uvs.length > 0) {
            var j = new Float32Array(d.uvs.length * 2);
            this.addAttribute(Z1e.M3, new THREE.BufferAttribute(j, 2).copyVector2sArray(d.uvs));
        }
        if (d.uvs2.length > 0) {
            var k = new Float32Array(d.uvs2.length * 2);
            this.addAttribute('uv2', new THREE.BufferAttribute(k, 2).copyVector2sArray(d.uvs2));
        }
        if (d.indices.length > 0) {
            var m = d.vertices.length > Z1e.P3 ? Uint32Array : Uint16Array, n = new m(d.indices.length * 3);
            this.setIndex(new THREE.BufferAttribute(n, 1).copyIndicesArray(d.indices));
        }
        this.groups = d.groups;
        for (var u in d.morphTargets) {
            var v = [], B = d.morphTargets[u];
            for (var C = 0, G = B.length; C < G; C++) {
                var L = B[C], N = new THREE.Float32Attribute(L.length * 3, 3);
                v.push(N.copyVector3sArray(L));
            }
            this.morphAttributes[u] = v;
        }
        if (d.skinIndices.length > 0) {
            var T = new THREE.Float32Attribute(d.skinIndices.length * 4, 4);
            this.addAttribute('skinIndex', T.copyVector4sArray(d.skinIndices));
        }
        if (d.skinWeights.length > 0) {
            var S = new THREE.Float32Attribute(d.skinWeights.length * 4, 4);
            this.addAttribute('skinWeight', S.copyVector4sArray(d.skinWeights));
        }
        if (d.boundingSphere !== Z1e.l3) {
            this.boundingSphere = d.boundingSphere.clone();
        }
        if (d.boundingBox !== Z1e.l3) {
            this.boundingBox = d.boundingBox.clone();
        }
        return this;
    }, computeBoundingBox: function () {
        if (this.boundingBox === Z1e.l3) {
            this.boundingBox = new THREE.Box3();
        }
        var d = this.attributes.position.array;
        if (d !== undefined) {
            this.boundingBox.setFromArray(d);
        } else {
            this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
    }, computeBoundingSphere: function () {
        var k = new THREE.Box3(), m = new THREE.Vector3();
        return function () {
            if (this.boundingSphere === Z1e.l3) {
                this.boundingSphere = new THREE.Sphere();
            }
            var d = this.attributes.position.array;
            if (d) {
                var e = this.boundingSphere.center;
                k.setFromArray(d);
                k.center(e);
                var f = 0;
                for (var i = 0, j = d.length; i < j; i += 3) {
                    m.fromArray(d, i);
                    f = Math.max(f, e.distanceToSquared(m));
                }
                this.boundingSphere.radius = Math.sqrt(f);
                if (isNaN(this.boundingSphere.radius)) {
                    console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            }
        };
    }(), computeFaceNormals: function () {
    }, computeVertexNormals: function () {
        var d = this.index, e = this.attributes, f = this.groups;
        if (e.position) {
            var i = e.position.array;
            if (e.normal === undefined) {
                this.addAttribute(Z1e.R2, new THREE.BufferAttribute(new Float32Array(i.length), 3));
            } else {
                var j = e.normal.array;
                for (var k = 0, m = j.length; k < m; k++) {
                    j[k] = 0;
                }
            }
            var n = e.normal.array, u, v, B, C = new THREE.Vector3(), G = new THREE.Vector3(), L = new THREE.Vector3(),
                N = new THREE.Vector3(), T = new THREE.Vector3();
            if (d) {
                var S = d.array;
                if (f.length === 0) {
                    this.addGroup(0, S.length);
                }
                for (var b0 = 0, h0 = f.length; b0 < h0; ++b0) {
                    var f0 = f[b0], i0 = f0.start, s0 = f0.count;
                    for (var k = i0, m = i0 + s0; k < m; k += 3) {
                        u = S[k + 0] * 3;
                        v = S[k + 1] * 3;
                        B = S[k + 2] * 3;
                        C.fromArray(i, u);
                        G.fromArray(i, v);
                        L.fromArray(i, B);
                        N.subVectors(L, G);
                        T.subVectors(C, G);
                        N.cross(T);
                        n[u] += N.x;
                        n[u + 1] += N.y;
                        n[u + 2] += N.z;
                        n[v] += N.x;
                        n[v + 1] += N.y;
                        n[v + 2] += N.z;
                        n[B] += N.x;
                        n[B + 1] += N.y;
                        n[B + 2] += N.z;
                    }
                }
            } else {
                for (var k = 0, m = i.length; k < m; k += 9) {
                    C.fromArray(i, k);
                    G.fromArray(i, k + 3);
                    L.fromArray(i, k + 6);
                    N.subVectors(L, G);
                    T.subVectors(C, G);
                    N.cross(T);
                    n[k] = N.x;
                    n[k + 1] = N.y;
                    n[k + 2] = N.z;
                    n[k + 3] = N.x;
                    n[k + 4] = N.y;
                    n[k + 5] = N.z;
                    n[k + 6] = N.x;
                    n[k + 7] = N.y;
                    n[k + 8] = N.z;
                }
            }
            this.normalizeNormals();
            e.normal.needsUpdate = Z1e.n3;
        }
    }, merge: function (d, e) {
        if (d instanceof THREE.BufferGeometry === Z1e.e4) {
            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', d);
            return;
        }
        if (e === undefined) e = 0;
        var f = this.attributes;
        for (var i in f) {
            if (d.attributes[i] === undefined)continue;
            var j = f[i], k = j.array, m = d.attributes[i], n = m.array, u = m.itemSize;
            for (var v = 0, B = u * e; v < n.length; v++, B++) {
                k[B] = n[v];
            }
        }
        return this;
    }, normalizeNormals: function () {
        var d = this.attributes.normal.array, e, f, i, j;
        for (var k = 0, m = d.length; k < m; k += 3) {
            e = d[k];
            f = d[k + 1];
            i = d[k + 2];
            j = Z1e.d4 / Math.sqrt(e * e + f * f + i * i);
            d[k] *= j;
            d[k + 1] *= j;
            d[k + 2] *= j;
        }
    }, toNonIndexed: function () {
        if (this.index === Z1e.l3) {
            console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
            return this;
        }
        var d = new THREE.BufferGeometry(), e = this.index.array, f = this.attributes;
        for (var i in f) {
            var j = f[i], k = j.array, m = j.itemSize, n = new k.constructor(e.length * m), u = 0, v = 0;
            for (var B = 0, C = e.length; B < C; B++) {
                u = e[B] * m;
                for (var G = 0; G < m; G++) {
                    n[v++] = k[u++];
                }
            }
            d.addAttribute(i, new THREE.BufferAttribute(n, m));
        }
        return d;
    }, toJSON: function () {
        var d = {metadata: {version: 4.4, type: Z1e.T2, generator: 'BufferGeometry.toJSON'}};
        d.uuid = this.uuid;
        d.type = this.type;
        if (this.name !== '') d.name = this.name;
        if (this.parameters !== undefined) {
            var e = this.parameters;
            for (var f in e) {
                if (e[f] !== undefined) d[f] = e[f];
            }
            return d;
        }
        d.data = {attributes: {}};
        var i = this.index;
        if (i !== Z1e.l3) {
            var j = Array.prototype.slice.call(i.array);
            d.data.index = {type: i.array.constructor.name, array: j};
        }
        var k = this.attributes;
        for (var f in k) {
            var m = k[f], j = Array.prototype.slice.call(m.array);
            d.data.attributes[f] = {
                itemSize: m.itemSize,
                type: m.array.constructor.name,
                array: j,
                normalized: m.normalized
            };
        }
        var n = this.groups;
        if (n.length > 0) {
            d.data.groups = JSON.parse(JSON.stringify(n));
        }
        var u = this.boundingSphere;
        if (u !== Z1e.l3) {
            d.data.boundingSphere = {center: u.center.toArray(), radius: u.radius};
        }
        return d;
    }, clone: function () {
        return new THREE.BufferGeometry().copy(this);
    }, copy: function (d) {
        var e = d.index;
        if (e !== Z1e.l3) {
            this.setIndex(e.clone());
        }
        var f = d.attributes;
        for (var i in f) {
            var j = f[i];
            this.addAttribute(i, j.clone());
        }
        var k = d.groups;
        for (var m = 0, n = k.length; m < n; m++) {
            var u = k[m];
            this.addGroup(u.start, u.count, u.materialIndex);
        }
        return this;
    }, dispose: function () {
        this.dispatchEvent({type: Z1e.L0});
    }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.BufferGeometry.MaxIndex = Z1e.P3;
THREE.InstancedBufferGeometry = function () {
    THREE.BufferGeometry.call(this);
    this.type = 'InstancedBufferGeometry';
    this.maxInstancedCount = undefined;
};
THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
THREE.InstancedBufferGeometry.prototype.addGroup = function (d, e, f) {
    this.groups.push({start: d, count: e, instances: f});
};
THREE.InstancedBufferGeometry.prototype.copy = function (d) {
    var e = d.index;
    if (e !== Z1e.l3) {
        this.setIndex(e.clone());
    }
    var f = d.attributes;
    for (var i in f) {
        var j = f[i];
        this.addAttribute(i, j.clone());
    }
    var k = d.groups;
    for (var m = 0, n = k.length; m < n; m++) {
        var u = k[m];
        this.addGroup(u.start, u.count, u.instances);
    }
    return this;
};
THREE.EventDispatcher.prototype.apply(THREE.InstancedBufferGeometry.prototype);
THREE.Uniform = function (d) {
    if (typeof d === Z1e.W1) {
        console.warn('THREE.Uniform: Type parameter is no longer needed.');
        d = arguments[1];
    }
    this.value = d;
    this.dynamic = Z1e.e4;
};
THREE.Uniform.prototype = {
    constructor: THREE.Uniform, onUpdate: function (d) {
        this.dynamic = Z1e.n3;
        this.onUpdateCallback = d;
        return this;
    }
};
THREE.AnimationClip = function (d, e, f) {
    this.name = d || THREE.Math.generateUUID();
    this.tracks = f;
    this.duration = (e !== undefined) ? e : -1;
    if (this.duration < 0) {
        this.resetDuration();
    }
    this.trim();
    this.optimize();
};
THREE.AnimationClip.prototype = {
    constructor: THREE.AnimationClip, resetDuration: function () {
        var d = this.tracks, e = 0;
        for (var f = 0, i = d.length; f !== i; ++f) {
            var j = this.tracks[f];
            e = Math.max(e, j.times[j.times.length - 1]);
        }
        this.duration = e;
    }, trim: function () {
        for (var d = 0; d < this.tracks.length; d++) {
            this.tracks[d].trim(0, this.duration);
        }
        return this;
    }, optimize: function () {
        for (var d = 0; d < this.tracks.length; d++) {
            this.tracks[d].optimize();
        }
        return this;
    }
};
Object.assign(THREE.AnimationClip, {
    parse: function (d) {
        var e = [], f = d.tracks, i = Z1e.d4 / (d.fps || Z1e.d4);
        for (var j = 0, k = f.length; j !== k; ++j) {
            e.push(THREE.KeyframeTrack.parse(f[j]).scale(i));
        }
        return new THREE.AnimationClip(d.name, d.duration, e);
    }, toJSON: function (d) {
        var e = [], f = d.tracks, i = {'name': d.name, 'duration': d.duration, 'tracks': e};
        for (var j = 0, k = f.length; j !== k; ++j) {
            e.push(THREE.KeyframeTrack.toJSON(f[j]));
        }
        return i;
    }, CreateFromMorphTargetSequence: function (d, e, f, i) {
        var j = e.length, k = [];
        for (var m = 0; m < j; m++) {
            var n = [], u = [];
            n.push((m + j - 1) % j, m, (m + 1) % j);
            u.push(0, 1, 0);
            var v = THREE.AnimationUtils.getKeyframeOrder(n);
            n = THREE.AnimationUtils.sortedArray(n, 1, v);
            u = THREE.AnimationUtils.sortedArray(u, 1, v);
            if (!i && n[0] === 0) {
                n.push(j);
                u.push(u[0]);
            }
            k.push(new THREE.NumberKeyframeTrack('.morphTargetInfluences[' + e[m].name + ']', n, u).scale(Z1e.d4 / f));
        }
        return new THREE.AnimationClip(d, -1, k);
    }, findByName: function (d, e) {
        for (var f = 0; f < d.length; f++) {
            if (d[f].name === e) {
                return d[f];
            }
        }
        return Z1e.l3;
    }, CreateClipsFromMorphTargetSequences: function (d, e, f) {
        var i = {}, j = /^([\w-]*?)([\d]+)$/;
        for (var k = 0, m = d.length; k < m; k++) {
            var n = d[k], u = n.name.match(j);
            if (u && u.length > 1) {
                var v = u[1], B = i[v];
                if (!B) {
                    i[v] = B = [];
                }
                B.push(n);
            }
        }
        var C = [];
        for (var v in i) {
            C.push(THREE.AnimationClip.CreateFromMorphTargetSequence(v, i[v], e, f));
        }
        return C;
    }, parseAnimation: function (n, u, v) {
        if (!n) {
            console.error("  no animation in JSONLoader data");
            return Z1e.l3;
        }
        var B = function (d, e, f, i, j) {
            if (f.length !== 0) {
                var k = [], m = [];
                THREE.AnimationUtils.flattenJSON(f, k, m, i);
                if (k.length !== 0) {
                    j.push(new d(e, k, m));
                }
            }
        }, C = [], G = n.name || 'default', L = n.length || -1, N = n.fps || 30, T = n.hierarchy || [];
        for (var S = 0; S < T.length; S++) {
            var b0 = T[S].keys;
            if (!b0 || b0.length == 0)continue;
            if (b0[0].morphTargets) {
                var h0 = {};
                for (var f0 = 0; f0 < b0.length; f0++) {
                    if (b0[f0].morphTargets) {
                        for (var i0 = 0; i0 < b0[f0].morphTargets.length; i0++) {
                            h0[b0[f0].morphTargets[i0]] = -1;
                        }
                    }
                }
                for (var s0 in h0) {
                    var t0 = [], o0 = [];
                    for (var i0 = 0; i0 !== b0[f0].morphTargets.length; ++i0) {
                        var w0 = b0[f0];
                        t0.push(w0.time);
                        o0.push((w0.morphTarget === s0) ? 1 : 0);
                    }
                    C.push(new THREE.NumberKeyframeTrack('.morphTargetInfluence[' + s0 + ']', t0, o0));
                }
                L = h0.length * (N || Z1e.d4);
            } else {
                var x0 = '.bones[' + u[S].name + ']';
                B(THREE.VectorKeyframeTrack, x0 + '.position', b0, 'pos', C);
                B(THREE.QuaternionKeyframeTrack, x0 + '.quaternion', b0, 'rot', C);
                B(THREE.VectorKeyframeTrack, x0 + '.scale', b0, 'scl', C);
            }
        }
        if (C.length === 0) {
            return Z1e.l3;
        }
        var D0 = new THREE.AnimationClip(G, L, C);
        return D0;
    }
});
THREE.AnimationMixer = function (d) {
    this._root = d;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = Z1e.d4;
};
THREE.AnimationMixer.prototype = {
    constructor: THREE.AnimationMixer, clipAction: function (d, e) {
        var f = e || this._root, i = f.uuid, j = (typeof d === Z1e.W1) ? d : d.name, k = (d !== j) ? d : Z1e.l3,
            m = this._actionsByClip[j], n;
        if (m !== undefined) {
            var u = m.actionByRoot[i];
            if (u !== undefined) {
                return u;
            }
            n = m.knownActions[0];
            k = n._clip;
            if (d !== j && d !== k) {
                throw  new Error("Different clips with the same name detected!");
            }
        }
        if (k === Z1e.l3)return Z1e.l3;
        var v = new THREE.AnimationMixer._Action(this, k, e);
        this._bindAction(v, n);
        this._addInactiveAction(v, j, i);
        return v;
    }, existingAction: function (d, e) {
        var f = e || this._root, i = f.uuid, j = (typeof d === Z1e.W1) ? d : d.name, k = this._actionsByClip[j];
        if (k !== undefined) {
            return k.actionByRoot[i] || Z1e.l3;
        }
        return Z1e.l3;
    }, stopAllAction: function () {
        var d = this._actions, e = this._nActiveActions, f = this._bindings, i = this._nActiveBindings;
        this._nActiveActions = 0;
        this._nActiveBindings = 0;
        for (var j = 0; j !== e; ++j) {
            d[j].reset();
        }
        for (var j = 0; j !== i; ++j) {
            f[j].useCount = 0;
        }
        return this;
    }, update: function (d) {
        d *= this.timeScale;
        var e = this._actions, f = this._nActiveActions, i = this.time += d, j = Math.sign(d), k = this._accuIndex ^= 1;
        for (var m = 0; m !== f; ++m) {
            var n = e[m];
            if (n.enabled) {
                n._update(i, d, j, k);
            }
        }
        var u = this._bindings, v = this._nActiveBindings;
        for (var m = 0; m !== v; ++m) {
            u[m].apply(k);
        }
        return this;
    }, getRoot: function () {
        return this._root;
    }, uncacheClip: function (d) {
        var e = this._actions, f = d.name, i = this._actionsByClip, j = i[f];
        if (j !== undefined) {
            var k = j.knownActions;
            for (var m = 0, n = k.length; m !== n; ++m) {
                var u = k[m];
                this._deactivateAction(u);
                var v = u._cacheIndex, B = e[e.length - 1];
                u._cacheIndex = Z1e.l3;
                u._byClipCacheIndex = Z1e.l3;
                B._cacheIndex = v;
                e[v] = B;
                e.pop();
                this._removeInactiveBindingsForAction(u);
            }
            delete  i[f];
        }
    }, uncacheRoot: function (d) {
        var e = d.uuid, f = this._actionsByClip;
        for (var i in f) {
            var j = f[i].actionByRoot, k = j[e];
            if (k !== undefined) {
                this._deactivateAction(k);
                this._removeInactiveAction(k);
            }
        }
        var m = this._bindingsByRootAndName, n = m[e];
        if (n !== undefined) {
            for (var u in n) {
                var v = n[u];
                v.restoreOriginalState();
                this._removeInactiveBinding(v);
            }
        }
    }, uncacheAction: function (d, e) {
        var f = this.existingAction(d, e);
        if (f !== Z1e.l3) {
            this._deactivateAction(f);
            this._removeInactiveAction(f);
        }
    }
};
THREE.EventDispatcher.prototype.apply(THREE.AnimationMixer.prototype);
THREE.AnimationMixer._Action = function (d, e, f) {
    this._mixer = d;
    this._clip = e;
    this._localRoot = f || Z1e.l3;
    var i = e.tracks, j = i.length, k = new Array(j),
        m = {endingStart: THREE.ZeroCurvatureEnding, endingEnd: THREE.ZeroCurvatureEnding};
    for (var n = 0; n !== j; ++n) {
        var u = i[n].createInterpolant(Z1e.l3);
        k[n] = u;
        u.settings = m;
    }
    this._interpolantSettings = m;
    this._interpolants = k;
    this._propertyBindings = new Array(j);
    this._cacheIndex = Z1e.l3;
    this._byClipCacheIndex = Z1e.l3;
    this._timeScaleInterpolant = Z1e.l3;
    this._weightInterpolant = Z1e.l3;
    this.loop = THREE.LoopRepeat;
    this._loopCount = -1;
    this._startTime = Z1e.l3;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = Z1e.e4;
    this.enabled = Z1e.n3;
    this.clampWhenFinished = Z1e.e4;
    this.zeroSlopeAtStart = Z1e.n3;
    this.zeroSlopeAtEnd = Z1e.n3;
};
THREE.AnimationMixer._Action.prototype = {
    constructor: THREE.AnimationMixer._Action, play: function () {
        this._mixer._activateAction(this);
        return this;
    }, stop: function () {
        this._mixer._deactivateAction(this);
        return this.reset();
    }, reset: function () {
        this.paused = Z1e.e4;
        this.enabled = Z1e.n3;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = Z1e.l3;
        return this.stopFading().stopWarping();
    }, isRunning: function () {
        var d = this._startTime;
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === Z1e.l3 && this._mixer._isActiveAction(this);
    }, isScheduled: function () {
        return this._mixer._isActiveAction(this);
    }, startAt: function (d) {
        this._startTime = d;
        return this;
    }, setLoop: function (d, e) {
        this.loop = d;
        this.repetitions = e;
        return this;
    }, setEffectiveWeight: function (d) {
        this.weight = d;
        this._effectiveWeight = this.enabled ? d : 0;
        return this.stopFading();
    }, getEffectiveWeight: function () {
        return this._effectiveWeight;
    }, fadeIn: function (d) {
        return this._scheduleFading(d, 0, 1);
    }, fadeOut: function (d) {
        return this._scheduleFading(d, 1, 0);
    }, crossFadeFrom: function (d, e, f) {
        var i = this._mixer;
        d.fadeOut(e);
        this.fadeIn(e);
        if (f) {
            var j = this._clip.duration, k = d._clip.duration, m = k / j, n = j / k;
            d.warp(Z1e.d4, m, e);
            this.warp(n, Z1e.d4, e);
        }
        return this;
    }, crossFadeTo: function (d, e, f) {
        return d.crossFadeFrom(this, e, f);
    }, stopFading: function () {
        var d = this._weightInterpolant;
        if (d !== Z1e.l3) {
            this._weightInterpolant = Z1e.l3;
            this._mixer._takeBackControlInterpolant(d);
        }
        return this;
    }, setEffectiveTimeScale: function (d) {
        this.timeScale = d;
        this._effectiveTimeScale = this.paused ? 0 : d;
        return this.stopWarping();
    }, getEffectiveTimeScale: function () {
        return this._effectiveTimeScale;
    }, setDuration: function (d) {
        this.timeScale = this._clip.duration / d;
        return this.stopWarping();
    }, syncWith: function (d) {
        this.time = d.time;
        this.timeScale = d.timeScale;
        return this.stopWarping();
    }, halt: function (d) {
        return this.warp(this._currentTimeScale, 0, d);
    }, warp: function (d, e, f) {
        var i = this._mixer, j = i.time, k = this._timeScaleInterpolant, m = this.timeScale;
        if (k === Z1e.l3) {
            k = i._lendControlInterpolant(), this._timeScaleInterpolant = k;
        }
        var n = k.parameterPositions, u = k.sampleValues;
        n[0] = j;
        n[1] = j + f;
        u[0] = d / m;
        u[1] = e / m;
        return this;
    }, stopWarping: function () {
        var d = this._timeScaleInterpolant;
        if (d !== Z1e.l3) {
            this._timeScaleInterpolant = Z1e.l3;
            this._mixer._takeBackControlInterpolant(d);
        }
        return this;
    }, getMixer: function () {
        return this._mixer;
    }, getClip: function () {
        return this._clip;
    }, getRoot: function () {
        return this._localRoot || this._mixer._root;
    }, _update: function (d, e, f, i) {
        var j = this._startTime;
        if (j !== Z1e.l3) {
            var k = (d - j) * f;
            if (k < 0 || f === 0) {
                return;
            }
            this._startTime = Z1e.l3;
            e = f * k;
        }
        e *= this._updateTimeScale(d);
        var m = this._updateTime(e), n = this._updateWeight(d);
        if (n > 0) {
            var u = this._interpolants, v = this._propertyBindings;
            for (var B = 0, C = u.length; B !== C; ++B) {
                u[B].evaluate(m);
                v[B].accumulate(i, n);
            }
        }
    }, _updateWeight: function (d) {
        var e = 0;
        if (this.enabled) {
            e = this.weight;
            var f = this._weightInterpolant;
            if (f !== Z1e.l3) {
                var i = f.evaluate(d)[0];
                e *= i;
                if (d > f.parameterPositions[1]) {
                    this.stopFading();
                    if (i === 0) {
                        this.enabled = Z1e.e4;
                    }
                }
            }
        }
        this._effectiveWeight = e;
        return e;
    }, _updateTimeScale: function (d) {
        var e = 0;
        if (!this.paused) {
            e = this.timeScale;
            var f = this._timeScaleInterpolant;
            if (f !== Z1e.l3) {
                var i = f.evaluate(d)[0];
                e *= i;
                if (d > f.parameterPositions[1]) {
                    this.stopWarping();
                    if (e === 0) {
                        this.pause = Z1e.n3;
                    } else {
                        this.timeScale = e;
                    }
                }
            }
        }
        this._effectiveTimeScale = e;
        return e;
    }, _updateTime: function (d) {
        var e = this.time + d;
        if (d === 0)return e;
        var f = this._clip.duration, i = this.loop, j = this._loopCount, k = Z1e.e4;
        switch (i) {
            case THREE.LoopOnce:
                if (j === -1) {
                    this.loopCount = 0;
                    this._setEndings(Z1e.n3, Z1e.n3, Z1e.e4);
                }
                if (e >= f) {
                    e = f;
                } else if (e < 0) {
                    e = 0;
                } else break;
                if (this.clampWhenFinished) this.pause = Z1e.n3; else this.enabled = Z1e.e4;
                this._mixer.dispatchEvent({type: 'finished', action: this, direction: d < 0 ? -1 : 1});
                break;
            case THREE.LoopPingPong:
                k = Z1e.n3;
            case THREE.LoopRepeat:
                if (j === -1) {
                    if (d > 0) {
                        j = 0;
                        this._setEndings(Z1e.n3, this.repetitions === 0, k);
                    } else {
                        this._setEndings(this.repetitions === 0, Z1e.n3, k);
                    }
                }
                if (e >= f || e < 0) {
                    var m = Math.floor(e / f);
                    e -= f * m;
                    j += Math.abs(m);
                    var n = this.repetitions - j;
                    if (n < 0) {
                        if (this.clampWhenFinished) this.paused = Z1e.n3; else this.enabled = Z1e.e4;
                        e = d > 0 ? f : 0;
                        this._mixer.dispatchEvent({type: 'finished', action: this, direction: d > 0 ? 1 : -1});
                        break;
                    } else if (n === 0) {
                        var u = d < 0;
                        this._setEndings(u, !u, k);
                    } else {
                        this._setEndings(Z1e.e4, Z1e.e4, k);
                    }
                    this._loopCount = j;
                    this._mixer.dispatchEvent({type: 'loop', action: this, loopDelta: m});
                }
                if (i === THREE.LoopPingPong && (j & 1) === 1) {
                    this.time = e;
                    return f - e;
                }
                break;
        }
        this.time = e;
        return e;
    }, _setEndings: function (d, e, f) {
        var i = this._interpolantSettings;
        if (f) {
            i.endingStart = THREE.ZeroSlopeEnding;
            i.endingEnd = THREE.ZeroSlopeEnding;
        } else {
            if (d) {
                i.endingStart = this.zeroSlopeAtStart ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
            } else {
                i.endingStart = THREE.WrapAroundEnding;
            }
            if (e) {
                i.endingEnd = this.zeroSlopeAtEnd ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
            } else {
                i.endingEnd = THREE.WrapAroundEnding;
            }
        }
    }, _scheduleFading: function (d, e, f) {
        var i = this._mixer, j = i.time, k = this._weightInterpolant;
        if (k === Z1e.l3) {
            k = i._lendControlInterpolant(), this._weightInterpolant = k;
        }
        var m = k.parameterPositions, n = k.sampleValues;
        m[0] = j;
        n[0] = e;
        m[1] = j + d;
        n[1] = f;
        return this;
    }
};
Object.assign(THREE.AnimationMixer.prototype, {
    _bindAction: function (d, e) {
        var f = d._localRoot || this._root, i = d._clip.tracks, j = i.length, k = d._propertyBindings,
            m = d._interpolants, n = f.uuid, u = this._bindingsByRootAndName, v = u[n];
        if (v === undefined) {
            v = {};
            u[n] = v;
        }
        for (var B = 0; B !== j; ++B) {
            var C = i[B], G = C.name, L = v[G];
            if (L !== undefined) {
                k[B] = L;
            } else {
                L = k[B];
                if (L !== undefined) {
                    if (L._cacheIndex === Z1e.l3) {
                        ++L.referenceCount;
                        this._addInactiveBinding(L, n, G);
                    }
                    continue;
                }
                var N = e && e._propertyBindings[B].binding.parsedPath;
                L = new THREE.PropertyMixer(THREE.PropertyBinding.create(f, G, N), C.ValueTypeName, C.getValueSize());
                ++L.referenceCount;
                this._addInactiveBinding(L, n, G);
                k[B] = L;
            }
            m[B].resultBuffer = L.buffer;
        }
    }, _activateAction: function (d) {
        if (!this._isActiveAction(d)) {
            if (d._cacheIndex === Z1e.l3) {
                var e = (d._localRoot || this._root).uuid, f = d._clip.name, i = this._actionsByClip[f];
                this._bindAction(d, i && i.knownActions[0]);
                this._addInactiveAction(d, f, e);
            }
            var j = d._propertyBindings;
            for (var k = 0, m = j.length; k !== m; ++k) {
                var n = j[k];
                if (n.useCount++ === 0) {
                    this._lendBinding(n);
                    n.saveOriginalState();
                }
            }
            this._lendAction(d);
        }
    }, _deactivateAction: function (d) {
        if (this._isActiveAction(d)) {
            var e = d._propertyBindings;
            for (var f = 0, i = e.length; f !== i; ++f) {
                var j = e[f];
                if (--j.useCount === 0) {
                    j.restoreOriginalState();
                    this._takeBackBinding(j);
                }
            }
            this._takeBackAction(d);
        }
    }, _initMemoryManager: function () {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        var d = this;
        this.stats = {
            actions: {
                get total() {
                    return d._actions.length;
                }, get inUse() {
                    return d._nActiveActions;
                }
            }, bindings: {
                get total() {
                    return d._bindings.length;
                }, get inUse() {
                    return d._nActiveBindings;
                }
            }, controlInterpolants: {
                get total() {
                    return d._controlInterpolants.length;
                }, get inUse() {
                    return d._nActiveControlInterpolants;
                }
            }
        };
    }, _isActiveAction: function (d) {
        var e = d._cacheIndex;
        return e !== Z1e.l3 && e < this._nActiveActions;
    }, _addInactiveAction: function (d, e, f) {
        var i = this._actions, j = this._actionsByClip, k = j[e];
        if (k === undefined) {
            k = {knownActions: [d], actionByRoot: {}};
            d._byClipCacheIndex = 0;
            j[e] = k;
        } else {
            var m = k.knownActions;
            d._byClipCacheIndex = m.length;
            m.push(d);
        }
        d._cacheIndex = i.length;
        i.push(d);
        k.actionByRoot[f] = d;
    }, _removeInactiveAction: function (d) {
        var e = this._actions, f = e[e.length - 1], i = d._cacheIndex;
        f._cacheIndex = i;
        e[i] = f;
        e.pop();
        d._cacheIndex = Z1e.l3;
        var j = d._clip.name, k = this._actionsByClip, m = k[j], n = m.knownActions, u = n[n.length - 1],
            v = d._byClipCacheIndex;
        u._byClipCacheIndex = v;
        n[v] = u;
        n.pop();
        d._byClipCacheIndex = Z1e.l3;
        var B = m.actionByRoot, C = (e._localRoot || this._root).uuid;
        delete  B[C];
        if (n.length === 0) {
            delete  k[j];
        }
        this._removeInactiveBindingsForAction(d);
    }, _removeInactiveBindingsForAction: function (d) {
        var e = d._propertyBindings;
        for (var f = 0, i = e.length; f !== i; ++f) {
            var j = e[f];
            if (--j.referenceCount === 0) {
                this._removeInactiveBinding(j);
            }
        }
    }, _lendAction: function (d) {
        var e = this._actions, f = d._cacheIndex, i = this._nActiveActions++, j = e[i];
        d._cacheIndex = i;
        e[i] = d;
        j._cacheIndex = f;
        e[f] = j;
    }, _takeBackAction: function (d) {
        var e = this._actions, f = d._cacheIndex, i = --this._nActiveActions, j = e[i];
        d._cacheIndex = i;
        e[i] = d;
        j._cacheIndex = f;
        e[f] = j;
    }, _addInactiveBinding: function (d, e, f) {
        var i = this._bindingsByRootAndName, j = i[e], k = this._bindings;
        if (j === undefined) {
            j = {};
            i[e] = j;
        }
        j[f] = d;
        d._cacheIndex = k.length;
        k.push(d);
    }, _removeInactiveBinding: function (d) {
        var e = this._bindings, f = d.binding, i = f.rootNode.uuid, j = f.path, k = this._bindingsByRootAndName,
            m = k[i], n = e[e.length - 1], u = d._cacheIndex;
        n._cacheIndex = u;
        e[u] = n;
        e.pop();
        delete  m[j];
        remove_empty_map:{
            for (var v in m)break remove_empty_map;
            delete  k[i];
        }
    }, _lendBinding: function (d) {
        var e = this._bindings, f = d._cacheIndex, i = this._nActiveBindings++, j = e[i];
        d._cacheIndex = i;
        e[i] = d;
        j._cacheIndex = f;
        e[f] = j;
    }, _takeBackBinding: function (d) {
        var e = this._bindings, f = d._cacheIndex, i = --this._nActiveBindings, j = e[i];
        d._cacheIndex = i;
        e[i] = d;
        j._cacheIndex = f;
        e[f] = j;
    }, _lendControlInterpolant: function () {
        var d = this._controlInterpolants, e = this._nActiveControlInterpolants++, f = d[e];
        if (f === undefined) {
            f = new THREE.LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            f.__cacheIndex = e;
            d[e] = f;
        }
        return f;
    }, _takeBackControlInterpolant: function (d) {
        var e = this._controlInterpolants, f = d.__cacheIndex, i = --this._nActiveControlInterpolants, j = e[i];
        d.__cacheIndex = i;
        e[i] = d;
        j.__cacheIndex = f;
        e[f] = j;
    }, _controlInterpolantsResultBuffer: new Float32Array(1)
});
THREE.AnimationObjectGroup = function (d) {
    this.uuid = THREE.Math.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    var e = {};
    this._indicesByUUID = e;
    for (var f = 0, i = arguments.length; f !== i; ++f) {
        e[arguments[f].uuid] = f;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    var j = this;
    this.stats = {
        objects: {
            get total() {
                return j._objects.length;
            }, get inUse() {
                return this.total - j.nCachedObjects_;
            }
        }, get bindingsPerObject() {
            return j._bindings.length;
        }
    };
};
THREE.AnimationObjectGroup.prototype = {
    constructor: THREE.AnimationObjectGroup, add: function (d) {
        var e = this._objects, f = e.length, i = this.nCachedObjects_, j = this._indicesByUUID, k = this._paths,
            m = this._parsedPaths, n = this._bindings, u = n.length;
        for (var v = 0, B = arguments.length; v !== B; ++v) {
            var C = arguments[v], G = C.uuid, L = j[G];
            if (L === undefined) {
                L = f++;
                j[G] = L;
                e.push(C);
                for (var N = 0, T = u; N !== T; ++N) {
                    n[N].push(new THREE.PropertyBinding(C, k[N], m[N]));
                }
            } else if (L < i) {
                var S = e[L], b0 = --i, h0 = e[b0];
                j[h0.uuid] = L;
                e[L] = h0;
                j[G] = b0;
                e[b0] = C;
                for (var N = 0, T = u; N !== T; ++N) {
                    var f0 = n[N], i0 = f0[b0], s0 = f0[L];
                    f0[L] = i0;
                    if (s0 === undefined) {
                        s0 = new THREE.PropertyBinding(C, k[N], m[N]);
                    }
                    f0[b0] = s0;
                }
            } else if (e[L] !== S) {
                console.error("Different objects with the same UUID " + "detected. Clean the caches or recreate your " + "infrastructure when reloading scenes...");
            }
        }
        this.nCachedObjects_ = i;
    }, remove: function (d) {
        var e = this._objects, f = e.length, i = this.nCachedObjects_, j = this._indicesByUUID, k = this._bindings,
            m = k.length;
        for (var n = 0, u = arguments.length; n !== u; ++n) {
            var v = arguments[n], B = v.uuid, C = j[B];
            if (C !== undefined && C >= i) {
                var G = i++, L = e[G];
                j[L.uuid] = C;
                e[C] = L;
                j[B] = G;
                e[G] = v;
                for (var N = 0, T = m; N !== T; ++N) {
                    var S = k[N], b0 = S[G], h0 = S[C];
                    S[C] = b0;
                    S[G] = h0;
                }
            }
        }
        this.nCachedObjects_ = i;
    }, uncache: function (d) {
        var e = this._objects, f = e.length, i = this.nCachedObjects_, j = this._indicesByUUID, k = this._bindings,
            m = k.length;
        for (var n = 0, u = arguments.length; n !== u; ++n) {
            var v = arguments[n], B = v.uuid, C = j[B];
            if (C !== undefined) {
                delete  j[B];
                if (C < i) {
                    var G = --i, L = e[G], N = --f, T = e[N];
                    j[L.uuid] = C;
                    e[C] = L;
                    j[T.uuid] = G;
                    e[G] = T;
                    e.pop();
                    for (var S = 0, b0 = m; S !== b0; ++S) {
                        var h0 = k[S], f0 = h0[G], i0 = h0[N];
                        h0[C] = f0;
                        h0[G] = i0;
                        h0.pop();
                    }
                } else {
                    var N = --f, T = e[N];
                    j[T.uuid] = C;
                    e[C] = T;
                    e.pop();
                    for (var S = 0, b0 = m; S !== b0; ++S) {
                        var h0 = k[S];
                        h0[C] = h0[N];
                        h0.pop();
                    }
                }
            }
        }
        this.nCachedObjects_ = i;
    }, subscribe_: function (d, e) {
        var f = this._bindingsIndicesByPath, i = f[d], j = this._bindings;
        if (i !== undefined)return j[i];
        var k = this._paths, m = this._parsedPaths, n = this._objects, u = n.length, v = this.nCachedObjects_,
            B = new Array(u);
        i = j.length;
        f[d] = i;
        k.push(d);
        m.push(e);
        j.push(B);
        for (var C = v, G = n.length; C !== G; ++C) {
            var L = n[C];
            B[C] = new THREE.PropertyBinding(L, d, e);
        }
        return B;
    }, unsubscribe_: function (d) {
        var e = this._bindingsIndicesByPath, f = e[d];
        if (f !== undefined) {
            var i = this._paths, j = this._parsedPaths, k = this._bindings, m = k.length - 1, n = k[m], u = d[m];
            e[u] = f;
            k[f] = n;
            k.pop();
            j[f] = j[m];
            j.pop();
            i[f] = i[m];
            i.pop();
        }
    }
};
THREE.AnimationUtils = {
    arraySlice: function (d, e, f) {
        if (THREE.AnimationUtils.isTypedArray(d)) {
            return new d.constructor(d.subarray(e, f));
        }
        return d.slice(e, f);
    }, convertArray: function (d, e, f) {
        if (!d || !f && d.constructor === e)return d;
        if (typeof e.BYTES_PER_ELEMENT === Z1e.H3) {
            return new e(d);
        }
        return Array.prototype.slice.call(d);
    }, isTypedArray: function (d) {
        return ArrayBuffer.isView(d) && !(d instanceof DataView);
    }, getKeyframeOrder: function (f) {
        function i(d, e) {
            return f[d] - f[e];
        }
        var j = f.length, k = new Array(j);
        for (var m = 0; m !== j; ++m)k[m] = m;
        k.sort(i);
        return k;
    }, sortedArray: function (d, e, f) {
        var i = d.length, j = new d.constructor(i);
        for (var k = 0, m = 0; m !== i; ++k) {
            var n = f[k] * e;
            for (var u = 0; u !== e; ++u) {
                j[m++] = d[n + u];
            }
        }
        return j;
    }, flattenJSON: function (d, e, f, i) {
        var j = 1, k = d[0];
        while (k !== undefined && k[i] === undefined) {
            k = d[j++];
        }
        if (k === undefined)return;
        var m = k[i];
        if (m === undefined)return;
        if (Array.isArray(m)) {
            do {
                m = k[i];
                if (m !== undefined) {
                    e.push(k.time);
                    f.push.apply(f, m);
                }
                k = d[j++];
            } while (k !== undefined);
        } else if (m.toArray !== undefined) {
            do {
                m = k[i];
                if (m !== undefined) {
                    e.push(k.time);
                    m.toArray(f, f.length);
                }
                k = d[j++];
            } while (k !== undefined);
        } else {
            do {
                m = k[i];
                if (m !== undefined) {
                    e.push(k.time);
                    f.push(m);
                }
                k = d[j++];
            } while (k !== undefined);
        }
    }
};
THREE.KeyframeTrack = function (d, e, f, i) {
    if (d === undefined)throw  new Error("track name is undefined");
    if (e === undefined || e.length === 0) {
        throw  new Error("no keyframes in track named " + d);
    }
    this.name = d;
    this.times = THREE.AnimationUtils.convertArray(e, this.TimeBufferType);
    this.values = THREE.AnimationUtils.convertArray(f, this.ValueBufferType);
    this.setInterpolation(i || this.DefaultInterpolation);
    this.validate();
    this.optimize();
};
THREE.KeyframeTrack.prototype = {
    constructor: THREE.KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: THREE.InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function (d) {
        return new THREE.DiscreteInterpolant(this.times, this.values, this.getValueSize(), d);
    },
    InterpolantFactoryMethodLinear: function (d) {
        return new THREE.LinearInterpolant(this.times, this.values, this.getValueSize(), d);
    },
    InterpolantFactoryMethodSmooth: function (d) {
        return new THREE.CubicInterpolant(this.times, this.values, this.getValueSize(), d);
    },
    setInterpolation: function (d) {
        var e = undefined;
        switch (d) {
            case THREE.InterpolateDiscrete:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case THREE.InterpolateLinear:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case THREE.InterpolateSmooth:
                e = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (e === undefined) {
            var f = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === undefined) {
                if (d !== this.DefaultInterpolation) {
                    this.setInterpolation(this.DefaultInterpolation);
                } else {
                    throw  new Error(f);
                }
            }
            console.warn(f);
            return;
        }
        this.createInterpolant = e;
    },
    getInterpolation: function () {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return THREE.InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return THREE.InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return THREE.InterpolateSmooth;
        }
    },
    getValueSize: function () {
        return this.values.length / this.times.length;
    },
    shift: function (d) {
        if (d !== Z1e.l1) {
            var e = this.times;
            for (var f = 0, i = e.length; f !== i; ++f) {
                e[f] += d;
            }
        }
        return this;
    },
    scale: function (d) {
        if (d !== Z1e.d4) {
            var e = this.times;
            for (var f = 0, i = e.length; f !== i; ++f) {
                e[f] *= d;
            }
        }
        return this;
    },
    trim: function (d, e) {
        var f = this.times, i = f.length, j = 0, k = i - 1;
        while (j !== i && f[j] < d)++j;
        while (k !== -1 && f[k] > e)--k;
        ++k;
        if (j !== 0 || k !== i) {
            if (j >= k) k = Math.max(k, 1), j = k - 1;
            var m = this.getValueSize();
            this.times = THREE.AnimationUtils.arraySlice(f, j, k);
            this.values = THREE.AnimationUtils.arraySlice(this.values, j * m, k * m);
        }
        return this;
    },
    validate: function () {
        var d = Z1e.n3, e = this.getValueSize();
        if (e - Math.floor(e) !== 0) {
            console.error("invalid value size in track", this);
            d = Z1e.e4;
        }
        var f = this.times, i = this.values, j = f.length;
        if (j === 0) {
            console.error("track is empty", this);
            d = Z1e.e4;
        }
        var k = Z1e.l3;
        for (var m = 0; m !== j; m++) {
            var n = f[m];
            if (typeof n === Z1e.H3 && isNaN(n)) {
                console.error("time is not a valid number", this, m, n);
                d = Z1e.e4;
                break;
            }
            if (k !== Z1e.l3 && k > n) {
                console.error("out of order keys", this, m, n, k);
                d = Z1e.e4;
                break;
            }
            k = n;
        }
        if (i !== undefined) {
            if (THREE.AnimationUtils.isTypedArray(i)) {
                for (var m = 0, u = i.length; m !== u; ++m) {
                    var v = i[m];
                    if (isNaN(v)) {
                        console.error("value is not a valid number", this, m, v);
                        d = Z1e.e4;
                        break;
                    }
                }
            }
        }
        return d;
    },
    optimize: function () {
        var d = this.times, e = this.values, f = this.getValueSize(), i = 1;
        for (var j = 1, k = d.length - 1; j <= k; ++j) {
            var m = Z1e.e4, n = d[j], u = d[j + 1];
            if (n !== u && (j !== 1 || n !== n[0])) {
                var v = j * f, B = v - f, C = v + f;
                for (var G = 0; G !== f; ++G) {
                    var L = e[v + G];
                    if (L !== e[B + G] || L !== e[C + G]) {
                        m = Z1e.n3;
                        break;
                    }
                }
            }
            if (m) {
                if (j !== i) {
                    d[i] = d[j];
                    var N = j * f, T = i * f;
                    for (var G = 0; G !== f; ++G) {
                        e[T + G] = e[N + G];
                    }
                }
                ++i;
            }
        }
        if (i !== d.length) {
            this.times = THREE.AnimationUtils.arraySlice(d, 0, i);
            this.values = THREE.AnimationUtils.arraySlice(e, 0, i * f);
        }
        return this;
    }
};
Object.assign(THREE.KeyframeTrack, {
    parse: function (d) {
        if (d.type === undefined) {
            throw  new Error("track type undefined, can not parse");
        }
        var e = THREE.KeyframeTrack._getTrackTypeForValueTypeName(d.type);
        if (d.times === undefined) {
            console.warn("legacy JSON format detected, converting");
            var f = [], i = [];
            THREE.AnimationUtils.flattenJSON(d.keys, f, i, 'value');
            d.times = f;
            d.values = i;
        }
        if (e.parse !== undefined) {
            return e.parse(d);
        } else {
            return new e(d.name, d.times, d.values, d.interpolation);
        }
    }, toJSON: function (d) {
        var e = d.constructor, f;
        if (e.toJSON !== undefined) {
            f = e.toJSON(d);
        } else {
            f = {
                'name': d.name,
                'times': THREE.AnimationUtils.convertArray(d.times, Array),
                'values': THREE.AnimationUtils.convertArray(d.values, Array)
            };
            var i = d.getInterpolation();
            if (i !== d.DefaultInterpolation) {
                f.interpolation = i;
            }
        }
        f.type = d.ValueTypeName;
        return f;
    }, _getTrackTypeForValueTypeName: function (d) {
        switch (d.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return THREE.NumberKeyframeTrack;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return THREE.VectorKeyframeTrack;
            case "color":
                return THREE.ColorKeyframeTrack;
            case "quaternion":
                return THREE.QuaternionKeyframeTrack;
            case "bool":
            case "boolean":
                return THREE.BooleanKeyframeTrack;
            case "string":
                return THREE.StringKeyframeTrack;
        }
        ;
        throw  new Error("Unsupported typeName: " + d);
    }
});
THREE.PropertyBinding = function (d, e, f) {
    this.path = e;
    this.parsedPath = f || THREE.PropertyBinding.parseTrackName(e);
    this.node = THREE.PropertyBinding.findNode(d, this.parsedPath.nodeName) || d;
    this.rootNode = d;
};
THREE.PropertyBinding.prototype = {
    constructor: THREE.PropertyBinding, getValue: function getValue_unbound(d, e) {
        this.bind();
        this.getValue(d, e);
    }, setValue: function getValue_unbound(d, e) {
        this.bind();
        this.setValue(d, e);
    }, bind: function () {
        var d = " but it wasn't found.", e = this.node, f = this.parsedPath, i = f.objectName, j = f.propertyName,
            k = f.propertyIndex;
        if (!e) {
            e = THREE.PropertyBinding.findNode(this.rootNode, f.nodeName) || this.rootNode;
            this.node = e;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!e) {
            console.error("  trying to update node for track: " + this.path + d);
            return;
        }
        if (i) {
            var m = f.objectIndex;
            switch (i) {
                case 'materials':
                    if (!e.material) {
                        console.error('  can not bind to material as node does not have a material', this);
                        return;
                    }
                    if (!e.material.materials) {
                        console.error('  can not bind to material.materials as node.material does not have a materials array', this);
                        return;
                    }
                    e = e.material.materials;
                    break;
                case 'bones':
                    if (!e.skeleton) {
                        console.error('  can not bind to bones as node does not have a skeleton', this);
                        return;
                    }
                    e = e.skeleton.bones;
                    for (var n = 0; n < e.length; n++) {
                        if (e[n].name === m) {
                            m = n;
                            break;
                        }
                    }
                    break;
                default:
                    if (e[i] === undefined) {
                        console.error('  can not bind to objectName of node, undefined', this);
                        return;
                    }
                    e = e[i];
            }
            if (m !== undefined) {
                if (e[m] === undefined) {
                    console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, e);
                    return;
                }
                e = e[m];
            }
        }
        var u = e[j];
        if (!u) {
            var v = f.nodeName;
            console.error("  trying to update property for track: " + v + '.' + j + d, e);
            return;
        }
        var B = this.Versioning.None;
        if (e.needsUpdate !== undefined) {
            B = this.Versioning.NeedsUpdate;
            this.targetObject = e;
        } else if (e.matrixWorldNeedsUpdate !== undefined) {
            B = this.Versioning.MatrixWorldNeedsUpdate;
            this.targetObject = e;
        }
        var C = this.BindingType.Direct;
        if (k !== undefined) {
            if (j === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
                    return;
                }
                if (!e.geometry.morphTargets) {
                    console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
                    return;
                }
                for (var n = 0; n < this.node.geometry.morphTargets.length; n++) {
                    if (e.geometry.morphTargets[n].name === k) {
                        k = n;
                        break;
                    }
                }
            }
            C = this.BindingType.ArrayElement;
            this.resolvedProperty = u;
            this.propertyIndex = k;
        } else if (u.fromArray !== undefined && u.toArray !== undefined) {
            C = this.BindingType.HasFromToArray;
            this.resolvedProperty = u;
        } else if (u.length !== undefined) {
            C = this.BindingType.EntireArray;
            this.resolvedProperty = u;
        } else {
            this.propertyName = j;
        }
        this.getValue = this.GetterByBindingType[C];
        this.setValue = this.SetterByBindingTypeAndVersioning[C][B];
    }, unbind: function () {
        this.node = Z1e.l3;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
};
Object.assign(THREE.PropertyBinding.prototype, {
    _getValue_unavailable: function () {
    },
    _setValue_unavailable: function () {
    },
    _getValue_unbound: THREE.PropertyBinding.prototype.getValue,
    _setValue_unbound: THREE.PropertyBinding.prototype.setValue,
    BindingType: {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3},
    Versioning: {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2},
    GetterByBindingType: [function getValue_direct(d, e) {
        d[e] = this.node[this.propertyName];
    }, function getValue_array(d, e) {
        var f = this.resolvedProperty;
        for (var i = 0, j = f.length; i !== j; ++i) {
            d[e++] = f[i];
        }
    }, function getValue_arrayElement(d, e) {
        d[e] = this.resolvedProperty[this.propertyIndex];
    }, function getValue_toArray(d, e) {
        this.resolvedProperty.toArray(d, e);
    }],
    SetterByBindingTypeAndVersioning: [[function setValue_direct(d, e) {
        this.node[this.propertyName] = d[e];
    }, function setValue_direct_setNeedsUpdate(d, e) {
        this.node[this.propertyName] = d[e];
        this.targetObject.needsUpdate = Z1e.n3;
    }, function setValue_direct_setMatrixWorldNeedsUpdate(d, e) {
        this.node[this.propertyName] = d[e];
        this.targetObject.matrixWorldNeedsUpdate = Z1e.n3;
    }], [function setValue_array(d, e) {
        var f = this.resolvedProperty;
        for (var i = 0, j = f.length; i !== j; ++i) {
            f[i] = d[e++];
        }
    }, function setValue_array_setNeedsUpdate(d, e) {
        var f = this.resolvedProperty;
        for (var i = 0, j = f.length; i !== j; ++i) {
            f[i] = d[e++];
        }
        this.targetObject.needsUpdate = Z1e.n3;
    }, function setValue_array_setMatrixWorldNeedsUpdate(d, e) {
        var f = this.resolvedProperty;
        for (var i = 0, j = f.length; i !== j; ++i) {
            f[i] = d[e++];
        }
        this.targetObject.matrixWorldNeedsUpdate = Z1e.n3;
    }], [function setValue_arrayElement(d, e) {
        this.resolvedProperty[this.propertyIndex] = d[e];
    }, function setValue_arrayElement_setNeedsUpdate(d, e) {
        this.resolvedProperty[this.propertyIndex] = d[e];
        this.targetObject.needsUpdate = Z1e.n3;
    }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(d, e) {
        this.resolvedProperty[this.propertyIndex] = d[e];
        this.targetObject.matrixWorldNeedsUpdate = Z1e.n3;
    }], [function setValue_fromArray(d, e) {
        this.resolvedProperty.fromArray(d, e);
    }, function setValue_fromArray_setNeedsUpdate(d, e) {
        this.resolvedProperty.fromArray(d, e);
        this.targetObject.needsUpdate = Z1e.n3;
    }, function setValue_fromArray_setMatrixWorldNeedsUpdate(d, e) {
        this.resolvedProperty.fromArray(d, e);
        this.targetObject.matrixWorldNeedsUpdate = Z1e.n3;
    }]]
});
THREE.PropertyBinding.Composite = function (d, e, f) {
    var i = f || THREE.PropertyBinding.parseTrackName(e);
    this._targetGroup = d;
    this._bindings = d.subscribe_(e, i);
};
THREE.PropertyBinding.Composite.prototype = {
    constructor: THREE.PropertyBinding.Composite, getValue: function (d, e) {
        this.bind();
        var f = this._targetGroup.nCachedObjects_, i = this._bindings[f];
        if (i !== undefined) i.getValue(d, e);
    }, setValue: function (d, e) {
        var f = this._bindings;
        for (var i = this._targetGroup.nCachedObjects_, j = f.length; i !== j; ++i) {
            f[i].setValue(d, e);
        }
    }, bind: function () {
        var d = this._bindings;
        for (var e = this._targetGroup.nCachedObjects_, f = d.length; e !== f; ++e) {
            d[e].bind();
        }
    }, unbind: function () {
        var d = this._bindings;
        for (var e = this._targetGroup.nCachedObjects_, f = d.length; e !== f; ++e) {
            d[e].unbind();
        }
    }
};
THREE.PropertyBinding.create = function (d, e, f) {
    if (!(d instanceof THREE.AnimationObjectGroup)) {
        return new THREE.PropertyBinding(d, e, f);
    } else {
        return new THREE.PropertyBinding.Composite(d, e, f);
    }
};
THREE.PropertyBinding.parseTrackName = function (d) {
    var e = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/,
        f = e.exec(d);
    if (!f) {
        throw  new Error("cannot parse trackName at all: " + d);
    }
    if (f.index === e.lastIndex) {
        e.lastIndex++;
    }
    var i = {nodeName: f[3], objectName: f[5], objectIndex: f[7], propertyName: f[9], propertyIndex: f[11]};
    if (i.propertyName === Z1e.l3 || i.propertyName.length === 0) {
        throw  new Error("can not parse propertyName from trackName: " + d);
    }
    return i;
};
THREE.PropertyBinding.findNode = function (j, k) {
    if (!k || k === "" || k === "root" || k === "." || k === -1 || k === j.name || k === j.uuid) {
        return j;
    }
    if (j.skeleton) {
        var m = function (d) {
            for (var e = 0; e < d.bones.length; e++) {
                var f = d.bones[e];
                if (f.name === k) {
                    return f;
                }
            }
            return Z1e.l3;
        }, n = m(j.skeleton);
        if (n) {
            return n;
        }
    }
    if (j.children) {
        var u = function (d) {
            for (var e = 0; e < d.length; e++) {
                var f = d[e];
                if (f.name === k || f.uuid === k) {
                    return f;
                }
                var i = u(f.children);
                if (i)return i;
            }
            return Z1e.l3;
        }, v = u(j.children);
        if (v) {
            return v;
        }
    }
    return Z1e.l3;
};
THREE.PropertyMixer = function (d, e, f) {
    this.binding = d;
    this.valueSize = f;
    var i = Float64Array, j;
    switch (e) {
        case 'quaternion':
            j = this._slerp;
            break;
        case Z1e.W1:
        case 'bool':
            i = Array, j = this._select;
            break;
        default:
            j = this._lerp;
    }
    this.buffer = new i(f * 4);
    this._mixBufferRegion = j;
    this.cumulativeWeight = 0;
    this.useCount = 0;
    this.referenceCount = 0;
};
THREE.PropertyMixer.prototype = {
    constructor: THREE.PropertyMixer, accumulate: function (d, e) {
        var f = this.buffer, i = this.valueSize, j = d * i + i, k = this.cumulativeWeight;
        if (k === 0) {
            for (var m = 0; m !== i; ++m) {
                f[j + m] = f[m];
            }
            k = e;
        } else {
            k += e;
            var n = e / k;
            this._mixBufferRegion(f, j, 0, n, i);
        }
        this.cumulativeWeight = k;
    }, apply: function (d) {
        var e = this.valueSize, f = this.buffer, i = d * e + e, j = this.cumulativeWeight, k = this.binding;
        this.cumulativeWeight = 0;
        if (j < 1) {
            var m = e * 3;
            this._mixBufferRegion(f, i, m, 1 - j, e);
        }
        for (var n = e, u = e + e; n !== u; ++n) {
            if (f[n] !== f[n + e]) {
                k.setValue(f, i);
                break;
            }
        }
    }, saveOriginalState: function () {
        var d = this.binding, e = this.buffer, f = this.valueSize, i = f * 3;
        d.getValue(e, i);
        for (var j = f, k = i; j !== k; ++j) {
            e[j] = e[i + (j % f)];
        }
        this.cumulativeWeight = 0;
    }, restoreOriginalState: function () {
        var d = this.valueSize * 3;
        this.binding.setValue(this.buffer, d);
    }, _select: function (d, e, f, i, j) {
        if (i >= Z1e.k1) {
            for (var k = 0; k !== j; ++k) {
                d[e + k] = d[f + k];
            }
        }
    }, _slerp: function (d, e, f, i, j) {
        THREE.Quaternion.slerpFlat(d, e, d, e, d, f, i);
    }, _lerp: function (d, e, f, i, j) {
        var k = 1 - i;
        for (var m = 0; m !== j; ++m) {
            var n = e + m;
            d[n] = d[n] * k + d[f + m] * i;
        }
    }
};
THREE.BooleanKeyframeTrack = function (d, e, f) {
    THREE.KeyframeTrack.call(this, d, e, f);
};
THREE.BooleanKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.BooleanKeyframeTrack,
    ValueTypeName: 'bool',
    ValueBufferType: Array,
    DefaultInterpolation: THREE.InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
THREE.ColorKeyframeTrack = function (d, e, f, i) {
    THREE.KeyframeTrack.call(this, d, e, f, i);
};
THREE.ColorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.ColorKeyframeTrack,
    ValueTypeName: Z1e.X1
});
THREE.NumberKeyframeTrack = function (d, e, f, i) {
    THREE.KeyframeTrack.call(this, d, e, f, i);
};
THREE.NumberKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.NumberKeyframeTrack,
    ValueTypeName: Z1e.H3,
});
THREE.QuaternionKeyframeTrack = function (d, e, f, i) {
    THREE.KeyframeTrack.call(this, d, e, f, i);
};
THREE.QuaternionKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.QuaternionKeyframeTrack,
    ValueTypeName: 'quaternion',
    DefaultInterpolation: THREE.InterpolateLinear,
    InterpolantFactoryMethodLinear: function (d) {
        return new THREE.QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), d);
    },
    InterpolantFactoryMethodSmooth: undefined
});
THREE.StringKeyframeTrack = function (d, e, f, i) {
    THREE.KeyframeTrack.call(this, d, e, f, i);
};
THREE.StringKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.StringKeyframeTrack,
    ValueTypeName: Z1e.W1,
    ValueBufferType: Array,
    DefaultInterpolation: THREE.InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
THREE.VectorKeyframeTrack = function (d, e, f, i) {
    THREE.KeyframeTrack.call(this, d, e, f, i);
};
THREE.VectorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.VectorKeyframeTrack,
    ValueTypeName: 'vector'
});
THREE.Audio = function (d) {
    THREE.Object3D.call(this);
    this.type = 'Audio';
    this.context = d.context;
    this.source = this.context.createBufferSource();
    this.source.onended = this.onEnded.bind(this);
    this.gain = this.context.createGain();
    this.gain.connect(d.getInput());
    this.autoplay = Z1e.e4;
    this.startTime = 0;
    this.playbackRate = 1;
    this.isPlaying = Z1e.e4;
    this.hasPlaybackControl = Z1e.n3;
    this.sourceType = 'empty';
    this.filter = Z1e.l3;
};
THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
THREE.Audio.prototype.constructor = THREE.Audio;
THREE.Audio.prototype.getOutput = function () {
    return this.gain;
};
THREE.Audio.prototype.setNodeSource = function (d) {
    this.hasPlaybackControl = Z1e.e4;
    this.sourceType = 'audioNode';
    this.source = d;
    this.connect();
    return this;
};
THREE.Audio.prototype.setBuffer = function (d) {
    var e = this;
    e.source.buffer = d;
    e.sourceType = 'buffer';
    if (e.autoplay) e.play();
    return this;
};
THREE.Audio.prototype.play = function () {
    if (this.isPlaying === Z1e.n3) {
        console.warn('THREE.Audio: Audio is already playing.');
        return;
    }
    if (this.hasPlaybackControl === Z1e.e4) {
        console.warn(Z1e.m4);
        return;
    }
    var d = this.context.createBufferSource();
    d.buffer = this.source.buffer;
    d.loop = this.source.loop;
    d.onended = this.source.onended;
    d.start(0, this.startTime);
    d.playbackRate.value = this.playbackRate;
    this.isPlaying = Z1e.n3;
    this.source = d;
    this.connect();
};
THREE.Audio.prototype.pause = function () {
    if (this.hasPlaybackControl === Z1e.e4) {
        console.warn(Z1e.m4);
        return;
    }
    this.source.stop();
    this.startTime = this.context.currentTime;
};
THREE.Audio.prototype.stop = function () {
    if (this.hasPlaybackControl === Z1e.e4) {
        console.warn(Z1e.m4);
        return;
    }
    this.source.stop();
    this.startTime = 0;
};
THREE.Audio.prototype.connect = function () {
    if (this.filter !== Z1e.l3) {
        this.source.connect(this.filter);
        this.filter.connect(this.getOutput());
    } else {
        this.source.connect(this.getOutput());
    }
};
THREE.Audio.prototype.disconnect = function () {
    if (this.filter !== Z1e.l3) {
        this.source.disconnect(this.filter);
        this.filter.disconnect(this.getOutput());
    } else {
        this.source.disconnect(this.getOutput());
    }
};
THREE.Audio.prototype.getFilter = function () {
    return this.filter;
};
THREE.Audio.prototype.setFilter = function (d) {
    if (d === undefined) d = Z1e.l3;
    if (this.isPlaying === Z1e.n3) {
        this.disconnect();
        this.filter = d;
        this.connect();
    } else {
        this.filter = d;
    }
};
THREE.Audio.prototype.setPlaybackRate = function (d) {
    if (this.hasPlaybackControl === Z1e.e4) {
        console.warn(Z1e.m4);
        return;
    }
    this.playbackRate = d;
    if (this.isPlaying === Z1e.n3) {
        this.source.playbackRate.value = this.playbackRate;
    }
};
THREE.Audio.prototype.getPlaybackRate = function () {
    return this.playbackRate;
};
THREE.Audio.prototype.onEnded = function () {
    this.isPlaying = Z1e.e4;
};
THREE.Audio.prototype.setLoop = function (d) {
    if (this.hasPlaybackControl === Z1e.e4) {
        console.warn(Z1e.m4);
        return;
    }
    this.source.loop = d;
};
THREE.Audio.prototype.getLoop = function () {
    if (this.hasPlaybackControl === Z1e.e4) {
        console.warn(Z1e.m4);
        return Z1e.e4;
    }
    return this.source.loop;
};
THREE.Audio.prototype.setVolume = function (d) {
    this.gain.gain.value = d;
};
THREE.Audio.prototype.getVolume = function () {
    return this.gain.gain.value;
};
THREE.AudioAnalyser = function (d, e) {
    this.analyser = d.context.createAnalyser();
    this.analyser.fftSize = e !== undefined ? e : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    d.getOutput().connect(this.analyser);
};
THREE.AudioAnalyser.prototype = {
    constructor: THREE.AudioAnalyser, getData: function () {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    }
};
Object.defineProperty(THREE, 'AudioContext', {
    get: (function () {
        var d;
        return function () {
            if (d === undefined) {
                d = new (window.AudioContext || window.webkitAudioContext)();
            }
            return d;
        };
    })()
});
THREE.PositionalAudio = function (d) {
    THREE.Audio.call(this, d);
    this.panner = this.context.createPanner();
    this.panner.connect(this.gain);
};
THREE.PositionalAudio.prototype = Object.create(THREE.Audio.prototype);
THREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;
THREE.PositionalAudio.prototype.getOutput = function () {
    return this.panner;
};
THREE.PositionalAudio.prototype.setRefDistance = function (d) {
    this.panner.refDistance = d;
};
THREE.PositionalAudio.prototype.getRefDistance = function () {
    return this.panner.refDistance;
};
THREE.PositionalAudio.prototype.setRolloffFactor = function (d) {
    this.panner.rolloffFactor = d;
};
THREE.PositionalAudio.prototype.getRolloffFactor = function () {
    return this.panner.rolloffFactor;
};
THREE.PositionalAudio.prototype.setDistanceModel = function (d) {
    this.panner.distanceModel = d;
};
THREE.PositionalAudio.prototype.getDistanceModel = function () {
    return this.panner.distanceModel;
};
THREE.PositionalAudio.prototype.setMaxDistance = function (d) {
    this.panner.maxDistance = d;
};
THREE.PositionalAudio.prototype.getMaxDistance = function () {
    return this.panner.maxDistance;
};
THREE.PositionalAudio.prototype.updateMatrixWorld = (function () {
    var e = new THREE.Vector3();
    return function f(d) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, d);
        e.setFromMatrixPosition(this.matrixWorld);
        this.panner.setPosition(e.x, e.y, e.z);
    };
})();
THREE.AudioListener = function () {
    THREE.Object3D.call(this);
    this.type = 'AudioListener';
    this.context = THREE.AudioContext;
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = Z1e.l3;
};
THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
THREE.AudioListener.prototype.constructor = THREE.AudioListener;
THREE.AudioListener.prototype.getInput = function () {
    return this.gain;
};
THREE.AudioListener.prototype.removeFilter = function () {
    if (this.filter !== Z1e.l3) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
        this.gain.connect(this.context.destination);
        this.filter = Z1e.l3;
    }
};
THREE.AudioListener.prototype.setFilter = function (d) {
    if (this.filter !== Z1e.l3) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
    } else {
        this.gain.disconnect(this.context.destination);
    }
    this.filter = d;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
};
THREE.AudioListener.prototype.getFilter = function () {
    return this.filter;
};
THREE.AudioListener.prototype.setMasterVolume = function (d) {
    this.gain.gain.value = d;
};
THREE.AudioListener.prototype.getMasterVolume = function () {
    return this.gain.gain.value;
};
THREE.AudioListener.prototype.updateMatrixWorld = (function () {
    var i = new THREE.Vector3(), j = new THREE.Quaternion(), k = new THREE.Vector3(), m = new THREE.Vector3();
    return function n(d) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, d);
        var e = this.context.listener, f = this.up;
        this.matrixWorld.decompose(i, j, k);
        m.set(0, 0, -1).applyQuaternion(j);
        e.setPosition(i.x, i.y, i.z);
        e.setOrientation(m.x, m.y, m.z, f.x, f.y, f.z);
    };
})();
THREE.Camera = function () {
    THREE.Object3D.call(this);
    this.type = 'Camera';
    this.matrixWorldInverse = new THREE.Matrix4();
    this.projectionMatrix = new THREE.Matrix4();
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.constructor = THREE.Camera;
THREE.Camera.prototype.getWorldDirection = function () {
    var f = new THREE.Quaternion();
    return function (d) {
        var e = d || new THREE.Vector3();
        this.getWorldQuaternion(f);
        return e.set(0, 0, -1).applyQuaternion(f);
    };
}();
THREE.Camera.prototype.lookAt = function () {
    var e = new THREE.Matrix4();
    return function (d) {
        e.lookAt(this.position, d, this.up);
        this.quaternion.setFromRotationMatrix(e);
    };
}();
THREE.Camera.prototype.clone = function () {
    return new this.constructor().copy(this);
};
THREE.Camera.prototype.copy = function (d) {
    THREE.Object3D.prototype.copy.call(this, d);
    this.matrixWorldInverse.copy(d.matrixWorldInverse);
    this.projectionMatrix.copy(d.projectionMatrix);
    return this;
};
THREE.CubeCamera = function (j, k, m) {
    THREE.Object3D.call(this);
    this.type = 'CubeCamera';
    var n = 90, u = 1, v = new THREE.PerspectiveCamera(n, u, j, k);
    v.up.set(0, -1, 0);
    v.lookAt(new THREE.Vector3(1, 0, 0));
    this.add(v);
    var B = new THREE.PerspectiveCamera(n, u, j, k);
    B.up.set(0, -1, 0);
    B.lookAt(new THREE.Vector3(-1, 0, 0));
    this.add(B);
    var C = new THREE.PerspectiveCamera(n, u, j, k);
    C.up.set(0, 0, 1);
    C.lookAt(new THREE.Vector3(0, 1, 0));
    this.add(C);
    var G = new THREE.PerspectiveCamera(n, u, j, k);
    G.up.set(0, 0, -1);
    G.lookAt(new THREE.Vector3(0, -1, 0));
    this.add(G);
    var L = new THREE.PerspectiveCamera(n, u, j, k);
    L.up.set(0, -1, 0);
    L.lookAt(new THREE.Vector3(0, 0, 1));
    this.add(L);
    var N = new THREE.PerspectiveCamera(n, u, j, k);
    N.up.set(0, -1, 0);
    N.lookAt(new THREE.Vector3(0, 0, -1));
    this.add(N);
    var T = {format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter};
    this.renderTarget = new THREE.WebGLRenderTargetCube(m, m, T);
    this.updateCubeMap = function (d, e) {
        if (this.parent === Z1e.l3) this.updateMatrixWorld();
        var f = this.renderTarget, i = f.texture.generateMipmaps;
        f.texture.generateMipmaps = Z1e.e4;
        f.activeCubeFace = 0;
        d.render(e, v, f);
        f.activeCubeFace = 1;
        d.render(e, B, f);
        f.activeCubeFace = 2;
        d.render(e, C, f);
        f.activeCubeFace = 3;
        d.render(e, G, f);
        f.activeCubeFace = 4;
        d.render(e, L, f);
        f.texture.generateMipmaps = i;
        f.activeCubeFace = 5;
        d.render(e, N, f);
        d.setRenderTarget(Z1e.l3);
    };
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
THREE.OrthographicCamera = function (d, e, f, i, j, k) {
    THREE.Camera.call(this);
    this.type = Z1e.H;
    this.zoom = 1;
    this.left = d;
    this.right = e;
    this.top = f;
    this.bottom = i;
    this.near = (j !== undefined) ? j : 0.1;
    this.far = (k !== undefined) ? k : 2000;
    this.updateProjectionMatrix();
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
    var d = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom),
        f = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    this.projectionMatrix.makeOrthographic(f - d, f + d, i + e, i - e, this.near, this.far);
};
THREE.OrthographicCamera.prototype.copy = function (d) {
    THREE.Camera.prototype.copy.call(this, d);
    this.left = d.left;
    this.right = d.right;
    this.top = d.top;
    this.bottom = d.bottom;
    this.near = d.near;
    this.far = d.far;
    this.zoom = d.zoom;
    return this;
};
THREE.OrthographicCamera.prototype.toJSON = function (d) {
    var e = THREE.Object3D.prototype.toJSON.call(this, d);
    e.object.zoom = this.zoom;
    e.object.left = this.left;
    e.object.right = this.right;
    e.object.top = this.top;
    e.object.bottom = this.bottom;
    e.object.near = this.near;
    e.object.far = this.far;
    return e;
};
THREE.PerspectiveCamera = function (d, e, f, i) {
    THREE.Camera.call(this);
    this.type = Z1e.e1;
    this.fov = d !== undefined ? d : 50;
    this.zoom = 1;
    this.near = f !== undefined ? f : 0.1;
    this.far = i !== undefined ? i : 2000;
    this.focus = 10;
    this.aspect = e !== undefined ? e : 1;
    this.view = Z1e.l3;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
THREE.PerspectiveCamera.prototype.setLens = function (d, e) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
    if (e !== undefined) this.filmGauge = e;
    this.setFocalLength(d);
};
THREE.PerspectiveCamera.prototype.setFocalLength = function (d) {
    var e = Z1e.k1 * this.getFilmHeight() / d;
    this.fov = THREE.Math.RAD2DEG * 2 * Math.atan(e);
    this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.getFocalLength = function () {
    var d = Math.tan(THREE.Math.DEG2RAD * Z1e.k1 * this.fov);
    return Z1e.k1 * this.getFilmHeight() / d;
};
THREE.PerspectiveCamera.prototype.getEffectiveFOV = function () {
    return THREE.Math.RAD2DEG * 2 * Math.atan(Math.tan(THREE.Math.DEG2RAD * Z1e.k1 * this.fov) / this.zoom);
};
THREE.PerspectiveCamera.prototype.getFilmWidth = function () {
    return this.filmGauge * Math.min(this.aspect, 1);
};
THREE.PerspectiveCamera.prototype.getFilmHeight = function () {
    return this.filmGauge / Math.max(this.aspect, 1);
};
THREE.PerspectiveCamera.prototype.setViewOffset = function (d, e, f, i, j, k) {
    this.aspect = d / e;
    this.view = {fullWidth: d, fullHeight: e, offsetX: f, offsetY: i, width: j, height: k};
    this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
    var d = this.near, e = d * Math.tan(THREE.Math.DEG2RAD * Z1e.k1 * this.fov) / this.zoom, f = 2 * e,
        i = this.aspect * f, j = -Z1e.k1 * i, k = this.view;
    if (k !== Z1e.l3) {
        var m = k.fullWidth, n = k.fullHeight;
        j += k.offsetX * i / m;
        e -= k.offsetY * f / n;
        i *= k.width / m;
        f *= k.height / n;
    }
    var u = this.filmOffset;
    if (u !== 0) j += d * u / this.getFilmWidth();
    this.projectionMatrix.makeFrustum(j, j + i, e - f, e, d, this.far);
};
THREE.PerspectiveCamera.prototype.copy = function (d) {
    THREE.Camera.prototype.copy.call(this, d);
    this.fov = d.fov;
    this.zoom = d.zoom;
    this.near = d.near;
    this.far = d.far;
    this.focus = d.focus;
    this.aspect = d.aspect;
    this.view = d.view === Z1e.l3 ? Z1e.l3 : Object.assign({}, d.view);
    this.filmGauge = d.filmGauge;
    this.filmOffset = d.filmOffset;
    return this;
};
THREE.PerspectiveCamera.prototype.toJSON = function (d) {
    var e = THREE.Object3D.prototype.toJSON.call(this, d);
    e.object.fov = this.fov;
    e.object.zoom = this.zoom;
    e.object.near = this.near;
    e.object.far = this.far;
    e.object.focus = this.focus;
    e.object.aspect = this.aspect;
    if (this.view !== Z1e.l3) e.object.view = Object.assign({}, this.view);
    e.object.filmGauge = this.filmGauge;
    e.object.filmOffset = this.filmOffset;
    return e;
};
THREE.StereoCamera = function () {
    this.type = 'StereoCamera';
    this.aspect = 1;
    this.cameraL = new THREE.PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = Z1e.e4;
    this.cameraR = new THREE.PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = Z1e.e4;
};
THREE.StereoCamera.prototype = {
    constructor: THREE.StereoCamera, update: (function () {
        var u, v, B, C, G, L = new THREE.Matrix4(), N = new THREE.Matrix4();
        return function T(d) {
            var e = u !== d.focus || v !== d.fov || B !== d.aspect * this.aspect || C !== d.near || G !== d.far;
            if (e) {
                u = d.focus;
                v = d.fov;
                B = d.aspect * this.aspect;
                C = d.near;
                G = d.far;
                var f = d.projectionMatrix.clone(), i = 0.064 / 2, j = i * C / u,
                    k = C * Math.tan(THREE.Math.DEG2RAD * v * Z1e.k1), m, n;
                N.elements[12] = -i;
                L.elements[12] = i;
                m = -k * B + j;
                n = k * B + j;
                f.elements[0] = 2 * C / (n - m);
                f.elements[8] = (n + m) / (n - m);
                this.cameraL.projectionMatrix.copy(f);
                m = -k * B - j;
                n = k * B - j;
                f.elements[0] = 2 * C / (n - m);
                f.elements[8] = (n + m) / (n - m);
                this.cameraR.projectionMatrix.copy(f);
            }
            this.cameraL.matrixWorld.copy(d.matrixWorld).multiply(N);
            this.cameraR.matrixWorld.copy(d.matrixWorld).multiply(L);
        };
    })()
};
THREE.Light = function (d, e) {
    THREE.Object3D.call(this);
    this.type = 'Light';
    this.color = new THREE.Color(d);
    this.intensity = e !== undefined ? e : 1;
    this.receiveShadow = undefined;
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.constructor = THREE.Light;
THREE.Light.prototype.copy = function (d) {
    THREE.Object3D.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.intensity = d.intensity;
    return this;
};
THREE.Light.prototype.toJSON = function (d) {
    var e = THREE.Object3D.prototype.toJSON.call(this, d);
    e.object.color = this.color.getHex();
    e.object.intensity = this.intensity;
    if (this.groundColor !== undefined) e.object.groundColor = this.groundColor.getHex();
    if (this.distance !== undefined) e.object.distance = this.distance;
    if (this.angle !== undefined) e.object.angle = this.angle;
    if (this.decay !== undefined) e.object.decay = this.decay;
    if (this.penumbra !== undefined) e.object.penumbra = this.penumbra;
    return e;
};
THREE.LightShadow = function (d) {
    this.camera = d;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new THREE.Vector2(512, 512);
    this.map = Z1e.l3;
    this.matrix = new THREE.Matrix4();
};
THREE.LightShadow.prototype = {
    constructor: THREE.LightShadow, copy: function (d) {
        this.camera = d.camera.clone();
        this.bias = d.bias;
        this.radius = d.radius;
        this.mapSize.copy(d.mapSize);
        return this;
    }, clone: function () {
        return new this.constructor().copy(this);
    }
};
THREE.AmbientLight = function (d, e) {
    THREE.Light.call(this, d, e);
    this.type = Z1e.I2;
    this.castShadow = undefined;
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
THREE.DirectionalLight = function (d, e) {
    THREE.Light.call(this, d, e);
    this.type = Z1e.o2;
    this.position.set(0, 1, 0);
    this.updateMatrix();
    this.target = new THREE.Object3D();
    this.shadow = new THREE.DirectionalLightShadow();
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
THREE.DirectionalLight.prototype.copy = function (d) {
    THREE.Light.prototype.copy.call(this, d);
    this.target = d.target.clone();
    this.shadow = d.shadow.clone();
    return this;
};
THREE.DirectionalLightShadow = function (d) {
    THREE.LightShadow.call(this, new THREE.OrthographicCamera(-5, 5, 5, -5, Z1e.k1, 500));
};
THREE.DirectionalLightShadow.prototype = Object.create(THREE.LightShadow.prototype);
THREE.DirectionalLightShadow.prototype.constructor = THREE.DirectionalLightShadow;
THREE.HemisphereLight = function (d, e, f) {
    THREE.Light.call(this, d, f);
    this.type = Z1e.Y1;
    this.castShadow = undefined;
    this.position.set(0, 1, 0);
    this.updateMatrix();
    this.groundColor = new THREE.Color(e);
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
THREE.HemisphereLight.prototype.copy = function (d) {
    THREE.Light.prototype.copy.call(this, d);
    this.groundColor.copy(d.groundColor);
    return this;
};
THREE.PointLight = function (d, e, f, i) {
    THREE.Light.call(this, d, e);
    this.type = Z1e.N0;
    this.distance = (f !== undefined) ? f : 0;
    this.decay = (i !== undefined) ? i : 1;
    this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, Z1e.k1, 500));
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.constructor = THREE.PointLight;
Object.defineProperty(THREE.PointLight.prototype, "power", {
    get: function () {
        return this.intensity * 4 * Math.PI;
    }, set: function (d) {
        this.intensity = d / (4 * Math.PI);
    }
});
THREE.PointLight.prototype.copy = function (d) {
    THREE.Light.prototype.copy.call(this, d);
    this.distance = d.distance;
    this.decay = d.decay;
    this.shadow = d.shadow.clone();
    return this;
};
THREE.SpotLight = function (d, e, f, i, j, k) {
    THREE.Light.call(this, d, e);
    this.type = Z1e.h3;
    this.position.set(0, 1, 0);
    this.updateMatrix();
    this.target = new THREE.Object3D();
    this.distance = (f !== undefined) ? f : 0;
    this.angle = (i !== undefined) ? i : Math.PI / 3;
    this.penumbra = (j !== undefined) ? j : 0;
    this.decay = (k !== undefined) ? k : 1;
    this.shadow = new THREE.SpotLightShadow();
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.constructor = THREE.SpotLight;
Object.defineProperty(THREE.SpotLight.prototype, "power", {
    get: function () {
        return this.intensity * Math.PI;
    }, set: function (d) {
        this.intensity = d / Math.PI;
    }
});
THREE.SpotLight.prototype.copy = function (d) {
    THREE.Light.prototype.copy.call(this, d);
    this.distance = d.distance;
    this.angle = d.angle;
    this.penumbra = d.penumbra;
    this.decay = d.decay;
    this.target = d.target.clone();
    this.shadow = d.shadow.clone();
    return this;
};
THREE.SpotLightShadow = function () {
    THREE.LightShadow.call(this, new THREE.PerspectiveCamera(50, 1, Z1e.k1, 500));
};
THREE.SpotLightShadow.prototype = Object.create(THREE.LightShadow.prototype);
THREE.SpotLightShadow.prototype.constructor = THREE.SpotLightShadow;
THREE.SpotLightShadow.prototype.update = function (d) {
    var e = THREE.Math.RAD2DEG * 2 * d.angle, f = this.mapSize.width / this.mapSize.height, i = d.distance || 500,
        j = this.camera;
    if (e !== j.fov || f !== j.aspect || i !== j.far) {
        j.fov = e;
        j.aspect = f;
        j.far = i;
        j.updateProjectionMatrix();
    }
};
THREE.AudioLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
};
THREE.AudioLoader.prototype = {
    constructor: THREE.AudioLoader, load: function (i, j, k, m) {
        var n = new THREE.XHRLoader(this.manager);
        n.setResponseType(Z1e.z3);
        n.load(i, function (e) {
            var f = THREE.AudioContext;
            f.decodeAudioData(e, function (d) {
                j(d);
            });
        }, k, m);
    }
};
THREE.Cache = {
    enabled: Z1e.e4, files: {}, add: function (d, e) {
        if (this.enabled === Z1e.e4)return;
        this.files[d] = e;
    }, get: function (d) {
        if (this.enabled === Z1e.e4)return;
        return this.files[d];
    }, remove: function (d) {
        delete  this.files[d];
    }, clear: function () {
        this.files = {};
    }
};
THREE.Loader = function () {
    this.onLoadStart = function () {
    };
    this.onLoadProgress = function () {
    };
    this.onLoadComplete = function () {
    };
};
THREE.Loader.prototype = {
    constructor: THREE.Loader, crossOrigin: undefined, extractUrlBase: function (d) {
        var e = d.split('/');
        if (e.length === 1)return './';
        e.pop();
        return e.join('/') + '/';
    }, initMaterials: function (d, e, f) {
        var i = [];
        for (var j = 0; j < d.length; ++j) {
            i[j] = this.createMaterial(d[j], e, f);
        }
        return i;
    }, createMaterial: (function () {
        var b0, h0, f0;
        return function (v, B, C) {
            if (b0 === undefined) b0 = new THREE.Color();
            if (h0 === undefined) h0 = new THREE.TextureLoader();
            if (f0 === undefined) f0 = new THREE.MaterialLoader();
            var G = {};
            function L(d, e, f, i, j) {
                var k = B + d, m = THREE.Loader.Handlers.get(k), n;
                if (m !== Z1e.l3) {
                    n = m.load(k);
                } else {
                    h0.setCrossOrigin(C);
                    n = h0.load(k);
                }
                if (e !== undefined) {
                    n.repeat.fromArray(e);
                    if (e[0] !== 1) n.wrapS = THREE.RepeatWrapping;
                    if (e[1] !== 1) n.wrapT = THREE.RepeatWrapping;
                }
                if (f !== undefined) {
                    n.offset.fromArray(f);
                }
                if (i !== undefined) {
                    if (i[0] === 'repeat') n.wrapS = THREE.RepeatWrapping;
                    if (i[0] === 'mirror') n.wrapS = THREE.MirroredRepeatWrapping;
                    if (i[1] === 'repeat') n.wrapT = THREE.RepeatWrapping;
                    if (i[1] === 'mirror') n.wrapT = THREE.MirroredRepeatWrapping;
                }
                if (j !== undefined) {
                    n.anisotropy = j;
                }
                var u = THREE.Math.generateUUID();
                G[u] = n;
                return u;
            }
            var N = {uuid: THREE.Math.generateUUID(), type: Z1e.u0};
            for (var T in v) {
                var S = v[T];
                switch (T) {
                    case 'DbgColor':
                    case 'DbgIndex':
                    case 'opticalDensity':
                    case 'illumination':
                        break;
                    case 'DbgName':
                        N.name = S;
                        break;
                    case 'blending':
                        N.blending = THREE[S];
                        break;
                    case 'colorAmbient':
                    case 'mapAmbient':
                        console.warn('THREE.Loader.createMaterial:', T, 'is no longer supported.');
                        break;
                    case 'colorDiffuse':
                        N.color = b0.fromArray(S).getHex();
                        break;
                    case 'colorSpecular':
                        N.specular = b0.fromArray(S).getHex();
                        break;
                    case 'colorEmissive':
                        N.emissive = b0.fromArray(S).getHex();
                        break;
                    case 'specularCoef':
                        N.shininess = S;
                        break;
                    case 'shading':
                        if (S.toLowerCase() === 'basic') N.type = Z1e.W3;
                        if (S.toLowerCase() === 'phong') N.type = Z1e.C3;
                        break;
                    case 'mapDiffuse':
                        N.map = L(S, v.mapDiffuseRepeat, v.mapDiffuseOffset, v.mapDiffuseWrap, v.mapDiffuseAnisotropy);
                        break;
                    case 'mapDiffuseRepeat':
                    case 'mapDiffuseOffset':
                    case 'mapDiffuseWrap':
                    case 'mapDiffuseAnisotropy':
                        break;
                    case 'mapLight':
                        N.lightMap = L(S, v.mapLightRepeat, v.mapLightOffset, v.mapLightWrap, v.mapLightAnisotropy);
                        break;
                    case 'mapLightRepeat':
                    case 'mapLightOffset':
                    case 'mapLightWrap':
                    case 'mapLightAnisotropy':
                        break;
                    case 'mapAO':
                        N.aoMap = L(S, v.mapAORepeat, v.mapAOOffset, v.mapAOWrap, v.mapAOAnisotropy);
                        break;
                    case 'mapAORepeat':
                    case 'mapAOOffset':
                    case 'mapAOWrap':
                    case 'mapAOAnisotropy':
                        break;
                    case 'mapBump':
                        N.bumpMap = L(S, v.mapBumpRepeat, v.mapBumpOffset, v.mapBumpWrap, v.mapBumpAnisotropy);
                        break;
                    case 'mapBumpScale':
                        N.bumpScale = S;
                        break;
                    case 'mapBumpRepeat':
                    case 'mapBumpOffset':
                    case 'mapBumpWrap':
                    case 'mapBumpAnisotropy':
                        break;
                    case 'mapNormal':
                        N.normalMap = L(S, v.mapNormalRepeat, v.mapNormalOffset, v.mapNormalWrap, v.mapNormalAnisotropy);
                        break;
                    case 'mapNormalFactor':
                        N.normalScale = [S, S];
                        break;
                    case 'mapNormalRepeat':
                    case 'mapNormalOffset':
                    case 'mapNormalWrap':
                    case 'mapNormalAnisotropy':
                        break;
                    case 'mapSpecular':
                        N.specularMap = L(S, v.mapSpecularRepeat, v.mapSpecularOffset, v.mapSpecularWrap, v.mapSpecularAnisotropy);
                        break;
                    case 'mapSpecularRepeat':
                    case 'mapSpecularOffset':
                    case 'mapSpecularWrap':
                    case 'mapSpecularAnisotropy':
                        break;
                    case 'mapAlpha':
                        N.alphaMap = L(S, v.mapAlphaRepeat, v.mapAlphaOffset, v.mapAlphaWrap, v.mapAlphaAnisotropy);
                        break;
                    case 'mapAlphaRepeat':
                    case 'mapAlphaOffset':
                    case 'mapAlphaWrap':
                    case 'mapAlphaAnisotropy':
                        break;
                    case 'flipSided':
                        N.side = THREE.BackSide;
                        break;
                    case 'doubleSided':
                        N.side = THREE.DoubleSide;
                        break;
                    case 'transparency':
                        console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
                        N.opacity = S;
                        break;
                    case 'depthTest':
                    case 'depthWrite':
                    case 'colorWrite':
                    case 'opacity':
                    case 'reflectivity':
                    case 'transparent':
                    case 'visible':
                    case 'wireframe':
                        N[T] = S;
                        break;
                    case 'vertexColors':
                        if (S === Z1e.n3) N.vertexColors = THREE.VertexColors;
                        if (S === 'face') N.vertexColors = THREE.FaceColors;
                        break;
                    default:
                        console.error('THREE.Loader.createMaterial: Unsupported', T, S);
                        break;
                }
            }
            if (N.type === Z1e.W3) delete  N.emissive;
            if (N.type !== Z1e.C3) delete  N.specular;
            if (N.opacity < 1) N.transparent = Z1e.n3;
            f0.setTextures(G);
            return f0.parse(N);
        };
    })()
};
THREE.Loader.Handlers = {
    handlers: [], add: function (d, e) {
        this.handlers.push(d, e);
    }, get: function (d) {
        var e = this.handlers;
        for (var f = 0, i = e.length; f < i; f += 2) {
            var j = e[f], k = e[f + 1];
            if (j.test(d)) {
                return k;
            }
        }
        return Z1e.l3;
    }
};
THREE.XHRLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
};
THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader, load: function (f, i, j, k) {
        if (this.path !== undefined) f = this.path + f;
        var m = this, n = THREE.Cache.get(f);
        if (n !== undefined) {
            if (i) {
                setTimeout(function () {
                    i(n);
                }, 0);
            }
            return n;
        }
        var u = new XMLHttpRequest();
        u.overrideMimeType('text/plain');
        u.open('GET', f, Z1e.n3);
        u.addEventListener('load', function (d) {
            var e = d.target.response;
            THREE.Cache.add(f, e);
            if (this.status === 200) {
                if (i) i(e);
                m.manager.itemEnd(f);
            } else if (this.status === 0) {
                console.warn('THREE.XHRLoader: HTTP Status 0 received.');
                if (i) i(e);
                m.manager.itemEnd(f);
            } else {
                if (k) k(d);
                m.manager.itemError(f);
            }
        }, Z1e.e4);
        if (j !== undefined) {
            u.addEventListener('progress', function (d) {
                j(d);
            }, Z1e.e4);
        }
        u.addEventListener('error', function (d) {
            if (k) k(d);
            m.manager.itemError(f);
        }, Z1e.e4);
        if (this.responseType !== undefined) u.responseType = this.responseType;
        if (this.withCredentials !== undefined) u.withCredentials = this.withCredentials;
        u.send(Z1e.l3);
        m.manager.itemStart(f);
        return u;
    }, setPath: function (d) {
        this.path = d;
    }, setResponseType: function (d) {
        this.responseType = d;
    }, setWithCredentials: function (d) {
        this.withCredentials = d;
    }
};
THREE.FontLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
};
THREE.FontLoader.prototype = {
    constructor: THREE.FontLoader, load: function (e, f, i, j) {
        var k = new THREE.XHRLoader(this.manager);
        k.load(e, function (d) {
            f(new THREE.Font(JSON.parse(d.substring(65, d.length - 2))));
        }, i, j);
    }
};
THREE.ImageLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
};
THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader, load: function (e, f, i, j) {
        if (this.path !== undefined) e = this.path + e;
        var k = this, m = THREE.Cache.get(e);
        if (m !== undefined) {
            k.manager.itemStart(e);
            if (f) {
                setTimeout(function () {
                    f(m);
                    k.manager.itemEnd(e);
                }, 0);
            } else {
                k.manager.itemEnd(e);
            }
            return m;
        }
        var n = document.createElement('img');
        n.addEventListener('load', function (d) {
            THREE.Cache.add(e, this);
            if (f) f(this);
            k.manager.itemEnd(e);
        }, Z1e.e4);
        if (i !== undefined) {
            n.addEventListener('progress', function (d) {
                i(d);
            }, Z1e.e4);
        }
        n.addEventListener('error', function (d) {
            if (j) j(d);
            k.manager.itemError(e);
        }, Z1e.e4);
        if (this.crossOrigin !== undefined) n.crossOrigin = this.crossOrigin;
        k.manager.itemStart(e);
        n.src = e;
        return n;
    }, setCrossOrigin: function (d) {
        this.crossOrigin = d;
    }, setPath: function (d) {
        this.path = d;
    }
};
THREE.JSONLoader = function (d) {
    if (typeof d === 'boolean') {
        console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
        d = undefined;
    }
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
    this.withCredentials = Z1e.e4;
};
THREE.JSONLoader.prototype = {
    constructor: THREE.JSONLoader, get statusDomElement() {
        if (this._statusDomElement === undefined) {
            this._statusDomElement = document.createElement('div');
        }
        console.warn('THREE.JSONLoader: .statusDomElement has been removed.');
        return this._statusDomElement;
    }, load: function (m, n, u, v) {
        var B = this,
            C = this.texturePath && (typeof this.texturePath === "string") ? this.texturePath : THREE.Loader.prototype.extractUrlBase(m),
            G = new THREE.XHRLoader(this.manager);
        G.setWithCredentials(this.withCredentials);
        G.load(m, function (d) {
            var e = 'THREE.JSONLoader: ', f = JSON.parse(d), i = f.metadata;
            if (i !== undefined) {
                var j = i.type;
                if (j !== undefined) {
                    if (j.toLowerCase() === 'object') {
                        console.error(e + m + ' should be loaded with THREE.ObjectLoader instead.');
                        return;
                    }
                    if (j.toLowerCase() === 'scene') {
                        console.error(e + m + ' should be loaded with THREE.SceneLoader instead.');
                        return;
                    }
                }
            }
            var k = B.parse(f, C);
            n(k.geometry, k.materials);
        }, u, v);
    }, setTexturePath: function (d) {
        this.texturePath = d;
    }, parse: function (X0, o1) {
        var z0 = new THREE.Geometry(), Z0 = (X0.scale !== undefined) ? Z1e.d4 / X0.scale : Z1e.d4;
        q1(Z0);
        t1();
        s1(Z0);
        z1();
        z0.computeFaceNormals();
        z0.computeBoundingSphere();
        function q1(f) {
            function i(d, e) {
                return d & (1 << e);
            }
            var j, k, m, n, u, v, B, C, G, L, N, T, S, b0, h0, f0, i0, s0, t0, o0, w0, x0, D0, F0, m0, W0, y0,
                P0 = X0.faces, M0 = X0.vertices, G0 = X0.normals, a1 = X0.colors, b1 = 0;
            if (X0.uvs !== undefined) {
                for (j = 0; j < X0.uvs.length; j++) {
                    if (X0.uvs[j].length) b1++;
                }
                for (j = 0; j < b1; j++) {
                    z0.faceVertexUvs[j] = [];
                }
            }
            n = 0;
            u = M0.length;
            while (n < u) {
                s0 = new THREE.Vector3();
                s0.x = M0[n++] * f;
                s0.y = M0[n++] * f;
                s0.z = M0[n++] * f;
                z0.vertices.push(s0);
            }
            n = 0;
            u = P0.length;
            while (n < u) {
                L = P0[n++];
                N = i(L, 0);
                T = i(L, 1);
                S = i(L, 3);
                b0 = i(L, 4);
                h0 = i(L, 5);
                f0 = i(L, 6);
                i0 = i(L, 7);
                if (N) {
                    o0 = new THREE.Face3();
                    o0.a = P0[n];
                    o0.b = P0[n + 1];
                    o0.c = P0[n + 3];
                    w0 = new THREE.Face3();
                    w0.a = P0[n + 1];
                    w0.b = P0[n + 2];
                    w0.c = P0[n + 3];
                    n += 4;
                    if (T) {
                        G = P0[n++];
                        o0.materialIndex = G;
                        w0.materialIndex = G;
                    }
                    m = z0.faces.length;
                    if (S) {
                        for (j = 0; j < b1; j++) {
                            F0 = X0.uvs[j];
                            z0.faceVertexUvs[j][m] = [];
                            z0.faceVertexUvs[j][m + 1] = [];
                            for (k = 0; k < 4; k++) {
                                C = P0[n++];
                                W0 = F0[C * 2];
                                y0 = F0[C * 2 + 1];
                                m0 = new THREE.Vector2(W0, y0);
                                if (k !== 2) z0.faceVertexUvs[j][m].push(m0);
                                if (k !== 0) z0.faceVertexUvs[j][m + 1].push(m0);
                            }
                        }
                    }
                    if (b0) {
                        B = P0[n++] * 3;
                        o0.normal.set(G0[B++], G0[B++], G0[B]);
                        w0.normal.copy(o0.normal);
                    }
                    if (h0) {
                        for (j = 0; j < 4; j++) {
                            B = P0[n++] * 3;
                            D0 = new THREE.Vector3(G0[B++], G0[B++], G0[B]);
                            if (j !== 2) o0.vertexNormals.push(D0);
                            if (j !== 0) w0.vertexNormals.push(D0);
                        }
                    }
                    if (f0) {
                        v = P0[n++];
                        x0 = a1[v];
                        o0.color.setHex(x0);
                        w0.color.setHex(x0);
                    }
                    if (i0) {
                        for (j = 0; j < 4; j++) {
                            v = P0[n++];
                            x0 = a1[v];
                            if (j !== 2) o0.vertexColors.push(new THREE.Color(x0));
                            if (j !== 0) w0.vertexColors.push(new THREE.Color(x0));
                        }
                    }
                    z0.faces.push(o0);
                    z0.faces.push(w0);
                } else {
                    t0 = new THREE.Face3();
                    t0.a = P0[n++];
                    t0.b = P0[n++];
                    t0.c = P0[n++];
                    if (T) {
                        G = P0[n++];
                        t0.materialIndex = G;
                    }
                    m = z0.faces.length;
                    if (S) {
                        for (j = 0; j < b1; j++) {
                            F0 = X0.uvs[j];
                            z0.faceVertexUvs[j][m] = [];
                            for (k = 0; k < 3; k++) {
                                C = P0[n++];
                                W0 = F0[C * 2];
                                y0 = F0[C * 2 + 1];
                                m0 = new THREE.Vector2(W0, y0);
                                z0.faceVertexUvs[j][m].push(m0);
                            }
                        }
                    }
                    if (b0) {
                        B = P0[n++] * 3;
                        t0.normal.set(G0[B++], G0[B++], G0[B]);
                    }
                    if (h0) {
                        for (j = 0; j < 3; j++) {
                            B = P0[n++] * 3;
                            D0 = new THREE.Vector3(G0[B++], G0[B++], G0[B]);
                            t0.vertexNormals.push(D0);
                        }
                    }
                    if (f0) {
                        v = P0[n++];
                        t0.color.setHex(a1[v]);
                    }
                    if (i0) {
                        for (j = 0; j < 3; j++) {
                            v = P0[n++];
                            t0.vertexColors.push(new THREE.Color(a1[v]));
                        }
                    }
                    z0.faces.push(t0);
                }
            }
        };
        function t1() {
            var d = (X0.influencesPerVertex !== undefined) ? X0.influencesPerVertex : 2;
            if (X0.skinWeights) {
                for (var e = 0, f = X0.skinWeights.length; e < f; e += d) {
                    var i = X0.skinWeights[e], j = (d > 1) ? X0.skinWeights[e + 1] : 0,
                        k = (d > 2) ? X0.skinWeights[e + 2] : 0, m = (d > 3) ? X0.skinWeights[e + 3] : 0;
                    z0.skinWeights.push(new THREE.Vector4(i, j, k, m));
                }
            }
            if (X0.skinIndices) {
                for (var e = 0, f = X0.skinIndices.length; e < f; e += d) {
                    var n = X0.skinIndices[e], u = (d > 1) ? X0.skinIndices[e + 1] : 0,
                        v = (d > 2) ? X0.skinIndices[e + 2] : 0, B = (d > 3) ? X0.skinIndices[e + 3] : 0;
                    z0.skinIndices.push(new THREE.Vector4(n, u, v, B));
                }
            }
            z0.bones = X0.bones;
            if (z0.bones && z0.bones.length > 0 && (z0.skinWeights.length !== z0.skinIndices.length || z0.skinIndices.length !== z0.vertices.length)) {
                console.warn('When skinning, number of vertices (' + z0.vertices.length + '), skinIndices (' + z0.skinIndices.length + '), and skinWeights (' + z0.skinWeights.length + ') should match.');
            }
        };
        function s1(d) {
            if (X0.morphTargets !== undefined) {
                for (var e = 0, f = X0.morphTargets.length; e < f; e++) {
                    z0.morphTargets[e] = {};
                    z0.morphTargets[e].name = X0.morphTargets[e].name;
                    z0.morphTargets[e].vertices = [];
                    var i = z0.morphTargets[e].vertices, j = X0.morphTargets[e].vertices;
                    for (var k = 0, m = j.length; k < m; k += 3) {
                        var n = new THREE.Vector3();
                        n.x = j[k] * d;
                        n.y = j[k + 1] * d;
                        n.z = j[k + 2] * d;
                        i.push(n);
                    }
                }
            }
            if (X0.morphColors !== undefined && X0.morphColors.length > 0) {
                console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                var u = z0.faces, v = X0.morphColors[0].colors;
                for (var e = 0, f = u.length; e < f; e++) {
                    u[e].color.fromArray(v, e * 3);
                }
            }
        }
        function z1() {
            var d = [], e = [];
            if (X0.animation !== undefined) {
                e.push(X0.animation);
            }
            if (X0.animations !== undefined) {
                if (X0.animations.length) {
                    e = e.concat(X0.animations);
                } else {
                    e.push(X0.animations);
                }
            }
            for (var f = 0; f < e.length; f++) {
                var i = THREE.AnimationClip.parseAnimation(e[f], z0.bones);
                if (i) d.push(i);
            }
            if (z0.morphTargets) {
                var j = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(z0.morphTargets, 10);
                d = d.concat(j);
            }
            if (d.length > 0) z0.animations = d;
        };
        if (X0.materials === undefined || X0.materials.length === 0) {
            return {geometry: z0};
        } else {
            var w1 = THREE.Loader.prototype.initMaterials(X0.materials, o1, this.crossOrigin);
            return {geometry: z0, materials: w1};
        }
    }
};
THREE.LoadingManager = function (e, f, i) {
    var j = this, k = Z1e.e4, m = 0, n = 0;
    this.onStart = undefined;
    this.onLoad = e;
    this.onProgress = f;
    this.onError = i;
    this.itemStart = function (d) {
        n++;
        if (k === Z1e.e4) {
            if (j.onStart !== undefined) {
                j.onStart(d, m, n);
            }
        }
        k = Z1e.n3;
    };
    this.itemEnd = function (d) {
        m++;
        if (j.onProgress !== undefined) {
            j.onProgress(d, m, n);
        }
        if (m === n) {
            k = Z1e.e4;
            if (j.onLoad !== undefined) {
                j.onLoad();
            }
        }
    };
    this.itemError = function (d) {
        if (j.onError !== undefined) {
            j.onError(d);
        }
    };
};
THREE.DefaultLoadingManager = new THREE.LoadingManager();
THREE.BufferGeometryLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
};
THREE.BufferGeometryLoader.prototype = {
    constructor: THREE.BufferGeometryLoader, load: function (e, f, i, j) {
        var k = this, m = new THREE.XHRLoader(k.manager);
        m.load(e, function (d) {
            f(k.parse(JSON.parse(d)));
        }, i, j);
    }, parse: function (d) {
        var e = new THREE.BufferGeometry(), f = d.data.index, i = {
            'Int8Array': Int8Array,
            'Uint8Array': Uint8Array,
            'Uint8ClampedArray': Uint8ClampedArray,
            'Int16Array': Int16Array,
            'Uint16Array': Uint16Array,
            'Int32Array': Int32Array,
            'Uint32Array': Uint32Array,
            'Float32Array': Float32Array,
            'Float64Array': Float64Array
        };
        if (f !== undefined) {
            var j = new i[f.type](f.array);
            e.setIndex(new THREE.BufferAttribute(j, 1));
        }
        var k = d.data.attributes;
        for (var m in k) {
            var n = k[m], j = new i[n.type](n.array);
            e.addAttribute(m, new THREE.BufferAttribute(j, n.itemSize, n.normalized));
        }
        var u = d.data.groups || d.data.drawcalls || d.data.offsets;
        if (u !== undefined) {
            for (var v = 0, B = u.length; v !== B; ++v) {
                var C = u[v];
                e.addGroup(C.start, C.count, C.materialIndex);
            }
        }
        var G = d.data.boundingSphere;
        if (G !== undefined) {
            var L = new THREE.Vector3();
            if (G.center !== undefined) {
                L.fromArray(G.center);
            }
            e.boundingSphere = new THREE.Sphere(L, G.radius);
        }
        return e;
    }
};
THREE.MaterialLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
    this.textures = {};
};
THREE.MaterialLoader.prototype = {
    constructor: THREE.MaterialLoader, load: function (e, f, i, j) {
        var k = this, m = new THREE.XHRLoader(k.manager);
        m.load(e, function (d) {
            f(k.parse(JSON.parse(d)));
        }, i, j);
    }, setTextures: function (d) {
        this.textures = d;
    }, getTexture: function (d) {
        var e = this.textures;
        if (e[d] === undefined) {
            console.warn('THREE.MaterialLoader: Undefined texture', d);
        }
        return e[d];
    }, parse: function (d) {
        var e = new THREE[d.type];
        if (d.uuid !== undefined) e.uuid = d.uuid;
        if (d.name !== undefined) e.name = d.name;
        if (d.color !== undefined) e.color.setHex(d.color);
        if (d.roughness !== undefined) e.roughness = d.roughness;
        if (d.metalness !== undefined) e.metalness = d.metalness;
        if (d.emissive !== undefined) e.emissive.setHex(d.emissive);
        if (d.specular !== undefined) e.specular.setHex(d.specular);
        if (d.shininess !== undefined) e.shininess = d.shininess;
        if (d.uniforms !== undefined) e.uniforms = d.uniforms;
        if (d.vertexShader !== undefined) e.vertexShader = d.vertexShader;
        if (d.fragmentShader !== undefined) e.fragmentShader = d.fragmentShader;
        if (d.vertexColors !== undefined) e.vertexColors = d.vertexColors;
        if (d.shading !== undefined) e.shading = d.shading;
        if (d.blending !== undefined) e.blending = d.blending;
        if (d.side !== undefined) e.side = d.side;
        if (d.opacity !== undefined) e.opacity = d.opacity;
        if (d.transparent !== undefined) e.transparent = d.transparent;
        if (d.alphaTest !== undefined) e.alphaTest = d.alphaTest;
        if (d.depthTest !== undefined) e.depthTest = d.depthTest;
        if (d.depthWrite !== undefined) e.depthWrite = d.depthWrite;
        if (d.colorWrite !== undefined) e.colorWrite = d.colorWrite;
        if (d.wireframe !== undefined) e.wireframe = d.wireframe;
        if (d.wireframeLinewidth !== undefined) e.wireframeLinewidth = d.wireframeLinewidth;
        if (d.size !== undefined) e.size = d.size;
        if (d.sizeAttenuation !== undefined) e.sizeAttenuation = d.sizeAttenuation;
        if (d.map !== undefined) e.map = this.getTexture(d.map);
        if (d.alphaMap !== undefined) {
            e.alphaMap = this.getTexture(d.alphaMap);
            e.transparent = Z1e.n3;
        }
        if (d.bumpMap !== undefined) e.bumpMap = this.getTexture(d.bumpMap);
        if (d.bumpScale !== undefined) e.bumpScale = d.bumpScale;
        if (d.normalMap !== undefined) e.normalMap = this.getTexture(d.normalMap);
        if (d.normalScale !== undefined) {
            var f = d.normalScale;
            if (Array.isArray(f) === Z1e.e4) {
                f = [f, f];
            }
            e.normalScale = new THREE.Vector2().fromArray(f);
        }
        if (d.displacementMap !== undefined) e.displacementMap = this.getTexture(d.displacementMap);
        if (d.displacementScale !== undefined) e.displacementScale = d.displacementScale;
        if (d.displacementBias !== undefined) e.displacementBias = d.displacementBias;
        if (d.roughnessMap !== undefined) e.roughnessMap = this.getTexture(d.roughnessMap);
        if (d.metalnessMap !== undefined) e.metalnessMap = this.getTexture(d.metalnessMap);
        if (d.emissiveMap !== undefined) e.emissiveMap = this.getTexture(d.emissiveMap);
        if (d.emissiveIntensity !== undefined) e.emissiveIntensity = d.emissiveIntensity;
        if (d.specularMap !== undefined) e.specularMap = this.getTexture(d.specularMap);
        if (d.envMap !== undefined) {
            e.envMap = this.getTexture(d.envMap);
            e.combine = THREE.MultiplyOperation;
        }
        if (d.reflectivity) e.reflectivity = d.reflectivity;
        if (d.lightMap !== undefined) e.lightMap = this.getTexture(d.lightMap);
        if (d.lightMapIntensity !== undefined) e.lightMapIntensity = d.lightMapIntensity;
        if (d.aoMap !== undefined) e.aoMap = this.getTexture(d.aoMap);
        if (d.aoMapIntensity !== undefined) e.aoMapIntensity = d.aoMapIntensity;
        if (d.materials !== undefined) {
            for (var i = 0, j = d.materials.length; i < j; i++) {
                e.materials.push(this.parse(d.materials[i]));
            }
        }
        return e;
    }
};
THREE.ObjectLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
    this.texturePath = '';
};
THREE.ObjectLoader.prototype = {
    constructor: THREE.ObjectLoader, load: function (e, f, i, j) {
        if (this.texturePath === '') {
            this.texturePath = e.substring(0, e.lastIndexOf('/') + 1);
        }
        var k = this, m = new THREE.XHRLoader(k.manager);
        m.load(e, function (d) {
            k.parse(JSON.parse(d), f);
        }, i, j);
    }, setTexturePath: function (d) {
        this.texturePath = d;
    }, setCrossOrigin: function (d) {
        this.crossOrigin = d;
    }, parse: function (d, e) {
        var f = this.parseGeometries(d.geometries), i = this.parseImages(d.images, function () {
                if (e !== undefined) e(m);
            }), j = this.parseTextures(d.textures, i), k = this.parseMaterials(d.materials, j),
            m = this.parseObject(d.object, f, k);
        if (d.animations) {
            m.animations = this.parseAnimations(d.animations);
        }
        if (d.images === undefined || d.images.length === 0) {
            if (e !== undefined) e(m);
        }
        return m;
    }, parseGeometries: function (d) {
        var e = {};
        if (d !== undefined) {
            var f = new THREE.JSONLoader(), i = new THREE.BufferGeometryLoader();
            for (var j = 0, k = d.length; j < k; j++) {
                var m, n = d[j];
                switch (n.type) {
                    case Z1e.q4:
                    case Z1e.f1:
                        m = new THREE[n.type](n.width, n.height, n.widthSegments, n.heightSegments);
                        break;
                    case Z1e.F2:
                    case Z1e.u3:
                    case 'CubeGeometry':
                        m = new THREE[n.type](n.width, n.height, n.depth, n.widthSegments, n.heightSegments, n.depthSegments);
                        break;
                    case Z1e.L2:
                    case Z1e.q0:
                        m = new THREE[n.type](n.radius, n.segments, n.thetaStart, n.thetaLength);
                        break;
                    case Z1e.q3:
                    case Z1e.K0:
                        m = new THREE[n.type](n.radiusTop, n.radiusBottom, n.height, n.radialSegments, n.heightSegments, n.openEnded, n.thetaStart, n.thetaLength);
                        break;
                    case Z1e.M2:
                    case Z1e.U3:
                        m = new THREE[n.type](n.radius, n.widthSegments, n.heightSegments, n.phiStart, n.phiLength, n.thetaStart, n.thetaLength);
                        break;
                    case Z1e.r0:
                        m = new THREE.DodecahedronGeometry(n.radius, n.detail);
                        break;
                    case Z1e.I:
                        m = new THREE.IcosahedronGeometry(n.radius, n.detail);
                        break;
                    case Z1e.j2:
                        m = new THREE.OctahedronGeometry(n.radius, n.detail);
                        break;
                    case Z1e.C1:
                        m = new THREE.TetrahedronGeometry(n.radius, n.detail);
                        break;
                    case Z1e.V3:
                    case Z1e.J2:
                        m = new THREE[n.type](n.innerRadius, n.outerRadius, n.thetaSegments, n.phiSegments, n.thetaStart, n.thetaLength);
                        break;
                    case Z1e.n4:
                    case Z1e.e0:
                        m = new THREE[n.type](n.radius, n.tube, n.radialSegments, n.tubularSegments, n.arc);
                        break;
                    case Z1e.I3:
                    case Z1e.r1:
                        m = new THREE[n.type](n.radius, n.tube, n.tubularSegments, n.radialSegments, n.p, n.q);
                        break;
                    case Z1e.K1:
                    case Z1e.Q2:
                        m = new THREE[n.type](n.points, n.segments, n.phiStart, n.phiLength);
                        break;
                    case Z1e.T2:
                        m = i.parse(n);
                        break;
                    case Z1e.C0:
                        m = f.parse(n.data, this.texturePath).geometry;
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + n.type + '"');
                        continue;
                }
                m.uuid = n.uuid;
                if (n.name !== undefined) m.name = n.name;
                e[n.uuid] = m;
            }
        }
        return e;
    }, parseMaterials: function (d, e) {
        var f = {};
        if (d !== undefined) {
            var i = new THREE.MaterialLoader();
            i.setTextures(e);
            for (var j = 0, k = d.length; j < k; j++) {
                var m = i.parse(d[j]);
                f[m.uuid] = m;
            }
        }
        return f;
    }, parseAnimations: function (d) {
        var e = [];
        for (var f = 0; f < d.length; f++) {
            var i = THREE.AnimationClip.parse(d[f]);
            e.push(i);
        }
        return e;
    }, parseImages: function (e, f) {
        var i = this, j = {};
        function k(d) {
            i.manager.itemStart(d);
            return n.load(d, function () {
                i.manager.itemEnd(d);
            });
        }
        if (e !== undefined && e.length > 0) {
            var m = new THREE.LoadingManager(f), n = new THREE.ImageLoader(m);
            n.setCrossOrigin(this.crossOrigin);
            for (var u = 0, v = e.length; u < v; u++) {
                var B = e[u], C = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(B.url) ? B.url : i.texturePath + B.url;
                j[B.uuid] = k(C);
            }
        }
        return j;
    }, parseTextures: function (e, f) {
        function i(d) {
            if (typeof (d) === Z1e.H3)return d;
            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', d);
            return THREE[d];
        }
        var j = {};
        if (e !== undefined) {
            for (var k = 0, m = e.length; k < m; k++) {
                var n = e[k];
                if (n.image === undefined) {
                    console.warn('THREE.ObjectLoader: No "image" specified for', n.uuid);
                }
                if (f[n.image] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined image', n.image);
                }
                var u = new THREE.Texture(f[n.image]);
                u.needsUpdate = Z1e.n3;
                u.uuid = n.uuid;
                if (n.name !== undefined) u.name = n.name;
                if (n.mapping !== undefined) u.mapping = i(n.mapping);
                if (n.offset !== undefined) u.offset = new THREE.Vector2(n.offset[0], n.offset[1]);
                if (n.repeat !== undefined) u.repeat = new THREE.Vector2(n.repeat[0], n.repeat[1]);
                if (n.minFilter !== undefined) u.minFilter = i(n.minFilter);
                if (n.magFilter !== undefined) u.magFilter = i(n.magFilter);
                if (n.anisotropy !== undefined) u.anisotropy = n.anisotropy;
                if (Array.isArray(n.wrap)) {
                    u.wrapS = i(n.wrap[0]);
                    u.wrapT = i(n.wrap[1]);
                }
                j[n.uuid] = u;
            }
        }
        return j;
    }, parseObject: function () {
        var L = new THREE.Matrix4();
        return function (e, f, i) {
            var j;
            function k(d) {
                if (f[d] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined geometry', d);
                }
                return f[d];
            }
            function m(d) {
                if (d === undefined)return undefined;
                if (i[d] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined material', d);
                }
                return i[d];
            }
            switch (e.type) {
                case 'Scene':
                    j = new THREE.Scene();
                    break;
                case Z1e.e1:
                    j = new THREE.PerspectiveCamera(e.fov, e.aspect, e.near, e.far);
                    if (e.focus !== undefined) j.focus = e.focus;
                    if (e.zoom !== undefined) j.zoom = e.zoom;
                    if (e.filmGauge !== undefined) j.filmGauge = e.filmGauge;
                    if (e.filmOffset !== undefined) j.filmOffset = e.filmOffset;
                    if (e.view !== undefined) j.view = Object.assign({}, e.view);
                    break;
                case Z1e.H:
                    j = new THREE.OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far);
                    break;
                case Z1e.I2:
                    j = new THREE.AmbientLight(e.color, e.intensity);
                    break;
                case Z1e.o2:
                    j = new THREE.DirectionalLight(e.color, e.intensity);
                    break;
                case Z1e.N0:
                    j = new THREE.PointLight(e.color, e.intensity, e.distance, e.decay);
                    break;
                case Z1e.h3:
                    j = new THREE.SpotLight(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                    break;
                case Z1e.Y1:
                    j = new THREE.HemisphereLight(e.color, e.groundColor, e.intensity);
                    break;
                case 'Mesh':
                    var n = k(e.geometry), u = m(e.material);
                    if (n.bones && n.bones.length > 0) {
                        j = new THREE.SkinnedMesh(n, u);
                    } else {
                        j = new THREE.Mesh(n, u);
                    }
                    break;
                case 'LOD':
                    j = new THREE.LOD();
                    break;
                case 'Line':
                    j = new THREE.Line(k(e.geometry), m(e.material), e.mode);
                    break;
                case 'PointCloud':
                case 'Points':
                    j = new THREE.Points(k(e.geometry), m(e.material));
                    break;
                case 'Sprite':
                    j = new THREE.Sprite(m(e.material));
                    break;
                case 'Group':
                    j = new THREE.Group();
                    break;
                default:
                    j = new THREE.Object3D();
            }
            j.uuid = e.uuid;
            if (e.name !== undefined) j.name = e.name;
            if (e.matrix !== undefined) {
                L.fromArray(e.matrix);
                L.decompose(j.position, j.quaternion, j.scale);
            } else {
                if (e.position !== undefined) j.position.fromArray(e.position);
                if (e.rotation !== undefined) j.rotation.fromArray(e.rotation);
                if (e.scale !== undefined) j.scale.fromArray(e.scale);
            }
            if (e.castShadow !== undefined) j.castShadow = e.castShadow;
            if (e.receiveShadow !== undefined) j.receiveShadow = e.receiveShadow;
            if (e.visible !== undefined) j.visible = e.visible;
            if (e.userData !== undefined) j.userData = e.userData;
            if (e.children !== undefined) {
                for (var v in e.children) {
                    j.add(this.parseObject(e.children[v], f, i));
                }
            }
            if (e.type === 'LOD') {
                var B = e.levels;
                for (var C = 0; C < B.length; C++) {
                    var G = B[C], v = j.getObjectByProperty('uuid', G.object);
                    if (v !== undefined) {
                        j.addLevel(v, G.distance);
                    }
                }
            }
            return j;
        };
    }()
};
THREE.TextureLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
};
THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader, load: function (e, f, i, j) {
        var k = new THREE.Texture(), m = new THREE.ImageLoader(this.manager);
        m.setCrossOrigin(this.crossOrigin);
        m.setPath(this.path);
        m.load(e, function (d) {
            k.image = d;
            k.needsUpdate = Z1e.n3;
            if (f !== undefined) {
                f(k);
            }
        }, i, j);
        return k;
    }, setCrossOrigin: function (d) {
        this.crossOrigin = d;
    }, setPath: function (d) {
        this.path = d;
    }
};
THREE.CubeTextureLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
};
THREE.CubeTextureLoader.prototype = {
    constructor: THREE.CubeTextureLoader, load: function (f, i, j, k) {
        var m = new THREE.CubeTexture(), n = new THREE.ImageLoader(this.manager);
        n.setCrossOrigin(this.crossOrigin);
        n.setPath(this.path);
        var u = 0;
        function v(e) {
            n.load(f[e], function (d) {
                m.images[e] = d;
                u++;
                if (u === 6) {
                    m.needsUpdate = Z1e.n3;
                    if (i) i(m);
                }
            }, undefined, k);
        }
        for (var B = 0; B < f.length; ++B) {
            v(B);
        }
        return m;
    }, setCrossOrigin: function (d) {
        this.crossOrigin = d;
    }, setPath: function (d) {
        this.path = d;
    }
};
THREE.DataTextureLoader = THREE.BinaryTextureLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
    this._parser = Z1e.l3;
};
THREE.BinaryTextureLoader.prototype = {
    constructor: THREE.BinaryTextureLoader, load: function (f, i, j, k) {
        var m = this, n = new THREE.DataTexture(), u = new THREE.XHRLoader(this.manager);
        u.setResponseType(Z1e.z3);
        u.load(f, function (d) {
            var e = m._parser(d);
            if (!e)return;
            if (undefined !== e.image) {
                n.image = e.image;
            } else if (undefined !== e.data) {
                n.image.width = e.width;
                n.image.height = e.height;
                n.image.data = e.data;
            }
            n.wrapS = undefined !== e.wrapS ? e.wrapS : THREE.ClampToEdgeWrapping;
            n.wrapT = undefined !== e.wrapT ? e.wrapT : THREE.ClampToEdgeWrapping;
            n.magFilter = undefined !== e.magFilter ? e.magFilter : THREE.LinearFilter;
            n.minFilter = undefined !== e.minFilter ? e.minFilter : THREE.LinearMipMapLinearFilter;
            n.anisotropy = undefined !== e.anisotropy ? e.anisotropy : 1;
            if (undefined !== e.format) {
                n.format = e.format;
            }
            if (undefined !== e.type) {
                n.type = e.type;
            }
            if (undefined !== e.mipmaps) {
                n.mipmaps = e.mipmaps;
            }
            if (1 === e.mipmapCount) {
                n.minFilter = THREE.LinearFilter;
            }
            n.needsUpdate = Z1e.n3;
            if (i) i(n, e);
        }, j, k);
        return n;
    }
};
THREE.CompressedTextureLoader = function (d) {
    this.manager = (d !== undefined) ? d : THREE.DefaultLoadingManager;
    this._parser = Z1e.l3;
};
THREE.CompressedTextureLoader.prototype = {
    constructor: THREE.CompressedTextureLoader, load: function (k, m, n, u) {
        var v = this, B = [], C = new THREE.CompressedTexture();
        C.image = B;
        var G = new THREE.XHRLoader(this.manager);
        G.setPath(this.path);
        G.setResponseType(Z1e.z3);
        function L(f) {
            G.load(k[f], function (d) {
                var e = v._parser(d, Z1e.n3);
                B[f] = {width: e.width, height: e.height, format: e.format, mipmaps: e.mipmaps};
                N += 1;
                if (N === 6) {
                    if (e.mipmapCount === 1) C.minFilter = THREE.LinearFilter;
                    C.format = e.format;
                    C.needsUpdate = Z1e.n3;
                    if (m) m(C);
                }
            }, n, u);
        }
        if (Array.isArray(k)) {
            var N = 0;
            for (var T = 0, S = k.length; T < S; ++T) {
                L(T);
            }
        } else {
            G.load(k, function (d) {
                var e = v._parser(d, Z1e.n3);
                if (e.isCubemap) {
                    var f = e.mipmaps.length / e.mipmapCount;
                    for (var i = 0; i < f; i++) {
                        B[i] = {mipmaps: []};
                        for (var j = 0; j < e.mipmapCount; j++) {
                            B[i].mipmaps.push(e.mipmaps[i * e.mipmapCount + j]);
                            B[i].format = e.format;
                            B[i].width = e.width;
                            B[i].height = e.height;
                        }
                    }
                } else {
                    C.image.width = e.width;
                    C.image.height = e.height;
                    C.mipmaps = e.mipmaps;
                }
                if (e.mipmapCount === 1) {
                    C.minFilter = THREE.LinearFilter;
                }
                C.format = e.format;
                C.needsUpdate = Z1e.n3;
                if (m) m(C);
            }, n, u);
        }
        return C;
    }, setPath: function (d) {
        this.path = d;
    }
};
THREE.Material = function () {
    Object.defineProperty(this, Z1e.S0, {value: THREE.MaterialIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.type = 'Material';
    this.side = THREE.FrontSide;
    this.opacity = 1;
    this.transparent = Z1e.e4;
    this.blending = THREE.NormalBlending;
    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.blendSrcAlpha = Z1e.l3;
    this.blendDstAlpha = Z1e.l3;
    this.blendEquationAlpha = Z1e.l3;
    this.depthFunc = THREE.LessEqualDepth;
    this.depthTest = Z1e.n3;
    this.depthWrite = Z1e.n3;
    this.clippingPlanes = Z1e.l3;
    this.clipShadows = Z1e.e4;
    this.colorWrite = Z1e.n3;
    this.precision = Z1e.l3;
    this.polygonOffset = Z1e.e4;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.alphaTest = 0;
    this.premultipliedAlpha = Z1e.e4;
    this.overdraw = 0;
    this.visible = Z1e.n3;
    this._needsUpdate = Z1e.n3;
};
THREE.Material.prototype = {
    constructor: THREE.Material, get needsUpdate() {
        return this._needsUpdate;
    }, set needsUpdate(value) {
        if (value === Z1e.n3) this.update();
        this._needsUpdate = value;
    }, setValues: function (d) {
        if (d === undefined)return;
        for (var e in d) {
            var f = d[e];
            if (f === undefined) {
                console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                continue;
            }
            var i = this[e];
            if (i === undefined) {
                console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
                continue;
            }
            if (i instanceof THREE.Color) {
                i.set(f);
            } else if (i instanceof THREE.Vector3 && f instanceof THREE.Vector3) {
                i.copy(f);
            } else if (e === 'overdraw') {
                this[e] = Number(f);
            } else {
                this[e] = f;
            }
        }
    }, toJSON: function (j) {
        var k = j === undefined;
        if (k) {
            j = {textures: {}, images: {}};
        }
        var m = {metadata: {version: 4.4, type: 'Material', generator: 'Material.toJSON'}};
        m.uuid = this.uuid;
        m.type = this.type;
        if (this.name !== '') m.name = this.name;
        if (this.color instanceof THREE.Color) m.color = this.color.getHex();
        if (this.roughness !== Z1e.k1) m.roughness = this.roughness;
        if (this.metalness !== Z1e.k1) m.metalness = this.metalness;
        if (this.emissive instanceof THREE.Color) m.emissive = this.emissive.getHex();
        if (this.specular instanceof THREE.Color) m.specular = this.specular.getHex();
        if (this.shininess !== undefined) m.shininess = this.shininess;
        if (this.map instanceof THREE.Texture) m.map = this.map.toJSON(j).uuid;
        if (this.alphaMap instanceof THREE.Texture) m.alphaMap = this.alphaMap.toJSON(j).uuid;
        if (this.lightMap instanceof THREE.Texture) m.lightMap = this.lightMap.toJSON(j).uuid;
        if (this.bumpMap instanceof THREE.Texture) {
            m.bumpMap = this.bumpMap.toJSON(j).uuid;
            m.bumpScale = this.bumpScale;
        }
        if (this.normalMap instanceof THREE.Texture) {
            m.normalMap = this.normalMap.toJSON(j).uuid;
            m.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap instanceof THREE.Texture) {
            m.displacementMap = this.displacementMap.toJSON(j).uuid;
            m.displacementScale = this.displacementScale;
            m.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap instanceof THREE.Texture) m.roughnessMap = this.roughnessMap.toJSON(j).uuid;
        if (this.metalnessMap instanceof THREE.Texture) m.metalnessMap = this.metalnessMap.toJSON(j).uuid;
        if (this.emissiveMap instanceof THREE.Texture) m.emissiveMap = this.emissiveMap.toJSON(j).uuid;
        if (this.specularMap instanceof THREE.Texture) m.specularMap = this.specularMap.toJSON(j).uuid;
        if (this.envMap instanceof THREE.Texture) {
            m.envMap = this.envMap.toJSON(j).uuid;
            m.reflectivity = this.reflectivity;
        }
        if (this.size !== undefined) m.size = this.size;
        if (this.sizeAttenuation !== undefined) m.sizeAttenuation = this.sizeAttenuation;
        if (this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors) m.vertexColors = this.vertexColors;
        if (this.shading !== undefined && this.shading !== THREE.SmoothShading) m.shading = this.shading;
        if (this.blending !== undefined && this.blending !== THREE.NormalBlending) m.blending = this.blending;
        if (this.side !== undefined && this.side !== THREE.FrontSide) m.side = this.side;
        if (this.opacity < 1) m.opacity = this.opacity;
        if (this.transparent === Z1e.n3) m.transparent = this.transparent;
        if (this.alphaTest > 0) m.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === Z1e.n3) m.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === Z1e.n3) m.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) m.wireframeLinewidth = this.wireframeLinewidth;
        function n(d) {
            var e = [];
            for (var f in d) {
                var i = d[f];
                delete  i.metadata;
                e.push(i);
            }
            return e;
        }
        if (k) {
            var u = n(j.textures), v = n(j.images);
            if (u.length > 0) m.textures = u;
            if (v.length > 0) m.images = v;
        }
        return m;
    }, clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.name = d.name;
        this.side = d.side;
        this.opacity = d.opacity;
        this.transparent = d.transparent;
        this.blending = d.blending;
        this.blendSrc = d.blendSrc;
        this.blendDst = d.blendDst;
        this.blendEquation = d.blendEquation;
        this.blendSrcAlpha = d.blendSrcAlpha;
        this.blendDstAlpha = d.blendDstAlpha;
        this.blendEquationAlpha = d.blendEquationAlpha;
        this.depthFunc = d.depthFunc;
        this.depthTest = d.depthTest;
        this.depthWrite = d.depthWrite;
        this.colorWrite = d.colorWrite;
        this.precision = d.precision;
        this.polygonOffset = d.polygonOffset;
        this.polygonOffsetFactor = d.polygonOffsetFactor;
        this.polygonOffsetUnits = d.polygonOffsetUnits;
        this.alphaTest = d.alphaTest;
        this.premultipliedAlpha = d.premultipliedAlpha;
        this.overdraw = d.overdraw;
        this.visible = d.visible;
        this.clipShadows = d.clipShadows;
        var e = d.clippingPlanes, f = Z1e.l3;
        if (e !== Z1e.l3) {
            var i = e.length;
            f = new Array(i);
            for (var j = 0; j !== i; ++j)f[j] = e[j].clone();
        }
        this.clippingPlanes = f;
        return this;
    }, update: function () {
        this.dispatchEvent({type: 'update'});
    }, dispose: function () {
        this.dispatchEvent({type: Z1e.L0});
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function (d) {
    THREE.Material.call(this);
    this.type = 'LineBasicMaterial';
    this.color = new THREE.Color(0xffffff);
    this.linewidth = 1;
    this.linecap = Z1e.C2;
    this.linejoin = Z1e.C2;
    this.blending = THREE.NormalBlending;
    this.vertexColors = THREE.NoColors;
    this.fog = Z1e.n3;
    this.setValues(d);
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
THREE.LineBasicMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.linewidth = d.linewidth;
    this.linecap = d.linecap;
    this.linejoin = d.linejoin;
    this.vertexColors = d.vertexColors;
    this.fog = d.fog;
    return this;
};
THREE.LineDashedMaterial = function (d) {
    THREE.Material.call(this);
    this.type = 'LineDashedMaterial';
    this.color = new THREE.Color(0xffffff);
    this.linewidth = 1;
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.blending = THREE.NormalBlending;
    this.vertexColors = THREE.NoColors;
    this.fog = Z1e.n3;
    this.setValues(d);
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
THREE.LineDashedMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.linewidth = d.linewidth;
    this.scale = d.scale;
    this.dashSize = d.dashSize;
    this.gapSize = d.gapSize;
    this.vertexColors = d.vertexColors;
    this.fog = d.fog;
    return this;
};
THREE.MeshBasicMaterial = function (d) {
    THREE.Material.call(this);
    this.type = Z1e.W3;
    this.color = new THREE.Color(0xffffff);
    this.map = Z1e.l3;
    this.aoMap = Z1e.l3;
    this.aoMapIntensity = Z1e.d4;
    this.specularMap = Z1e.l3;
    this.alphaMap = Z1e.l3;
    this.envMap = Z1e.l3;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.fog = Z1e.n3;
    this.shading = THREE.SmoothShading;
    this.blending = THREE.NormalBlending;
    this.wireframe = Z1e.e4;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = Z1e.C2;
    this.wireframeLinejoin = Z1e.C2;
    this.vertexColors = THREE.NoColors;
    this.skinning = Z1e.e4;
    this.morphTargets = Z1e.e4;
    this.setValues(d);
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
THREE.MeshBasicMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.map = d.map;
    this.aoMap = d.aoMap;
    this.aoMapIntensity = d.aoMapIntensity;
    this.specularMap = d.specularMap;
    this.alphaMap = d.alphaMap;
    this.envMap = d.envMap;
    this.combine = d.combine;
    this.reflectivity = d.reflectivity;
    this.refractionRatio = d.refractionRatio;
    this.fog = d.fog;
    this.shading = d.shading;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.wireframeLinecap = d.wireframeLinecap;
    this.wireframeLinejoin = d.wireframeLinejoin;
    this.vertexColors = d.vertexColors;
    this.skinning = d.skinning;
    this.morphTargets = d.morphTargets;
    return this;
};
THREE.MeshDepthMaterial = function (d) {
    THREE.Material.call(this);
    this.type = 'MeshDepthMaterial';
    this.depthPacking = THREE.BasicDepthPacking;
    this.skinning = Z1e.e4;
    this.morphTargets = Z1e.e4;
    this.map = Z1e.l3;
    this.alphaMap = Z1e.l3;
    this.displacementMap = Z1e.l3;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = Z1e.e4;
    this.wireframeLinewidth = 1;
    this.setValues(d);
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
THREE.MeshDepthMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.depthPacking = d.depthPacking;
    this.skinning = d.skinning;
    this.morphTargets = d.morphTargets;
    this.map = d.map;
    this.alphaMap = d.alphaMap;
    this.displacementMap = d.displacementMap;
    this.displacementScale = d.displacementScale;
    this.displacementBias = d.displacementBias;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    return this;
};
THREE.MeshLambertMaterial = function (d) {
    THREE.Material.call(this);
    this.type = Z1e.u0;
    this.color = new THREE.Color(0xffffff);
    this.map = Z1e.l3;
    this.lightMap = Z1e.l3;
    this.lightMapIntensity = Z1e.d4;
    this.aoMap = Z1e.l3;
    this.aoMapIntensity = Z1e.d4;
    this.emissive = new THREE.Color(0x000000);
    this.emissiveIntensity = Z1e.d4;
    this.emissiveMap = Z1e.l3;
    this.specularMap = Z1e.l3;
    this.alphaMap = Z1e.l3;
    this.envMap = Z1e.l3;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.fog = Z1e.n3;
    this.blending = THREE.NormalBlending;
    this.wireframe = Z1e.e4;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = Z1e.C2;
    this.wireframeLinejoin = Z1e.C2;
    this.vertexColors = THREE.NoColors;
    this.skinning = Z1e.e4;
    this.morphTargets = Z1e.e4;
    this.morphNormals = Z1e.e4;
    this.setValues(d);
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
THREE.MeshLambertMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.map = d.map;
    this.lightMap = d.lightMap;
    this.lightMapIntensity = d.lightMapIntensity;
    this.aoMap = d.aoMap;
    this.aoMapIntensity = d.aoMapIntensity;
    this.emissive.copy(d.emissive);
    this.emissiveMap = d.emissiveMap;
    this.emissiveIntensity = d.emissiveIntensity;
    this.specularMap = d.specularMap;
    this.alphaMap = d.alphaMap;
    this.envMap = d.envMap;
    this.combine = d.combine;
    this.reflectivity = d.reflectivity;
    this.refractionRatio = d.refractionRatio;
    this.fog = d.fog;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.wireframeLinecap = d.wireframeLinecap;
    this.wireframeLinejoin = d.wireframeLinejoin;
    this.vertexColors = d.vertexColors;
    this.skinning = d.skinning;
    this.morphTargets = d.morphTargets;
    this.morphNormals = d.morphNormals;
    return this;
};
THREE.MeshNormalMaterial = function (d) {
    THREE.Material.call(this, d);
    this.type = 'MeshNormalMaterial';
    this.wireframe = Z1e.e4;
    this.wireframeLinewidth = 1;
    this.morphTargets = Z1e.e4;
    this.setValues(d);
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
THREE.MeshNormalMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    return this;
};
THREE.MeshPhongMaterial = function (d) {
    THREE.Material.call(this);
    this.type = Z1e.C3;
    this.color = new THREE.Color(0xffffff);
    this.specular = new THREE.Color(0x111111);
    this.shininess = 30;
    this.map = Z1e.l3;
    this.lightMap = Z1e.l3;
    this.lightMapIntensity = Z1e.d4;
    this.aoMap = Z1e.l3;
    this.aoMapIntensity = Z1e.d4;
    this.emissive = new THREE.Color(0x000000);
    this.emissiveIntensity = Z1e.d4;
    this.emissiveMap = Z1e.l3;
    this.bumpMap = Z1e.l3;
    this.bumpScale = 1;
    this.normalMap = Z1e.l3;
    this.normalScale = new THREE.Vector2(1, 1);
    this.displacementMap = Z1e.l3;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = Z1e.l3;
    this.alphaMap = Z1e.l3;
    this.envMap = Z1e.l3;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.fog = Z1e.n3;
    this.shading = THREE.SmoothShading;
    this.blending = THREE.NormalBlending;
    this.wireframe = Z1e.e4;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = Z1e.C2;
    this.wireframeLinejoin = Z1e.C2;
    this.vertexColors = THREE.NoColors;
    this.skinning = Z1e.e4;
    this.morphTargets = Z1e.e4;
    this.morphNormals = Z1e.e4;
    this.setValues(d);
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
THREE.MeshPhongMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.specular.copy(d.specular);
    this.shininess = d.shininess;
    this.map = d.map;
    this.lightMap = d.lightMap;
    this.lightMapIntensity = d.lightMapIntensity;
    this.aoMap = d.aoMap;
    this.aoMapIntensity = d.aoMapIntensity;
    this.emissive.copy(d.emissive);
    this.emissiveMap = d.emissiveMap;
    this.emissiveIntensity = d.emissiveIntensity;
    this.bumpMap = d.bumpMap;
    this.bumpScale = d.bumpScale;
    this.normalMap = d.normalMap;
    this.normalScale.copy(d.normalScale);
    this.displacementMap = d.displacementMap;
    this.displacementScale = d.displacementScale;
    this.displacementBias = d.displacementBias;
    this.specularMap = d.specularMap;
    this.alphaMap = d.alphaMap;
    this.envMap = d.envMap;
    this.combine = d.combine;
    this.reflectivity = d.reflectivity;
    this.refractionRatio = d.refractionRatio;
    this.fog = d.fog;
    this.shading = d.shading;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.wireframeLinecap = d.wireframeLinecap;
    this.wireframeLinejoin = d.wireframeLinejoin;
    this.vertexColors = d.vertexColors;
    this.skinning = d.skinning;
    this.morphTargets = d.morphTargets;
    this.morphNormals = d.morphNormals;
    return this;
};
THREE.MeshStandardMaterial = function (d) {
    THREE.Material.call(this);
    this.defines = {'STANDARD': ''};
    this.type = Z1e.B3;
    this.color = new THREE.Color(0xffffff);
    this.roughness = Z1e.k1;
    this.metalness = Z1e.k1;
    this.map = Z1e.l3;
    this.lightMap = Z1e.l3;
    this.lightMapIntensity = Z1e.d4;
    this.aoMap = Z1e.l3;
    this.aoMapIntensity = Z1e.d4;
    this.emissive = new THREE.Color(0x000000);
    this.emissiveIntensity = Z1e.d4;
    this.emissiveMap = Z1e.l3;
    this.bumpMap = Z1e.l3;
    this.bumpScale = 1;
    this.normalMap = Z1e.l3;
    this.normalScale = new THREE.Vector2(1, 1);
    this.displacementMap = Z1e.l3;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = Z1e.l3;
    this.metalnessMap = Z1e.l3;
    this.alphaMap = Z1e.l3;
    this.envMap = Z1e.l3;
    this.envMapIntensity = Z1e.d4;
    this.refractionRatio = 0.98;
    this.fog = Z1e.n3;
    this.shading = THREE.SmoothShading;
    this.blending = THREE.NormalBlending;
    this.wireframe = Z1e.e4;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = Z1e.C2;
    this.wireframeLinejoin = Z1e.C2;
    this.vertexColors = THREE.NoColors;
    this.skinning = Z1e.e4;
    this.morphTargets = Z1e.e4;
    this.morphNormals = Z1e.e4;
    this.setValues(d);
};
THREE.MeshStandardMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;
THREE.MeshStandardMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.defines = {'STANDARD': ''};
    this.color.copy(d.color);
    this.roughness = d.roughness;
    this.metalness = d.metalness;
    this.map = d.map;
    this.lightMap = d.lightMap;
    this.lightMapIntensity = d.lightMapIntensity;
    this.aoMap = d.aoMap;
    this.aoMapIntensity = d.aoMapIntensity;
    this.emissive.copy(d.emissive);
    this.emissiveMap = d.emissiveMap;
    this.emissiveIntensity = d.emissiveIntensity;
    this.bumpMap = d.bumpMap;
    this.bumpScale = d.bumpScale;
    this.normalMap = d.normalMap;
    this.normalScale.copy(d.normalScale);
    this.displacementMap = d.displacementMap;
    this.displacementScale = d.displacementScale;
    this.displacementBias = d.displacementBias;
    this.roughnessMap = d.roughnessMap;
    this.metalnessMap = d.metalnessMap;
    this.alphaMap = d.alphaMap;
    this.envMap = d.envMap;
    this.envMapIntensity = d.envMapIntensity;
    this.refractionRatio = d.refractionRatio;
    this.fog = d.fog;
    this.shading = d.shading;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.wireframeLinecap = d.wireframeLinecap;
    this.wireframeLinejoin = d.wireframeLinejoin;
    this.vertexColors = d.vertexColors;
    this.skinning = d.skinning;
    this.morphTargets = d.morphTargets;
    this.morphNormals = d.morphNormals;
    return this;
};
THREE.MeshPhysicalMaterial = function (d) {
    THREE.MeshStandardMaterial.call(this);
    this.defines = {'PHYSICAL': ''};
    this.type = Z1e.a3;
    this.reflectivity = Z1e.k1;
    this.setValues(d);
};
THREE.MeshPhysicalMaterial.prototype = Object.create(THREE.MeshStandardMaterial.prototype);
THREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;
THREE.MeshPhysicalMaterial.prototype.copy = function (d) {
    THREE.MeshStandardMaterial.prototype.copy.call(this, d);
    this.defines = {'PHYSICAL': ''};
    this.reflectivity = d.reflectivity;
    return this;
};
THREE.MultiMaterial = function (d) {
    this.uuid = THREE.Math.generateUUID();
    this.type = 'MultiMaterial';
    this.materials = d instanceof Array ? d : [];
    this.visible = Z1e.n3;
};
THREE.MultiMaterial.prototype = {
    constructor: THREE.MultiMaterial, toJSON: function (d) {
        var e = {
            metadata: {version: 4.2, type: 'material', generator: 'MaterialExporter'},
            uuid: this.uuid,
            type: this.type,
            materials: []
        }, f = this.materials;
        for (var i = 0, j = f.length; i < j; i++) {
            var k = f[i].toJSON(d);
            delete  k.metadata;
            e.materials.push(k);
        }
        e.visible = this.visible;
        return e;
    }, clone: function () {
        var d = new this.constructor();
        for (var e = 0; e < this.materials.length; e++) {
            d.materials.push(this.materials[e].clone());
        }
        d.visible = this.visible;
        return d;
    }
};
THREE.PointsMaterial = function (d) {
    THREE.Material.call(this);
    this.type = 'PointsMaterial';
    this.color = new THREE.Color(0xffffff);
    this.map = Z1e.l3;
    this.size = 1;
    this.sizeAttenuation = Z1e.n3;
    this.blending = THREE.NormalBlending;
    this.vertexColors = THREE.NoColors;
    this.fog = Z1e.n3;
    this.setValues(d);
};
THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
THREE.PointsMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.map = d.map;
    this.size = d.size;
    this.sizeAttenuation = d.sizeAttenuation;
    this.vertexColors = d.vertexColors;
    this.fog = d.fog;
    return this;
};
THREE.ShaderMaterial = function (d) {
    THREE.Material.call(this);
    this.type = 'ShaderMaterial';
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
    this.shading = THREE.SmoothShading;
    this.linewidth = 1;
    this.wireframe = Z1e.e4;
    this.wireframeLinewidth = 1;
    this.fog = Z1e.e4;
    this.lights = Z1e.e4;
    this.clipping = Z1e.e4;
    this.vertexColors = THREE.NoColors;
    this.skinning = Z1e.e4;
    this.morphTargets = Z1e.e4;
    this.morphNormals = Z1e.e4;
    this.extensions = {derivatives: Z1e.e4, fragDepth: Z1e.e4, drawBuffers: Z1e.e4, shaderTextureLOD: Z1e.e4};
    this.defaultAttributeValues = {'color': [1, 1, 1], 'uv': [0, 0], 'uv2': [0, 0]};
    this.index0AttributeName = undefined;
    if (d !== undefined) {
        if (d.attributes !== undefined) {
            console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        }
        this.setValues(d);
    }
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
THREE.ShaderMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.fragmentShader = d.fragmentShader;
    this.vertexShader = d.vertexShader;
    this.uniforms = THREE.UniformsUtils.clone(d.uniforms);
    this.defines = d.defines;
    this.shading = d.shading;
    this.wireframe = d.wireframe;
    this.wireframeLinewidth = d.wireframeLinewidth;
    this.fog = d.fog;
    this.lights = d.lights;
    this.clipping = d.clipping;
    this.vertexColors = d.vertexColors;
    this.skinning = d.skinning;
    this.morphTargets = d.morphTargets;
    this.morphNormals = d.morphNormals;
    this.extensions = d.extensions;
    return this;
};
THREE.ShaderMaterial.prototype.toJSON = function (d) {
    var e = THREE.Material.prototype.toJSON.call(this, d);
    e.uniforms = this.uniforms;
    e.vertexShader = this.vertexShader;
    e.fragmentShader = this.fragmentShader;
    return e;
};
THREE.RawShaderMaterial = function (d) {
    THREE.ShaderMaterial.call(this, d);
    this.type = 'RawShaderMaterial';
};
THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
THREE.SpriteMaterial = function (d) {
    THREE.Material.call(this);
    this.type = 'SpriteMaterial';
    this.color = new THREE.Color(0xffffff);
    this.map = Z1e.l3;
    this.rotation = 0;
    this.fog = Z1e.e4;
    this.setValues(d);
};
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
THREE.SpriteMaterial.prototype.copy = function (d) {
    THREE.Material.prototype.copy.call(this, d);
    this.color.copy(d.color);
    this.map = d.map;
    this.rotation = d.rotation;
    this.fog = d.fog;
    return this;
};
THREE.Texture = function (d, e, f, i, j, k, m, n, u, v) {
    Object.defineProperty(this, Z1e.S0, {value: THREE.TextureIdCount++});
    this.uuid = THREE.Math.generateUUID();
    this.name = '';
    this.sourceFile = '';
    this.image = d !== undefined ? d : THREE.Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = e !== undefined ? e : THREE.Texture.DEFAULT_MAPPING;
    this.wrapS = f !== undefined ? f : THREE.ClampToEdgeWrapping;
    this.wrapT = i !== undefined ? i : THREE.ClampToEdgeWrapping;
    this.magFilter = j !== undefined ? j : THREE.LinearFilter;
    this.minFilter = k !== undefined ? k : THREE.LinearMipMapLinearFilter;
    this.anisotropy = u !== undefined ? u : 1;
    this.format = m !== undefined ? m : THREE.RGBAFormat;
    this.type = n !== undefined ? n : THREE.UnsignedByteType;
    this.offset = new THREE.Vector2(0, 0);
    this.repeat = new THREE.Vector2(1, 1);
    this.generateMipmaps = Z1e.n3;
    this.premultiplyAlpha = Z1e.e4;
    this.flipY = Z1e.n3;
    this.unpackAlignment = 4;
    this.encoding = v !== undefined ? v : THREE.LinearEncoding;
    this.version = 0;
    this.onUpdate = Z1e.l3;
};
THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
THREE.Texture.prototype = {
    constructor: THREE.Texture, set needsUpdate(value) {
        if (value === Z1e.n3) this.version++;
    }, clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.image = d.image;
        this.mipmaps = d.mipmaps.slice(0);
        this.mapping = d.mapping;
        this.wrapS = d.wrapS;
        this.wrapT = d.wrapT;
        this.magFilter = d.magFilter;
        this.minFilter = d.minFilter;
        this.anisotropy = d.anisotropy;
        this.format = d.format;
        this.type = d.type;
        this.offset.copy(d.offset);
        this.repeat.copy(d.repeat);
        this.generateMipmaps = d.generateMipmaps;
        this.premultiplyAlpha = d.premultiplyAlpha;
        this.flipY = d.flipY;
        this.unpackAlignment = d.unpackAlignment;
        this.encoding = d.encoding;
        return this;
    }, toJSON: function (f) {
        if (f.textures[this.uuid] !== undefined) {
            return f.textures[this.uuid];
        }
        function i(d) {
            var e;
            if (d.toDataURL !== undefined) {
                e = d;
            } else {
                e = document.createElement(Z1e.M);
                e.width = d.width;
                e.height = d.height;
                e.getContext('2d').drawImage(d, 0, 0, d.width, d.height);
            }
            if (e.width > 2048 || e.height > 2048) {
                return e.toDataURL('image/jpeg', 0.6);
            } else {
                return e.toDataURL('image/png');
            }
        }
        var j = {
            metadata: {version: 4.4, type: 'Texture', generator: 'Texture.toJSON'},
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            wrap: [this.wrapS, this.wrapT],
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy
        };
        if (this.image !== undefined) {
            var k = this.image;
            if (k.uuid === undefined) {
                k.uuid = THREE.Math.generateUUID();
            }
            if (f.images[k.uuid] === undefined) {
                f.images[k.uuid] = {uuid: k.uuid, url: i(k)};
            }
            j.image = k.uuid;
        }
        f.textures[this.uuid] = j;
        return j;
    }, dispose: function () {
        this.dispatchEvent({type: Z1e.L0});
    }, transformUv: function (d) {
        if (this.mapping !== THREE.UVMapping)return;
        d.multiply(this.repeat);
        d.add(this.offset);
        if (d.x < 0 || d.x > 1) {
            switch (this.wrapS) {
                case THREE.RepeatWrapping:
                    d.x = d.x - Math.floor(d.x);
                    break;
                case THREE.ClampToEdgeWrapping:
                    d.x = d.x < 0 ? 0 : 1;
                    break;
                case THREE.MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(d.x) % 2) === 1) {
                        d.x = Math.ceil(d.x) - d.x;
                    } else {
                        d.x = d.x - Math.floor(d.x);
                    }
                    break;
            }
        }
        if (d.y < 0 || d.y > 1) {
            switch (this.wrapT) {
                case THREE.RepeatWrapping:
                    d.y = d.y - Math.floor(d.y);
                    break;
                case THREE.ClampToEdgeWrapping:
                    d.y = d.y < 0 ? 0 : 1;
                    break;
                case THREE.MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(d.y) % 2) === 1) {
                        d.y = Math.ceil(d.y) - d.y;
                    } else {
                        d.y = d.y - Math.floor(d.y);
                    }
                    break;
            }
        }
        if (this.flipY) {
            d.y = 1 - d.y;
        }
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.DepthTexture = function (d, e, f, i, j, k, m, n, u) {
    THREE.Texture.call(this, Z1e.l3, i, j, k, m, n, THREE.DepthFormat, f, u);
    this.image = {width: d, height: e};
    this.type = f !== undefined ? f : THREE.UnsignedShortType;
    this.magFilter = m !== undefined ? m : THREE.NearestFilter;
    this.minFilter = n !== undefined ? n : THREE.NearestFilter;
    this.flipY = Z1e.e4;
    this.generateMipmaps = Z1e.e4;
};
THREE.DepthTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DepthTexture.prototype.constructor = THREE.DepthTexture;
THREE.CanvasTexture = function (d, e, f, i, j, k, m, n, u) {
    THREE.Texture.call(this, d, e, f, i, j, k, m, n, u);
    this.needsUpdate = Z1e.n3;
};
THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
THREE.CubeTexture = function (d, e, f, i, j, k, m, n, u, v) {
    d = d !== undefined ? d : [];
    e = e !== undefined ? e : THREE.CubeReflectionMapping;
    THREE.Texture.call(this, d, e, f, i, j, k, m, n, u, v);
    this.flipY = Z1e.e4;
};
THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
Object.defineProperty(THREE.CubeTexture.prototype, 'images', {
    get: function () {
        return this.image;
    }, set: function (d) {
        this.image = d;
    }
});
THREE.CompressedTexture = function (d, e, f, i, j, k, m, n, u, v, B, C) {
    THREE.Texture.call(this, Z1e.l3, k, m, n, u, v, i, j, B, C);
    this.image = {width: e, height: f};
    this.mipmaps = d;
    this.flipY = Z1e.e4;
    this.generateMipmaps = Z1e.e4;
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
THREE.DataTexture = function (d, e, f, i, j, k, m, n, u, v, B, C) {
    THREE.Texture.call(this, Z1e.l3, k, m, n, u, v, i, j, B, C);
    this.image = {data: d, width: e, height: f};
    this.magFilter = u !== undefined ? u : THREE.NearestFilter;
    this.minFilter = v !== undefined ? v : THREE.NearestFilter;
    this.flipY = Z1e.e4;
    this.generateMipmaps = Z1e.e4;
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.constructor = THREE.DataTexture;
THREE.VideoTexture = function (d, e, f, i, j, k, m, n, u) {
    THREE.Texture.call(this, d, e, f, i, j, k, m, n, u);
    this.generateMipmaps = Z1e.e4;
    var v = this;
    function B() {
        requestAnimationFrame(B);
        if (d.readyState >= d.HAVE_CURRENT_DATA) {
            v.needsUpdate = Z1e.n3;
        }
    }
    B();
};
THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
THREE.Group = function () {
    THREE.Object3D.call(this);
    this.type = 'Group';
};
THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
THREE.Group.prototype.constructor = THREE.Group;
THREE.Points = function (d, e) {
    THREE.Object3D.call(this);
    this.type = 'Points';
    this.geometry = d !== undefined ? d : new THREE.Geometry();
    this.material = e !== undefined ? e : new THREE.PointsMaterial({color: Math.random() * 0xffffff});
};
THREE.Points.prototype = Object.create(THREE.Object3D.prototype);
THREE.Points.prototype.constructor = THREE.Points;
THREE.Points.prototype.raycast = (function () {
    var w0 = new THREE.Matrix4(), x0 = new THREE.Ray(), D0 = new THREE.Sphere();
    return function F0(k, m) {
        var n = this, u = this.geometry, v = this.matrixWorld, B = k.params.Points.threshold;
        if (u.boundingSphere === Z1e.l3) u.computeBoundingSphere();
        D0.copy(u.boundingSphere);
        D0.applyMatrix4(v);
        if (k.ray.intersectsSphere(D0) === Z1e.e4)return;
        w0.getInverse(v);
        x0.copy(k.ray).applyMatrix4(w0);
        var C = B / ((this.scale.x + this.scale.y + this.scale.z) / 3), G = C * C, L = new THREE.Vector3();
        function N(d, e) {
            var f = x0.distanceSqToPoint(d);
            if (f < G) {
                var i = x0.closestPointToPoint(d);
                i.applyMatrix4(v);
                var j = k.ray.origin.distanceTo(i);
                if (j < k.near || j > k.far)return;
                m.push({distance: j, distanceToRay: Math.sqrt(f), point: i.clone(), index: e, face: Z1e.l3, object: n});
            }
        }
        if (u instanceof THREE.BufferGeometry) {
            var T = u.index, S = u.attributes, b0 = S.position.array;
            if (T !== Z1e.l3) {
                var h0 = T.array;
                for (var f0 = 0, i0 = h0.length; f0 < i0; f0++) {
                    var s0 = h0[f0];
                    L.fromArray(b0, s0 * 3);
                    N(L, s0);
                }
            } else {
                for (var f0 = 0, t0 = b0.length / 3; f0 < t0; f0++) {
                    L.fromArray(b0, f0 * 3);
                    N(L, f0);
                }
            }
        } else {
            var o0 = u.vertices;
            for (var f0 = 0, t0 = o0.length; f0 < t0; f0++) {
                N(o0[f0], f0);
            }
        }
    };
}());
THREE.Points.prototype.clone = function () {
    return new this.constructor(this.geometry, this.material).copy(this);
};
THREE.Line = function (d, e, f) {
    if (f === 1) {
        console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
        return new THREE.LineSegments(d, e);
    }
    THREE.Object3D.call(this);
    this.type = 'Line';
    this.geometry = d !== undefined ? d : new THREE.Geometry();
    this.material = e !== undefined ? e : new THREE.LineBasicMaterial({color: Math.random() * 0xffffff});
};
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.constructor = THREE.Line;
THREE.Line.prototype.raycast = (function () {
    var o0 = new THREE.Matrix4(), w0 = new THREE.Ray(), x0 = new THREE.Sphere();
    return function D0(d, e) {
        var f = d.linePrecision, i = f * f, j = this.geometry, k = this.matrixWorld;
        if (j.boundingSphere === Z1e.l3) j.computeBoundingSphere();
        x0.copy(j.boundingSphere);
        x0.applyMatrix4(k);
        if (d.ray.intersectsSphere(x0) === Z1e.e4)return;
        o0.getInverse(k);
        w0.copy(d.ray).applyMatrix4(o0);
        var m = new THREE.Vector3(), n = new THREE.Vector3(), u = new THREE.Vector3(), v = new THREE.Vector3(),
            B = this instanceof THREE.LineSegments ? 2 : 1;
        if (j instanceof THREE.BufferGeometry) {
            var C = j.index, G = j.attributes, L = G.position.array;
            if (C !== Z1e.l3) {
                var N = C.array;
                for (var T = 0, S = N.length - 1; T < S; T += B) {
                    var b0 = N[T], h0 = N[T + 1];
                    m.fromArray(L, b0 * 3);
                    n.fromArray(L, h0 * 3);
                    var f0 = w0.distanceSqToSegment(m, n, v, u);
                    if (f0 > i)continue;
                    v.applyMatrix4(this.matrixWorld);
                    var i0 = d.ray.origin.distanceTo(v);
                    if (i0 < d.near || i0 > d.far)continue;
                    e.push({
                        distance: i0,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: T,
                        face: Z1e.l3,
                        faceIndex: Z1e.l3,
                        object: this
                    });
                }
            } else {
                for (var T = 0, S = L.length / 3 - 1; T < S; T += B) {
                    m.fromArray(L, 3 * T);
                    n.fromArray(L, 3 * T + 3);
                    var f0 = w0.distanceSqToSegment(m, n, v, u);
                    if (f0 > i)continue;
                    v.applyMatrix4(this.matrixWorld);
                    var i0 = d.ray.origin.distanceTo(v);
                    if (i0 < d.near || i0 > d.far)continue;
                    e.push({
                        distance: i0,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: T,
                        face: Z1e.l3,
                        faceIndex: Z1e.l3,
                        object: this
                    });
                }
            }
        } else if (j instanceof THREE.Geometry) {
            var s0 = j.vertices, t0 = s0.length;
            for (var T = 0; T < t0 - 1; T += B) {
                var f0 = w0.distanceSqToSegment(s0[T], s0[T + 1], v, u);
                if (f0 > i)continue;
                v.applyMatrix4(this.matrixWorld);
                var i0 = d.ray.origin.distanceTo(v);
                if (i0 < d.near || i0 > d.far)continue;
                e.push({
                    distance: i0,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: T,
                    face: Z1e.l3,
                    faceIndex: Z1e.l3,
                    object: this
                });
            }
        }
    };
}());
THREE.Line.prototype.clone = function () {
    return new this.constructor(this.geometry, this.material).copy(this);
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.LineSegments = function (d, e) {
    THREE.Line.call(this, d, e);
    this.type = 'LineSegments';
};
THREE.LineSegments.prototype = Object.create(THREE.Line.prototype);
THREE.LineSegments.prototype.constructor = THREE.LineSegments;
THREE.Mesh = function (d, e) {
    THREE.Object3D.call(this);
    this.type = 'Mesh';
    this.geometry = d !== undefined ? d : new THREE.Geometry();
    this.material = e !== undefined ? e : new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff});
    this.drawMode = THREE.TrianglesDrawMode;
    this.updateMorphTargets();
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.constructor = THREE.Mesh;
THREE.Mesh.prototype.setDrawMode = function (d) {
    this.drawMode = d;
};
THREE.Mesh.prototype.updateMorphTargets = function () {
    if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
        this.morphTargetBase = -1;
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (var d = 0, e = this.geometry.morphTargets.length; d < e; d++) {
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[this.geometry.morphTargets[d].name] = d;
        }
    }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function (d) {
    if (this.morphTargetDictionary[d] !== undefined) {
        return this.morphTargetDictionary[d];
    }
    console.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + d + ' does not exist. Returning 0.');
    return 0;
};
THREE.Mesh.prototype.raycast = (function () {
    var b1 = new THREE.Matrix4(), X0 = new THREE.Ray(), o1 = new THREE.Sphere(), z0 = new THREE.Vector3(),
        Z0 = new THREE.Vector3(), q1 = new THREE.Vector3(), t1 = new THREE.Vector3(), s1 = new THREE.Vector3(),
        z1 = new THREE.Vector3(), w1 = new THREE.Vector2(), u1 = new THREE.Vector2(), L1 = new THREE.Vector2(),
        S1 = new THREE.Vector3(), y1 = new THREE.Vector3(), a2 = new THREE.Vector3();
    function P1(d, e, f, i, j, k, m) {
        THREE.Triangle.barycoordFromPoint(d, e, f, i, S1);
        j.multiplyScalar(S1.x);
        k.multiplyScalar(S1.y);
        m.multiplyScalar(S1.z);
        j.add(k).add(m);
        return j.clone();
    }
    function B1(d, e, f, i, j, k, m) {
        var n, u = d.material;
        if (u.side === THREE.BackSide) {
            n = f.intersectTriangle(k, j, i, Z1e.n3, m);
        } else {
            n = f.intersectTriangle(i, j, k, u.side !== THREE.DoubleSide, m);
        }
        if (n === Z1e.l3)return Z1e.l3;
        a2.copy(m);
        a2.applyMatrix4(d.matrixWorld);
        var v = e.ray.origin.distanceTo(a2);
        if (v < e.near || v > e.far)return Z1e.l3;
        return {distance: v, point: a2.clone(), object: d};
    }
    function p2(d, e, f, i, j, k, m, n) {
        z0.fromArray(i, k * 3);
        Z0.fromArray(i, m * 3);
        q1.fromArray(i, n * 3);
        var u = B1(d, e, f, z0, Z0, q1, y1);
        if (u) {
            if (j) {
                w1.fromArray(j, k * 2);
                u1.fromArray(j, m * 2);
                L1.fromArray(j, n * 2);
                u.uv = P1(y1, z0, Z0, q1, w1, u1, L1);
            }
            u.face = new THREE.Face3(k, m, n, THREE.Triangle.normal(z0, Z0, q1));
            u.faceIndex = k;
        }
        return u;
    }
    return function K2(d, e) {
        var f = this.geometry, i = this.material, j = this.matrixWorld;
        if (i === undefined)return;
        if (f.boundingSphere === Z1e.l3) f.computeBoundingSphere();
        o1.copy(f.boundingSphere);
        o1.applyMatrix4(j);
        if (d.ray.intersectsSphere(o1) === Z1e.e4)return;
        b1.getInverse(j);
        X0.copy(d.ray).applyMatrix4(b1);
        if (f.boundingBox !== Z1e.l3) {
            if (X0.intersectsBox(f.boundingBox) === Z1e.e4)return;
        }
        var k, m;
        if (f instanceof THREE.BufferGeometry) {
            var n, u, v, B = f.index, C = f.attributes, G = C.position.array;
            if (C.uv !== undefined) {
                k = C.uv.array;
            }
            if (B !== Z1e.l3) {
                var L = B.array;
                for (var N = 0, T = L.length; N < T; N += 3) {
                    n = L[N];
                    u = L[N + 1];
                    v = L[N + 2];
                    m = p2(this, d, X0, G, k, n, u, v);
                    if (m) {
                        m.faceIndex = Math.floor(N / 3);
                        e.push(m);
                    }
                }
            } else {
                for (var N = 0, T = G.length; N < T; N += 9) {
                    n = N / 3;
                    u = n + 1;
                    v = n + 2;
                    m = p2(this, d, X0, G, k, n, u, v);
                    if (m) {
                        m.index = n;
                        e.push(m);
                    }
                }
            }
        } else if (f instanceof THREE.Geometry) {
            var S, b0, h0, f0 = i instanceof THREE.MultiMaterial, i0 = f0 === Z1e.n3 ? i.materials : Z1e.l3,
                s0 = f.vertices, t0 = f.faces, o0 = f.faceVertexUvs[0];
            if (o0.length > 0) k = o0;
            for (var w0 = 0, x0 = t0.length; w0 < x0; w0++) {
                var D0 = t0[w0], F0 = f0 === Z1e.n3 ? i0[D0.materialIndex] : i;
                if (F0 === undefined)continue;
                S = s0[D0.a];
                b0 = s0[D0.b];
                h0 = s0[D0.c];
                if (F0.morphTargets === Z1e.n3) {
                    var m0 = f.morphTargets, W0 = this.morphTargetInfluences;
                    z0.set(0, 0, 0);
                    Z0.set(0, 0, 0);
                    q1.set(0, 0, 0);
                    for (var y0 = 0, P0 = m0.length; y0 < P0; y0++) {
                        var M0 = W0[y0];
                        if (M0 === 0)continue;
                        var G0 = m0[y0].vertices;
                        z0.addScaledVector(t1.subVectors(G0[D0.a], S), M0);
                        Z0.addScaledVector(s1.subVectors(G0[D0.b], b0), M0);
                        q1.addScaledVector(z1.subVectors(G0[D0.c], h0), M0);
                    }
                    z0.add(S);
                    Z0.add(b0);
                    q1.add(h0);
                    S = z0;
                    b0 = Z0;
                    h0 = q1;
                }
                m = B1(this, d, X0, S, b0, h0, y1);
                if (m) {
                    if (k) {
                        var a1 = k[w0];
                        w1.copy(a1[0]);
                        u1.copy(a1[1]);
                        L1.copy(a1[2]);
                        m.uv = P1(y1, S, b0, h0, w1, u1, L1);
                    }
                    m.face = D0;
                    m.faceIndex = w0;
                    e.push(m);
                }
            }
        }
    };
}());
THREE.Mesh.prototype.clone = function () {
    return new this.constructor(this.geometry, this.material).copy(this);
};
THREE.Bone = function (d) {
    THREE.Object3D.call(this);
    this.type = 'Bone';
    this.skin = d;
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.constructor = THREE.Bone;
THREE.Bone.prototype.copy = function (d) {
    THREE.Object3D.prototype.copy.call(this, d);
    this.skin = d.skin;
    return this;
};
THREE.Skeleton = function (d, e, f) {
    this.useVertexTexture = f !== undefined ? f : Z1e.n3;
    this.identityMatrix = new THREE.Matrix4();
    d = d || [];
    this.bones = d.slice(0);
    if (this.useVertexTexture) {
        var i = Math.sqrt(this.bones.length * 4);
        i = THREE.Math.nextPowerOfTwo(Math.ceil(i));
        i = Math.max(i, 4);
        this.boneTextureWidth = i;
        this.boneTextureHeight = i;
        this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
        this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
    } else {
        this.boneMatrices = new Float32Array(16 * this.bones.length);
    }
    if (e === undefined) {
        this.calculateInverses();
    } else {
        if (this.bones.length === e.length) {
            this.boneInverses = e.slice(0);
        } else {
            console.warn('THREE.Skeleton bonInverses is the wrong length.');
            this.boneInverses = [];
            for (var j = 0, k = this.bones.length; j < k; j++) {
                this.boneInverses.push(new THREE.Matrix4());
            }
        }
    }
};
THREE.Skeleton.prototype.calculateInverses = function () {
    this.boneInverses = [];
    for (var d = 0, e = this.bones.length; d < e; d++) {
        var f = new THREE.Matrix4();
        if (this.bones[d]) {
            f.getInverse(this.bones[d].matrixWorld);
        }
        this.boneInverses.push(f);
    }
};
THREE.Skeleton.prototype.pose = function () {
    var d;
    for (var e = 0, f = this.bones.length; e < f; e++) {
        d = this.bones[e];
        if (d) {
            d.matrixWorld.getInverse(this.boneInverses[e]);
        }
    }
    for (var e = 0, f = this.bones.length; e < f; e++) {
        d = this.bones[e];
        if (d) {
            if (d.parent) {
                d.matrix.getInverse(d.parent.matrixWorld);
                d.matrix.multiply(d.matrixWorld);
            } else {
                d.matrix.copy(d.matrixWorld);
            }
            d.matrix.decompose(d.position, d.quaternion, d.scale);
        }
    }
};
THREE.Skeleton.prototype.update = (function () {
    var i = new THREE.Matrix4();
    return function j() {
        for (var d = 0, e = this.bones.length; d < e; d++) {
            var f = this.bones[d] ? this.bones[d].matrixWorld : this.identityMatrix;
            i.multiplyMatrices(f, this.boneInverses[d]);
            i.toArray(this.boneMatrices, d * 16);
        }
        if (this.useVertexTexture) {
            this.boneTexture.needsUpdate = Z1e.n3;
        }
    };
})();
THREE.Skeleton.prototype.clone = function () {
    return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
};
THREE.SkinnedMesh = function (d, e, f) {
    THREE.Mesh.call(this, d, e);
    this.type = 'SkinnedMesh';
    this.bindMode = "attached";
    this.bindMatrix = new THREE.Matrix4();
    this.bindMatrixInverse = new THREE.Matrix4();
    var i = [];
    if (this.geometry && this.geometry.bones !== undefined) {
        var j, k;
        for (var m = 0, n = this.geometry.bones.length; m < n; ++m) {
            k = this.geometry.bones[m];
            j = new THREE.Bone(this);
            i.push(j);
            j.name = k.name;
            j.position.fromArray(k.pos);
            j.quaternion.fromArray(k.rotq);
            if (k.scl !== undefined) j.scale.fromArray(k.scl);
        }
        for (var m = 0, n = this.geometry.bones.length; m < n; ++m) {
            k = this.geometry.bones[m];
            if (k.parent !== -1 && k.parent !== Z1e.l3 && i[k.parent] !== undefined) {
                i[k.parent].add(i[m]);
            } else {
                this.add(i[m]);
            }
        }
    }
    this.normalizeSkinWeights();
    this.updateMatrixWorld(Z1e.n3);
    this.bind(new THREE.Skeleton(i, undefined, f), this.matrixWorld);
};
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
THREE.SkinnedMesh.prototype.bind = function (d, e) {
    this.skeleton = d;
    if (e === undefined) {
        this.updateMatrixWorld(Z1e.n3);
        this.skeleton.calculateInverses();
        e = this.matrixWorld;
    }
    this.bindMatrix.copy(e);
    this.bindMatrixInverse.getInverse(e);
};
THREE.SkinnedMesh.prototype.pose = function () {
    this.skeleton.pose();
};
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
    if (this.geometry instanceof THREE.Geometry) {
        for (var d = 0; d < this.geometry.skinWeights.length; d++) {
            var e = this.geometry.skinWeights[d], f = Z1e.d4 / e.lengthManhattan();
            if (f !== Infinity) {
                e.multiplyScalar(f);
            } else {
                e.set(1, 0, 0, 0);
            }
        }
    } else if (this.geometry instanceof THREE.BufferGeometry) {
        var i = new THREE.Vector4(), j = this.geometry.attributes.skinWeight;
        for (var d = 0; d < j.count; d++) {
            i.x = j.getX(d);
            i.y = j.getY(d);
            i.z = j.getZ(d);
            i.w = j.getW(d);
            var f = Z1e.d4 / i.lengthManhattan();
            if (f !== Infinity) {
                i.multiplyScalar(f);
            } else {
                i.set(1, 0, 0, 0);
            }
            j.setXYZW(d, i.x, i.y, i.z, i.w);
        }
    }
};
THREE.SkinnedMesh.prototype.updateMatrixWorld = function (d) {
    THREE.Mesh.prototype.updateMatrixWorld.call(this, Z1e.n3);
    if (this.bindMode === "attached") {
        this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
        console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
    }
};
THREE.SkinnedMesh.prototype.clone = function () {
    return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this);
};
THREE.LOD = function () {
    THREE.Object3D.call(this);
    this.type = 'LOD';
    Object.defineProperties(this, {levels: {enumerable: Z1e.n3, value: []}});
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.constructor = THREE.LOD;
THREE.LOD.prototype.addLevel = function (d, e) {
    if (e === undefined) e = 0;
    e = Math.abs(e);
    var f = this.levels;
    for (var i = 0; i < f.length; i++) {
        if (e < f[i].distance) {
            break;
        }
    }
    f.splice(i, 0, {distance: e, object: d});
    this.add(d);
};
THREE.LOD.prototype.getObjectForDistance = function (d) {
    var e = this.levels;
    for (var f = 1, i = e.length; f < i; f++) {
        if (d < e[f].distance) {
            break;
        }
    }
    return e[f - 1].object;
};
THREE.LOD.prototype.raycast = (function () {
    var i = new THREE.Vector3();
    return function j(d, e) {
        i.setFromMatrixPosition(this.matrixWorld);
        var f = d.ray.origin.distanceTo(i);
        this.getObjectForDistance(f).raycast(d, e);
    };
}());
THREE.LOD.prototype.update = function () {
    var k = new THREE.Vector3(), m = new THREE.Vector3();
    return function n(d) {
        var e = this.levels;
        if (e.length > 1) {
            k.setFromMatrixPosition(d.matrixWorld);
            m.setFromMatrixPosition(this.matrixWorld);
            var f = k.distanceTo(m);
            e[0].object.visible = Z1e.n3;
            for (var i = 1, j = e.length; i < j; i++) {
                if (f >= e[i].distance) {
                    e[i - 1].object.visible = Z1e.e4;
                    e[i].object.visible = Z1e.n3;
                } else {
                    break;
                }
            }
            for (; i < j; i++) {
                e[i].object.visible = Z1e.e4;
            }
        }
    };
}();
THREE.LOD.prototype.copy = function (d) {
    THREE.Object3D.prototype.copy.call(this, d, Z1e.e4);
    var e = d.levels;
    for (var f = 0, i = e.length; f < i; f++) {
        var j = e[f];
        this.addLevel(j.object.clone(), j.distance);
    }
    return this;
};
THREE.LOD.prototype.toJSON = function (d) {
    var e = THREE.Object3D.prototype.toJSON.call(this, d);
    e.object.levels = [];
    var f = this.levels;
    for (var i = 0, j = f.length; i < j; i++) {
        var k = f[i];
        e.object.levels.push({object: k.object.uuid, distance: k.distance});
    }
    return e;
};
THREE.Sprite = (function () {
    var e = new Uint16Array([0, 1, 2, 0, 2, 3]),
        f = new Float32Array([-Z1e.k1, -Z1e.k1, 0, Z1e.k1, -Z1e.k1, 0, Z1e.k1, Z1e.k1, 0, -Z1e.k1, Z1e.k1, 0]),
        i = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), j = new THREE.BufferGeometry();
    j.setIndex(new THREE.BufferAttribute(e, 1));
    j.addAttribute(Z1e.g1, new THREE.BufferAttribute(f, 3));
    j.addAttribute(Z1e.M3, new THREE.BufferAttribute(i, 2));
    return function k(d) {
        THREE.Object3D.call(this);
        this.type = 'Sprite';
        this.geometry = j;
        this.material = (d !== undefined) ? d : new THREE.SpriteMaterial();
    };
})();
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.constructor = THREE.Sprite;
THREE.Sprite.prototype.raycast = (function () {
    var j = new THREE.Vector3();
    return function k(d, e) {
        j.setFromMatrixPosition(this.matrixWorld);
        var f = d.ray.distanceSqToPoint(j), i = this.scale.x * this.scale.y / 4;
        if (f > i) {
            return;
        }
        e.push({distance: Math.sqrt(f), point: this.position, face: Z1e.l3, object: this});
    };
}());
THREE.Sprite.prototype.clone = function () {
    return new this.constructor(this.material).copy(this);
};
THREE.Particle = THREE.Sprite;
THREE.LensFlare = function (d, e, f, i, j) {
    THREE.Object3D.call(this);
    this.lensFlares = [];
    this.positionScreen = new THREE.Vector3();
    this.customUpdateCallback = undefined;
    if (d !== undefined) {
        this.add(d, e, f, i, j);
    }
};
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.constructor = THREE.LensFlare;
THREE.LensFlare.prototype.add = function (d, e, f, i, j, k) {
    if (e === undefined) e = -1;
    if (f === undefined) f = 0;
    if (k === undefined) k = 1;
    if (j === undefined) j = new THREE.Color(0xffffff);
    if (i === undefined) i = THREE.NormalBlending;
    f = Math.min(f, Math.max(0, f));
    this.lensFlares.push({
        texture: d,
        size: e,
        distance: f,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 0,
        opacity: k,
        color: j,
        blending: i
    });
};
THREE.LensFlare.prototype.updateLensFlares = function () {
    var d, e = this.lensFlares.length, f, i = -this.positionScreen.x * 2, j = -this.positionScreen.y * 2;
    for (d = 0; d < e; d++) {
        f = this.lensFlares[d];
        f.x = this.positionScreen.x + i * f.distance;
        f.y = this.positionScreen.y + j * f.distance;
        f.wantedRotation = f.x * Math.PI * Z1e.k0;
        f.rotation += (f.wantedRotation - f.rotation) * Z1e.k0;
    }
};
THREE.LensFlare.prototype.copy = function (d) {
    THREE.Object3D.prototype.copy.call(this, d);
    this.positionScreen.copy(d.positionScreen);
    this.customUpdateCallback = d.customUpdateCallback;
    for (var e = 0, f = d.lensFlares.length; e < f; e++) {
        this.lensFlares.push(d.lensFlares[e]);
    }
    return this;
};
THREE.Scene = function () {
    THREE.Object3D.call(this);
    this.type = 'Scene';
    this.fog = Z1e.l3;
    this.overrideMaterial = Z1e.l3;
    this.overrideMaterialInst = Z1e.l3;
    this.autoUpdate = Z1e.n3;
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.constructor = THREE.Scene;
THREE.Scene.prototype.copy = function (d, e) {
    THREE.Object3D.prototype.copy.call(this, d, e);
    if (d.fog !== Z1e.l3) this.fog = d.fog.clone();
    if (d.overrideMaterial !== Z1e.l3) this.overrideMaterial = d.overrideMaterial.clone();
    if (d.overrideMaterialInst !== Z1e.l3) this.overrideMaterialInst = d.overrideMaterialInst.clone();
    this.autoUpdate = d.autoUpdate;
    this.matrixAutoUpdate = d.matrixAutoUpdate;
    return this;
};
THREE.Fog = function (d, e, f) {
    this.name = '';
    this.color = new THREE.Color(d);
    this.near = (e !== undefined) ? e : 1;
    this.far = (f !== undefined) ? f : 1000;
};
THREE.Fog.prototype.clone = function () {
    return new THREE.Fog(this.color.getHex(), this.near, this.far);
};
THREE.FogExp2 = function (d, e) {
    this.name = '';
    this.color = new THREE.Color(d);
    this.density = (e !== undefined) ? e : 0.00025;
};
THREE.FogExp2.prototype.clone = function () {
    return new THREE.FogExp2(this.color.getHex(), this.density);
};
THREE.ShaderChunk = {};
THREE.ShaderChunk['alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
THREE.ShaderChunk['alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n";
THREE.ShaderChunk['alphatest_fragment'] = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
THREE.ShaderChunk['aomap_fragment'] = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n";
THREE.ShaderChunk['aomap_pars_fragment'] = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
THREE.ShaderChunk['begin_vertex'] = "\n#ifdef INSTI\nmat4 matrix = mat4( vec4( mcol0, 0 ),vec4( mcol1, 0 ), vec4( mcol2, 0 ), vec4( mcol3, 1 ) );\nvec3 instpos = (matrix * vec4( position, 1.0 )).xyz;\nvec3 transformed = vec3( instpos );\n#else\nvec3 transformed = vec3( position );\n#endif\n#ifdef USE_COLOR_OPACITY\nopacity_v=color.a;\n#endif\n";
THREE.ShaderChunk['insti_paras_vertex'] = "#ifdef INSTI\nattribute vec3 mcol0;\nattribute vec3 mcol1;\nattribute vec3 mcol2;\nattribute vec3 mcol3;\n#endif\n#ifdef USE_COLOR_OPACITY\nvarying float opacity_v;\n#endif\n";
THREE.ShaderChunk['insti_paras_fragment'] = "\n #ifdef USE_COLOR\n varying float opacity_v;\n#endif \n";
THREE.ShaderChunk['beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";
THREE.ShaderChunk['bsdfs'] = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n		if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n			return distanceFalloff * maxDistanceCutoffFactor;\n#else\n			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n		}\n		return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
THREE.ShaderChunk['bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n";
THREE.ShaderChunk['clipping_planes_fragment'] = "#if NUM_CLIPPING_PLANES > 0\n	for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n		vec4 plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n#endif\n";
THREE.ShaderChunk['clipping_planes_pars_fragment'] = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
THREE.ShaderChunk['clipping_planes_pars_vertex'] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n";
THREE.ShaderChunk['clipping_planes_vertex'] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n";
THREE.ShaderChunk['color_fragment'] = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
THREE.ShaderChunk['color_pars_fragment'] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n";
THREE.ShaderChunk['color_pars_vertex'] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
THREE.ShaderChunk['color_vertex'] = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
THREE.ShaderChunk[Z1e.A3] = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";
THREE.ShaderChunk['cube_uv_reflection_fragment'] = "#ifdef ENVMAP_TYPE_CUBE_UV\nconst float cubeUV_textureSize = 1024.0;\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\nfloat cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\nfloat cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\nfloat cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\nfloat cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n";
THREE.ShaderChunk['defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
THREE.ShaderChunk['displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
THREE.ShaderChunk['displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n";
THREE.ShaderChunk['emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
THREE.ShaderChunk['emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n";
THREE.ShaderChunk[Z1e.E2] = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
THREE.ShaderChunk['encodings_fragment'] = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
THREE.ShaderChunk['envmap_fragment'] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n";
THREE.ShaderChunk['envmap_pars_fragment'] = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n";
THREE.ShaderChunk['envmap_pars_vertex'] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n";
THREE.ShaderChunk['envmap_vertex'] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n";
THREE.ShaderChunk['fog_fragment'] = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
THREE.ShaderChunk['fog_pars_fragment'] = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
THREE.ShaderChunk['lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
THREE.ShaderChunk['lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
THREE.ShaderChunk['lights_lambert_vertex'] = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n";
THREE.ShaderChunk['lights_pars'] = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n";
THREE.ShaderChunk['lights_phong_fragment'] = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
THREE.ShaderChunk['lights_phong_pars_fragment'] = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n";
THREE.ShaderChunk['lights_physical_fragment'] = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#endif\n";
THREE.ShaderChunk['lights_physical_pars_fragment'] = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n	#endif\n};\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
THREE.ShaderChunk['lights_template'] = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n";
THREE.ShaderChunk['logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
THREE.ShaderChunk['logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n";
THREE.ShaderChunk['logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif";
THREE.ShaderChunk['logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n";
THREE.ShaderChunk['map_fragment'] = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n";
THREE.ShaderChunk['map_pars_fragment'] = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n";
THREE.ShaderChunk['map_particle_fragment'] = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
THREE.ShaderChunk['map_particle_pars_fragment'] = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n";
THREE.ShaderChunk['metalnessmap_fragment'] = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n";
THREE.ShaderChunk['metalnessmap_pars_fragment'] = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
THREE.ShaderChunk['morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
THREE.ShaderChunk['morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
THREE.ShaderChunk['morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n";
THREE.ShaderChunk['normal_fragment'] = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#endif\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
THREE.ShaderChunk['normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n";
THREE.ShaderChunk['packing'] = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nvec4 packDepthToRGBA( const in float value ) {\n	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( value * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bit_mask;\n	return res;\n}\nfloat unpackRGBAToDepth( const in vec4 rgba ) {\n	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n	return dot( rgba, bitSh );\n}\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
THREE.ShaderChunk['premultiplied_alpha_fragment'] = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
THREE.ShaderChunk['project_vertex'] = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
THREE.ShaderChunk['roughnessmap_fragment'] = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n";
THREE.ShaderChunk['roughnessmap_pars_fragment'] = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
THREE.ShaderChunk['shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\n\t#if defined( SHADOWMAP_TYPE_PCSS )\n\t\t#define LIGHT_WORLD_SIZE 0.005\n\t\t#define LIGHT_FRUSTUM_WIDTH 3.75\n\t\t#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n\t\t#define NEAR_PLANE 9.5\n\n\t\t#define NUM_SAMPLES 17\n\t\t#define NUM_RINGS 11\n\t\t#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n\t\t#define PCF_NUM_SAMPLES NUM_SAMPLES\n\n\t\tvec2 poissonDisk[NUM_SAMPLES];\n\n\t\tvoid initPoissonSamples( const in vec2 randomSeed )\n\t\t{\n\t\t\tfloat ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n\t\t\tfloat INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n\t\t\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\n\t\t\tfloat radius = INV_NUM_SAMPLES;\n\t\t\tfloat radiusStep = radius;\n\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\t\t\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n\t\t\t\tradius += radiusStep;\n\t\t\t\tangle += ANGLE_STEP;\n\t\t\t}\n\t\t}\n\n\t\tfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n\t\t\treturn (zReceiver - zBlocker) / zBlocker;\n\t\t}\n\n\t\tfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n\t\t\t// This uses similar triangles to compute what\n\t\t\t// area of the shadow map we should search\n\t\t\tfloat searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\n\t\t\tfloat blockerDepthSum = 0.0;\n\t\t\tint numBlockers = 0;\n\n\t\t\tfor( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\n\t\t\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\t\t\tif ( shadowMapDepth < zReceiver ) {\n\t\t\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\t\t\tnumBlockers ++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( numBlockers == 0 ) return -1.0;\n\n\t\t\treturn blockerDepthSum / float( numBlockers );\n\t\t}\n\n\t\tfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\n\t\t\tfloat sum = 0.0;\n\t\t\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\n\t\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\n\t\t\t\tif( zReceiver <= depth ) sum += 1.0;\n\t\t\t}\n\t\t\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\n\t\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\n\t\t\t\tif( zReceiver <= depth ) sum += 1.0;\n\t\t\t}\n\t\t\treturn sum / ( 2.0 * float( PCF_NUM_SAMPLES ) );\n\t\t}\n\n\t\tfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\n\t\t\tvec2 uv = coords.xy;\n\t\t\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n\t\t\tinitPoissonSamples( uv );\n\t\t\t// STEP 1: blocker search\n\t\t\tfloat avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\n\n\t\t\t//There are no occluders so early out (this saves filtering)\n\t\t\tif( avgBlockerDepth == -1.0 ) return 1.0;\n\n\t\t\t// STEP 2: penumbra size\n\t\t\tfloat penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\n\t\t\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\n\t\t\t// STEP 3: filtering\n\t\t\t//return avgBlockerDepth;\n\t\t\treturn PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\n\t\t}\n\n\t#endif\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n\t\tvec2 f = fract( uv * size + 0.5 );\n\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\n\t\treturn c;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCSS )\n\t\t  return PCSS( shadowMap, shadowCoord);\n\t\t  return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn 1.0;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the distance from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t// dp = distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n";
THREE.ShaderChunk['shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n";
THREE.ShaderChunk['shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n";
THREE.ShaderChunk['shadowmask_pars_fragment'] = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n";
THREE.ShaderChunk['skinbase_vertex'] = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
THREE.ShaderChunk['skinning_pars_vertex'] = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n";
THREE.ShaderChunk['skinning_vertex'] = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n";
THREE.ShaderChunk['skinnormal_vertex'] = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
THREE.ShaderChunk['specularmap_fragment'] = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
THREE.ShaderChunk['specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
THREE.ShaderChunk['tonemapping_fragment'] = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
THREE.ShaderChunk[Z1e.B2] = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
THREE.ShaderChunk['uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
THREE.ShaderChunk['uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";
THREE.ShaderChunk['uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";
THREE.ShaderChunk['uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";
THREE.ShaderChunk['uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n";
THREE.ShaderChunk['uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
THREE.ShaderChunk['worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n";
THREE.UniformsUtils = {
    merge: function (d) {
        var e = {};
        for (var f = 0; f < d.length; f++) {
            var i = this.clone(d[f]);
            for (var j in i) {
                e[j] = i[j];
            }
        }
        return e;
    }, clone: function (d) {
        var e = {};
        for (var f in d) {
            e[f] = {};
            for (var i in d[f]) {
                var j = d[f][i];
                if (j instanceof THREE.Color || j instanceof THREE.Vector2 || j instanceof THREE.Vector3 || j instanceof THREE.Vector4 || j instanceof THREE.Matrix3 || j instanceof THREE.Matrix4 || j instanceof THREE.Texture) {
                    e[f][i] = j.clone();
                } else if (Array.isArray(j)) {
                    e[f][i] = j.slice();
                } else {
                    e[f][i] = j;
                }
            }
        }
        return e;
    }
};
THREE.UniformsLib = {
    common: {
        "diffuse": {type: Z1e.Q0, value: new THREE.Color(0xeeeeee)},
        "opacity": {type: Z1e.U1, value: Z1e.d4},
        "map": {type: Z1e.e2, value: Z1e.l3},
        "offsetRepeat": {type: "v4", value: new THREE.Vector4(0, 0, 1, 1)},
        "specularMap": {type: Z1e.e2, value: Z1e.l3},
        "alphaMap": {type: Z1e.e2, value: Z1e.l3},
        "envMap": {type: Z1e.e2, value: Z1e.l3},
        "flipEnvMap": {type: Z1e.U1, value: -1},
        "reflectivity": {type: Z1e.U1, value: Z1e.d4},
        "refractionRatio": {type: Z1e.U1, value: 0.98}
    },
    aomap: {"aoMap": {type: Z1e.e2, value: Z1e.l3}, "aoMapIntensity": {type: Z1e.U1, value: 1}},
    lightmap: {"lightMap": {type: Z1e.e2, value: Z1e.l3}, "lightMapIntensity": {type: Z1e.U1, value: 1}},
    emissivemap: {"emissiveMap": {type: Z1e.e2, value: Z1e.l3}},
    bumpmap: {"bumpMap": {type: Z1e.e2, value: Z1e.l3}, "bumpScale": {type: Z1e.U1, value: 1}},
    normalmap: {
        "normalMap": {type: Z1e.e2, value: Z1e.l3},
        "normalScale": {type: "v2", value: new THREE.Vector2(1, 1)}
    },
    displacementmap: {
        "displacementMap": {type: Z1e.e2, value: Z1e.l3},
        "displacementScale": {type: Z1e.U1, value: 1},
        "displacementBias": {type: Z1e.U1, value: 0}
    },
    roughnessmap: {"roughnessMap": {type: Z1e.e2, value: Z1e.l3}},
    metalnessmap: {"metalnessMap": {type: Z1e.e2, value: Z1e.l3}},
    fog: {
        "fogDensity": {type: Z1e.U1, value: 0.00025},
        "fogNear": {type: Z1e.U1, value: 1},
        "fogFar": {type: Z1e.U1, value: 2000},
        "fogColor": {type: Z1e.Q0, value: new THREE.Color(0xffffff)}
    },
    lights: {
        "ambientLightColor": {type: "3fv", value: []},
        "directionalLights": {
            type: Z1e.O,
            value: [],
            properties: {
                "direction": {type: "v3"},
                "color": {type: Z1e.Q0},
                "shadow": {type: "1i"},
                "shadowBias": {type: Z1e.U1},
                "shadowRadius": {type: Z1e.U1},
                "shadowMapSize": {type: "v2"}
            }
        },
        "directionalShadowMap": {type: "tv", value: []},
        "directionalShadowMatrix": {type: "m4v", value: []},
        "spotLights": {
            type: Z1e.O,
            value: [],
            properties: {
                "color": {type: Z1e.Q0},
                "position": {type: "v3"},
                "direction": {type: "v3"},
                "distance": {type: Z1e.U1},
                "coneCos": {type: Z1e.U1},
                "penumbraCos": {type: Z1e.U1},
                "decay": {type: Z1e.U1},
                "shadow": {type: "1i"},
                "shadowBias": {type: Z1e.U1},
                "shadowRadius": {type: Z1e.U1},
                "shadowMapSize": {type: "v2"}
            }
        },
        "spotShadowMap": {type: "tv", value: []},
        "spotShadowMatrix": {type: "m4v", value: []},
        "pointLights": {
            type: Z1e.O,
            value: [],
            properties: {
                "color": {type: Z1e.Q0},
                "position": {type: "v3"},
                "decay": {type: Z1e.U1},
                "distance": {type: Z1e.U1},
                "shadow": {type: "1i"},
                "shadowBias": {type: Z1e.U1},
                "shadowRadius": {type: Z1e.U1},
                "shadowMapSize": {type: "v2"}
            }
        },
        "pointShadowMap": {type: "tv", value: []},
        "pointShadowMatrix": {type: "m4v", value: []},
        "hemisphereLights": {
            type: Z1e.O,
            value: [],
            properties: {"direction": {type: "v3"}, "skyColor": {type: Z1e.Q0}, "groundColor": {type: Z1e.Q0}}
        }
    },
    points: {
        "diffuse": {type: Z1e.Q0, value: new THREE.Color(0xeeeeee)},
        "opacity": {type: Z1e.U1, value: Z1e.d4},
        "size": {type: Z1e.U1, value: Z1e.d4},
        "scale": {type: Z1e.U1, value: Z1e.d4},
        "map": {type: Z1e.e2, value: Z1e.l3},
        "offsetRepeat": {type: "v4", value: new THREE.Vector4(0, 0, 1, 1)}
    }
};
THREE.ShaderChunk['cube_frag'] = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	#include <logdepthbuf_fragment>\n}\n";
THREE.ShaderChunk[Z1e.Q] = Z1e.g0;
THREE.ShaderChunk['depth_frag'] = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n";
THREE.ShaderChunk['depth_vert'] = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk[Z1e.j0] = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
THREE.ShaderChunk[Z1e.U] = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition;\n}\n";
THREE.ShaderChunk[Z1e.Y2] = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <logdepthbuf_fragment>\n}\n";
THREE.ShaderChunk[Z1e.S3] = Z1e.g0;
THREE.ShaderChunk[Z1e.A1] = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
THREE.ShaderChunk[Z1e.V] = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk[Z1e.I0] = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <insti_paras_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#ifdef USE_COLOR_OPACITY\n	vec4 diffuseColor = vec4( diffuse, opacity_v );\n	#else\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight;\n	reflectedLight.directDiffuse = vec3( 0.0 );\n	reflectedLight.directSpecular = vec3( 0.0 );\n	reflectedLight.indirectDiffuse = diffuseColor.rgb;\n	reflectedLight.indirectSpecular = vec3( 0.0 );\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
THREE.ShaderChunk[Z1e.D1] = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <insti_paras_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n}\n";
THREE.ShaderChunk[Z1e.F1] = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <insti_paras_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#ifdef USE_COLOR_OPACITY\n	vec4 diffuseColor = vec4( diffuse, opacity_v );\n	#else\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#endif\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
THREE.ShaderChunk[Z1e.T1] = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <insti_paras_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk[Z1e.o3] = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
THREE.ShaderChunk[Z1e.Z3] = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk[Z1e.R0] = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
THREE.ShaderChunk[Z1e.b4] = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk[Z1e.O0] = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n	#include <logdepthbuf_fragment>\n}\n";
THREE.ShaderChunk[Z1e.N1] = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vNormal = normalize( normalMatrix * normal );\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk[Z1e.B0] = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";
THREE.ShaderChunk[Z1e.t4] = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";
THREE.ShaderLib = {
    'basic': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[Z1e.A3], THREE.UniformsLib[Z1e.u4], THREE.UniformsLib[Z1e.T0]]),
        vertexShader: THREE.ShaderChunk[Z1e.D1],
        fragmentShader: THREE.ShaderChunk[Z1e.I0]
    },
    'lambert': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[Z1e.A3], THREE.UniformsLib[Z1e.u4], THREE.UniformsLib[Z1e.Q1], THREE.UniformsLib[Z1e.J], THREE.UniformsLib[Z1e.T0], THREE.UniformsLib[Z1e.W2], {
            "emissive": {
                type: Z1e.Q0,
                value: new THREE.Color(0x000000)
            }
        }]), vertexShader: THREE.ShaderChunk[Z1e.T1], fragmentShader: THREE.ShaderChunk[Z1e.F1]
    },
    'phong': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[Z1e.A3], THREE.UniformsLib[Z1e.u4], THREE.UniformsLib[Z1e.Q1], THREE.UniformsLib[Z1e.J], THREE.UniformsLib['bumpmap'], THREE.UniformsLib['normalmap'], THREE.UniformsLib[Z1e.A0], THREE.UniformsLib[Z1e.T0], THREE.UniformsLib[Z1e.W2], {
            "emissive": {
                type: Z1e.Q0,
                value: new THREE.Color(0x000000)
            }, "specular": {type: Z1e.Q0, value: new THREE.Color(0x111111)}, "shininess": {type: Z1e.U1, value: 30}
        }]), vertexShader: THREE.ShaderChunk[Z1e.Z3], fragmentShader: THREE.ShaderChunk[Z1e.o3]
    },
    'standard': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[Z1e.A3], THREE.UniformsLib[Z1e.u4], THREE.UniformsLib[Z1e.Q1], THREE.UniformsLib[Z1e.J], THREE.UniformsLib['bumpmap'], THREE.UniformsLib['normalmap'], THREE.UniformsLib[Z1e.A0], THREE.UniformsLib['roughnessmap'], THREE.UniformsLib['metalnessmap'], THREE.UniformsLib[Z1e.T0], THREE.UniformsLib[Z1e.W2], {
            "emissive": {
                type: Z1e.Q0,
                value: new THREE.Color(0x000000)
            },
            "roughness": {type: Z1e.U1, value: Z1e.k1},
            "metalness": {type: Z1e.U1, value: 0},
            "envMapIntensity": {type: Z1e.U1, value: 1}
        }]), vertexShader: THREE.ShaderChunk[Z1e.b4], fragmentShader: THREE.ShaderChunk[Z1e.R0]
    },
    'points': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib['points'], THREE.UniformsLib[Z1e.T0]]),
        vertexShader: THREE.ShaderChunk[Z1e.t4],
        fragmentShader: THREE.ShaderChunk[Z1e.B0]
    },
    'dashed': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[Z1e.A3], THREE.UniformsLib[Z1e.T0], {
            "scale": {
                type: Z1e.U1,
                value: 1
            }, "dashSize": {type: Z1e.U1, value: 1}, "totalSize": {type: Z1e.U1, value: 2}
        }]), vertexShader: THREE.ShaderChunk[Z1e.V], fragmentShader: THREE.ShaderChunk[Z1e.A1]
    },
    'depth': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[Z1e.A3], THREE.UniformsLib[Z1e.A0]]),
        vertexShader: THREE.ShaderChunk['depth_vert'],
        fragmentShader: THREE.ShaderChunk['depth_frag']
    },
    'normal': {
        uniforms: {"opacity": {type: Z1e.U1, value: Z1e.d4}},
        vertexShader: THREE.ShaderChunk[Z1e.N1],
        fragmentShader: THREE.ShaderChunk[Z1e.O0]
    },
    'cube': {
        uniforms: {"tCube": {type: Z1e.e2, value: Z1e.l3}, "tFlip": {type: Z1e.U1, value: -1}},
        vertexShader: THREE.ShaderChunk[Z1e.Q],
        fragmentShader: THREE.ShaderChunk['cube_frag']
    },
    'equirect': {
        uniforms: {"tEquirect": {type: Z1e.e2, value: Z1e.l3}, "tFlip": {type: Z1e.U1, value: -1}},
        vertexShader: THREE.ShaderChunk[Z1e.S3],
        fragmentShader: THREE.ShaderChunk[Z1e.Y2]
    },
    'distanceRGBA': {
        uniforms: {"lightPos": {type: "v3", value: new THREE.Vector3()}},
        vertexShader: THREE.ShaderChunk[Z1e.U],
        fragmentShader: THREE.ShaderChunk[Z1e.j0]
    }
};
THREE.ShaderLib[Z1e.W] = {
    uniforms: THREE.UniformsUtils.merge([THREE.ShaderLib['standard'].uniforms, {}]),
    vertexShader: THREE.ShaderChunk[Z1e.b4],
    fragmentShader: THREE.ShaderChunk[Z1e.R0]
};
THREE.WebGLRenderer = function (m0) {
    var W0 = '). Resized to ', y0 = 'morphNormal', P0 = 'morphTarget', M0 = 'OES_texture_half_float_linear',
        G0 = 'OES_texture_float_linear', a1 = 'webglcontextlost';
    console.log('THREE.WebGLRenderer', THREE.REVISION);
    m0 = m0 || {};
    var b1 = m0.canvas !== undefined ? m0.canvas : document.createElement(Z1e.M),
        X0 = m0.context !== undefined ? m0.context : Z1e.l3, o1 = m0.alpha !== undefined ? m0.alpha : Z1e.e4,
        z0 = m0.depth !== undefined ? m0.depth : Z1e.n3, Z0 = m0.stencil !== undefined ? m0.stencil : Z1e.n3,
        q1 = m0.antialias !== undefined ? m0.antialias : Z1e.e4,
        t1 = m0.premultipliedAlpha !== undefined ? m0.premultipliedAlpha : Z1e.n3,
        s1 = m0.preserveDrawingBuffer !== undefined ? m0.preserveDrawingBuffer : Z1e.e4, z1 = [], w1 = [], u1 = -1,
        L1 = [], S1 = -1, y1 = new Float32Array(8), a2 = [], P1 = [];
    this.domElement = b1;
    this.context = Z1e.l3;
    this.autoClear = Z1e.n3;
    this.autoClearColor = Z1e.n3;
    this.autoClearDepth = Z1e.n3;
    this.autoClearStencil = Z1e.n3;
    this.sortObjects = Z1e.n3;
    this.clippingPlanes = [];
    this.localClippingEnabled = Z1e.e4;
    this.gammaFactor = 2.0;
    this.gammaInput = Z1e.e4;
    this.gammaOutput = Z1e.e4;
    this.physicallyCorrectLights = Z1e.e4;
    this.toneMapping = THREE.LinearToneMapping;
    this.toneMappingExposure = Z1e.d4;
    this.toneMappingWhitePoint = Z1e.d4;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    this.autoScaleCubemaps = Z1e.n3;
    var B1 = this, p2 = Z1e.l3, K2 = Z1e.l3, h1 = Z1e.l3, t2 = -1, f2 = '', x2 = Z1e.l3, P2 = new THREE.Vector4(),
        H2 = Z1e.l3, n1 = new THREE.Vector4(), l2 = 0, r2 = new THREE.Color(0x000000), y2 = 0, m3 = b1.width,
        Z2 = b1.height, N2 = 1, d3 = new THREE.Vector4(0, 0, m3, Z2), s3 = Z1e.e4, j3 = new THREE.Vector4(0, 0, m3, Z2),
        g4 = new THREE.Frustum(), g3 = Z1e.e4, E3 = Z1e.e4, Q3 = Z1e.e4, K3 = 0,
        x3 = {type: '4fv', value: Z1e.l3, needsUpdate: Z1e.e4}, i4 = Z1e.l3, t3 = 0, W4 = new THREE.Matrix3(),
        X5 = new THREE.Sphere(), k5 = new THREE.Plane(), v4 = new THREE.Matrix4(), e3 = new THREE.Vector3(), h2 = {
            hash: '',
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            shadows: []
        }, r4 = {geometries: 0, textures: 0}, p4 = {calls: 0, vertices: 0, faces: 0, points: 0};
    this.info = {render: p4, memory: r4, programs: Z1e.l3};
    var p0;
    try {
        var Y5 = {alpha: o1, depth: z0, stencil: Z0, antialias: q1, premultipliedAlpha: t1, preserveDrawingBuffer: s1};
        p0 = X0 || b1.getContext('webgl', Y5) || b1.getContext('experimental-webgl', Y5);
        if (p0 === Z1e.l3) {
            if (b1.getContext('webgl') !== Z1e.l3) {
                throw 'Error creating WebGL context with your selected attributes.';
            } else {
                throw 'Error creating WebGL context.';
            }
        }
        if (p0.getShaderPrecisionFormat === undefined) {
            p0.getShaderPrecisionFormat = function () {
                return {'rangeMin': 1, 'rangeMax': 1, 'precision': 1};
            };
        }
        b1.addEventListener(a1, a6, Z1e.e4);
    } catch (d) {
        console.error(Z1e.R + d);
    }
    var Z5 = (typeof WebGL2RenderingContext !== Z1e.O1 && p0 instanceof WebGL2RenderingContext),
        z2 = new THREE.WebGLExtensions(p0);
    z2.get(Z1e.G3);
    z2.get(Z1e.a0);
    z2.get(G0);
    z2.get(Z1e.P);
    z2.get(M0);
    z2.get(Z1e.J3);
    z2.get(Z1e.X2);
    if (z2.get(Z1e.h4)) {
        THREE.BufferGeometry.MaxIndex = 4294967296;
    }
    var X3 = new THREE.WebGLCapabilities(p0, z2, m0), p1 = new THREE.WebGLState(p0, z2, i3),
        w2 = new THREE.WebGLProperties(), d5 = new THREE.WebGLObjects(p0, w2, this.info),
        c5 = new THREE.WebGLPrograms(this, X3), l5 = new THREE.WebGLLights();
    this.info.programs = c5.programs;
    var B6 = new THREE.WebGLBufferRenderer(p0, z2, p4), A6 = new THREE.WebGLIndexedBufferRenderer(p0, z2, p4);
    function d6() {
        return K2 === Z1e.l3 ? N2 : 1;
    }
    function N5(d, e, f, i) {
        if (t1 === Z1e.n3) {
            d *= i;
            e *= i;
            f *= i;
        }
        p1.clearColor(d, e, f, i);
    }
    function e6() {
        p1.init();
        p1.scissor(P2.copy(d3).multiplyScalar(N2));
        p1.viewport(n1.copy(j3).multiplyScalar(N2));
        N5(r2.r, r2.g, r2.b, y2);
    }
    function g6() {
        p2 = Z1e.l3;
        x2 = Z1e.l3;
        f2 = '';
        t2 = -1;
        p1.reset();
    }
    e6();
    this.context = p0;
    this.capabilities = X3;
    this.extensions = z2;
    this.properties = w2;
    this.state = p1;
    var f6 = new THREE.WebGLShadowMap(this, h2, d5);
    this.shadowMap = f6;
    var D6 = new THREE.SpritePlugin(this, a2), C6 = new THREE.LensFlarePlugin(this, P1);
    this.getContext = function () {
        return p0;
    };
    this.getContextAttributes = function () {
        return p0.getContextAttributes();
    };
    this.forceContextLoss = function () {
        z2.get('WEBGL_lose_context').loseContext();
    };
    this.getMaxAnisotropy = (function () {
        var e;
        return function f() {
            if (e !== undefined)return e;
            var d = z2.get(Z1e.n0);
            if (d !== Z1e.l3) {
                e = p0.getParameter(d.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else {
                e = 0;
            }
            return e;
        };
    })();
    this.getPrecision = function () {
        return X3.precision;
    };
    this.getPixelRatio = function () {
        return N2;
    };
    this.setPixelRatio = function (d) {
        if (d === undefined)return;
        N2 = d;
        this.setSize(j3.z, j3.w, Z1e.e4);
    };
    this.getSize = function () {
        return {width: m3, height: Z2};
    };
    this.setSize = function (d, e, f) {
        m3 = d;
        Z2 = e;
        b1.width = d * N2;
        b1.height = e * N2;
        if (f !== Z1e.e4) {
            b1.style.width = d + 'px';
            b1.style.height = e + 'px';
        }
        this.setViewport(0, 0, d, e);
    };
    this.setViewport = function (d, e, f, i) {
        p1.viewport(j3.set(d, e, f, i));
    };
    this.setScissor = function (d, e, f, i) {
        p1.scissor(d3.set(d, e, f, i));
    };
    this.setScissorTest = function (d) {
        p1.setScissorTest(s3 = d);
    };
    this.getClearColor = function () {
        return r2;
    };
    this.setClearColor = function (d, e) {
        r2.set(d);
        y2 = e !== undefined ? e : 1;
        N5(r2.r, r2.g, r2.b, y2);
    };
    this.getClearAlpha = function () {
        return y2;
    };
    this.setClearAlpha = function (d) {
        y2 = d;
        N5(r2.r, r2.g, r2.b, y2);
    };
    this.clear = function (d, e, f) {
        var i = 0;
        if (d === undefined || d) i |= p0.COLOR_BUFFER_BIT;
        if (e === undefined || e) i |= p0.DEPTH_BUFFER_BIT;
        if (f === undefined || f) i |= p0.STENCIL_BUFFER_BIT;
        p0.clear(i);
    };
    this.clearColor = function () {
        this.clear(Z1e.n3, Z1e.e4, Z1e.e4);
    };
    this.clearDepth = function () {
        this.clear(Z1e.e4, Z1e.n3, Z1e.e4);
    };
    this.clearStencil = function () {
        this.clear(Z1e.e4, Z1e.e4, Z1e.n3);
    };
    this.clearTarget = function (d, e, f, i) {
        this.setRenderTarget(d);
        this.clear(e, f, i);
    };
    this.resetGLState = g6;
    this.dispose = function () {
        b1.removeEventListener(a1, a6, Z1e.e4);
    };
    function a6(d) {
        d.preventDefault();
        g6();
        e6();
        w2.clear();
    }
    function M5(d) {
        var e = d.target;
        e.removeEventListener(Z1e.L0, M5);
        G6(e);
        r4.textures--;
    }
    function c6(d) {
        var e = d.target;
        e.removeEventListener(Z1e.L0, c6);
        F6(e);
        r4.textures--;
    }
    function b6(d) {
        var e = d.target;
        e.removeEventListener(Z1e.L0, b6);
        E6(e);
    }
    function G6(d) {
        var e = w2.get(d);
        if (d.image && e.__image__webglTextureCube) {
            p0.deleteTexture(e.__image__webglTextureCube);
        } else {
            if (e.__webglInit === undefined)return;
            p0.deleteTexture(e.__webglTexture);
        }
        w2.delete(d);
    }
    function F6(d) {
        var e = w2.get(d), f = w2.get(d.texture);
        if (!d)return;
        if (f.__webglTexture !== undefined) {
            p0.deleteTexture(f.__webglTexture);
        }
        if (d.depthTexture) {
            d.depthTexture.dispose();
        }
        if (d instanceof THREE.WebGLRenderTargetCube) {
            for (var i = 0; i < 6; i++) {
                p0.deleteFramebuffer(e.__webglFramebuffer[i]);
                if (e.__webglDepthbuffer) p0.deleteRenderbuffer(e.__webglDepthbuffer[i]);
            }
        } else {
            p0.deleteFramebuffer(e.__webglFramebuffer);
            if (e.__webglDepthbuffer) p0.deleteRenderbuffer(e.__webglDepthbuffer);
        }
        w2.delete(d.texture);
        w2.delete(d);
    }
    function E6(d) {
        j6(d);
        w2.delete(d);
    }
    function j6(d) {
        var e = w2.get(d).program;
        d.program = undefined;
        if (e !== undefined) {
            c5.releaseProgram(e);
        }
    }
    this.renderBufferImmediate = function (d, e, f) {
        p1.initAttributes();
        var i = w2.get(d);
        if (d.hasPositions && !i.position) i.position = p0.createBuffer();
        if (d.hasNormals && !i.normal) i.normal = p0.createBuffer();
        if (d.hasUvs && !i.uv) i.uv = p0.createBuffer();
        if (d.hasColors && !i.color) i.color = p0.createBuffer();
        var j = e.getAttributes();
        if (d.hasPositions) {
            p0.bindBuffer(p0.ARRAY_BUFFER, i.position);
            p0.bufferData(p0.ARRAY_BUFFER, d.positionArray, p0.DYNAMIC_DRAW);
            p1.enableAttribute(j.position);
            p0.vertexAttribPointer(j.position, 3, p0.FLOAT, Z1e.e4, 0, 0);
        }
        if (d.hasNormals) {
            p0.bindBuffer(p0.ARRAY_BUFFER, i.normal);
            if (f.type !== Z1e.C3 && f.type !== Z1e.B3 && f.type !== Z1e.a3 && f.shading === THREE.FlatShading) {
                for (var k = 0, m = d.count * 3; k < m; k += 9) {
                    var n = d.normalArray, u = (n[k + 0] + n[k + 3] + n[k + 6]) / 3,
                        v = (n[k + 1] + n[k + 4] + n[k + 7]) / 3, B = (n[k + 2] + n[k + 5] + n[k + 8]) / 3;
                    n[k + 0] = u;
                    n[k + 1] = v;
                    n[k + 2] = B;
                    n[k + 3] = u;
                    n[k + 4] = v;
                    n[k + 5] = B;
                    n[k + 6] = u;
                    n[k + 7] = v;
                    n[k + 8] = B;
                }
            }
            p0.bufferData(p0.ARRAY_BUFFER, d.normalArray, p0.DYNAMIC_DRAW);
            p1.enableAttribute(j.normal);
            p0.vertexAttribPointer(j.normal, 3, p0.FLOAT, Z1e.e4, 0, 0);
        }
        if (d.hasUvs && f.map) {
            p0.bindBuffer(p0.ARRAY_BUFFER, i.uv);
            p0.bufferData(p0.ARRAY_BUFFER, d.uvArray, p0.DYNAMIC_DRAW);
            p1.enableAttribute(j.uv);
            p0.vertexAttribPointer(j.uv, 2, p0.FLOAT, Z1e.e4, 0, 0);
        }
        if (d.hasColors && f.vertexColors !== THREE.NoColors) {
            p0.bindBuffer(p0.ARRAY_BUFFER, i.color);
            p0.bufferData(p0.ARRAY_BUFFER, d.colorArray, p0.DYNAMIC_DRAW);
            p1.enableAttribute(j.color);
            p0.vertexAttribPointer(j.color, 3, p0.FLOAT, Z1e.e4, 0, 0);
        }
        p1.disableUnusedAttributes();
        p0.drawArrays(p0.TRIANGLES, 0, d.count);
        d.count = 0;
    };
    this.renderBufferDirect = function (d, e, f, i, j, k) {
        m6(i);
        var m = n6(d, e, i, j), n = Z1e.e4, u = f.id + '_' + m.id + '_' + i.wireframe;
        if (u !== f2) {
            f2 = u;
            n = Z1e.n3;
        }
        var v = j.morphTargetInfluences;
        if (v !== undefined) {
            var B = [];
            for (var C = 0, G = v.length; C < G; C++) {
                var L = v[C];
                B.push([L, C]);
            }
            B.sort(U6);
            if (B.length > 8) {
                B.length = 8;
            }
            var N = f.morphAttributes;
            for (var C = 0, G = B.length; C < G; C++) {
                var L = B[C];
                y1[C] = L[0];
                if (L[0] !== 0) {
                    var T = L[1];
                    if (i.morphTargets === Z1e.n3 && N.position) f.addAttribute(P0 + C, N.position[T]);
                    if (i.morphNormals === Z1e.n3 && N.normal) f.addAttribute(y0 + C, N.normal[T]);
                } else {
                    if (i.morphTargets === Z1e.n3) f.removeAttribute(P0 + C);
                    if (i.morphNormals === Z1e.n3) f.removeAttribute(y0 + C);
                }
            }
            m.getUniforms().setValue(p0, 'morphTargetInfluences', y1);
            n = Z1e.n3;
        }
        var T = f.index, S = f.attributes.position;
        if (i.wireframe === Z1e.n3) {
            T = d5.getWireframeAttribute(f);
        }
        var b0;
        if (T !== Z1e.l3) {
            b0 = A6;
            b0.setIndex(T);
        } else {
            b0 = B6;
        }
        if (n) {
            T6(i, m, f);
            if (T !== Z1e.l3) {
                p0.bindBuffer(p0.ELEMENT_ARRAY_BUFFER, d5.getAttributeBuffer(T));
            }
        }
        var h0 = 0, f0 = Infinity;
        if (T !== Z1e.l3) {
            f0 = T.count;
        } else if (S !== undefined) {
            f0 = S.count;
        }
        var i0 = f.drawRange.start, s0 = f.drawRange.count, t0 = k !== Z1e.l3 ? k.start : 0,
            o0 = k !== Z1e.l3 ? k.count : Infinity, w0 = Math.max(h0, i0, t0),
            x0 = Math.min(h0 + f0, i0 + s0, t0 + o0) - 1, D0 = Math.max(0, x0 - w0 + 1);
        if (j instanceof THREE.Mesh) {
            if (i.wireframe === Z1e.n3) {
                p1.setLineWidth(i.wireframeLinewidth * d6());
                b0.setMode(p0.LINES);
            } else {
                switch (j.drawMode) {
                    case THREE.TrianglesDrawMode:
                        b0.setMode(p0.TRIANGLES);
                        break;
                    case THREE.TriangleStripDrawMode:
                        b0.setMode(p0.TRIANGLE_STRIP);
                        break;
                    case THREE.TriangleFanDrawMode:
                        b0.setMode(p0.TRIANGLE_FAN);
                        break;
                }
            }
        } else if (j instanceof THREE.Line) {
            var F0 = i.linewidth;
            if (F0 === undefined) F0 = 1;
            p1.setLineWidth(F0 * d6());
            if (j instanceof THREE.LineSegments) {
                b0.setMode(p0.LINES);
            } else {
                b0.setMode(p0.LINE_STRIP);
            }
        } else if (j instanceof THREE.Points) {
            b0.setMode(p0.POINTS);
        }
        if (f instanceof THREE.InstancedBufferGeometry) {
            if (f.maxInstancedCount > 0) {
                b0.renderInstances(f, w0, D0);
            }
        } else {
            b0.render(w0, D0);
        }
    };
    function T6(d, e, f, i) {
        var j;
        if (f instanceof THREE.InstancedBufferGeometry) {
            j = z2.get(Z1e.X2);
            if (j === Z1e.l3) {
                console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        if (i === undefined) i = 0;
        p1.initAttributes();
        var k = f.attributes, m = e.getAttributes(), n = d.defaultAttributeValues;
        for (var u in m) {
            var v = m[u];
            if (v >= 0) {
                var B = k[u];
                if (B !== undefined) {
                    var C = p0.FLOAT, G = B.array, L = B.normalized;
                    if (G instanceof Float32Array) {
                        C = p0.FLOAT;
                    } else if (G instanceof Float64Array) {
                        console.warn("Unsupported data buffer format: Float64Array");
                    } else if (G instanceof Uint16Array) {
                        C = p0.UNSIGNED_SHORT;
                    } else if (G instanceof Int16Array) {
                        C = p0.SHORT;
                    } else if (G instanceof Uint32Array) {
                        C = p0.UNSIGNED_INT;
                    } else if (G instanceof Int32Array) {
                        C = p0.INT;
                    } else if (G instanceof Int8Array) {
                        C = p0.BYTE;
                    } else if (G instanceof Uint8Array) {
                        C = p0.UNSIGNED_BYTE;
                    }
                    var N = B.itemSize, T = d5.getAttributeBuffer(B);
                    if (B instanceof THREE.InterleavedBufferAttribute) {
                        var S = B.data, b0 = S.stride, h0 = B.offset;
                        if (S instanceof THREE.InstancedInterleavedBuffer) {
                            p1.enableAttributeAndDivisor(v, S.meshPerAttribute, j);
                            if (f.maxInstancedCount === undefined) {
                                f.maxInstancedCount = S.meshPerAttribute * S.count;
                            }
                        } else {
                            p1.enableAttribute(v);
                        }
                        p0.bindBuffer(p0.ARRAY_BUFFER, T);
                        p0.vertexAttribPointer(v, N, C, L, b0 * S.array.BYTES_PER_ELEMENT, (i * b0 + h0) * S.array.BYTES_PER_ELEMENT);
                    } else {
                        if (B instanceof THREE.InstancedBufferAttribute) {
                            p1.enableAttributeAndDivisor(v, B.meshPerAttribute, j);
                            if (f.maxInstancedCount === undefined) {
                                f.maxInstancedCount = B.meshPerAttribute * B.count;
                            }
                        } else {
                            p1.enableAttribute(v);
                        }
                        p0.bindBuffer(p0.ARRAY_BUFFER, T);
                        p0.vertexAttribPointer(v, N, C, L, 0, i * N * B.array.BYTES_PER_ELEMENT);
                    }
                } else if (n !== undefined) {
                    var f0 = n[u];
                    if (f0 !== undefined) {
                        switch (f0.length) {
                            case 2:
                                p0.vertexAttrib2fv(v, f0);
                                break;
                            case 3:
                                p0.vertexAttrib3fv(v, f0);
                                break;
                            case 4:
                                p0.vertexAttrib4fv(v, f0);
                                break;
                            default:
                                p0.vertexAttrib1fv(v, f0);
                        }
                    }
                }
            }
        }
        p1.disableUnusedAttributes();
    }
    function U6(d, e) {
        return Math.abs(e[0]) - Math.abs(d[0]);
    }
    function V6(d, e) {
        if (d.object.renderOrder !== e.object.renderOrder) {
            return d.object.renderOrder - e.object.renderOrder;
        } else if (d.material.id !== e.material.id) {
            return d.material.id - e.material.id;
        } else if (d.z !== e.z) {
            return d.z - e.z;
        } else {
            return d.id - e.id;
        }
    }
    function W6(d, e) {
        if (d.object.renderOrder !== e.object.renderOrder) {
            return d.object.renderOrder - e.object.renderOrder;
        }
        if (d.z !== e.z) {
            return e.z - d.z;
        } else {
            return d.id - e.id;
        }
    }
    this.render = function (d, e, f, i) {
        if (e instanceof THREE.Camera === Z1e.e4) {
            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
            return;
        }
        var j = d.fog;
        f2 = '';
        t2 = -1;
        x2 = Z1e.l3;
        if (d.autoUpdate === Z1e.n3) d.updateMatrixWorld();
        if (e.parent === Z1e.l3) e.updateMatrixWorld();
        e.matrixWorldInverse.getInverse(e.matrixWorld);
        v4.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse);
        g4.setFromMatrix(v4);
        z1.length = 0;
        u1 = -1;
        S1 = -1;
        a2.length = 0;
        P1.length = 0;
        O6(this.clippingPlanes, e);
        l6(d, e);
        w1.length = u1 + 1;
        L1.length = S1 + 1;
        if (B1.sortObjects === Z1e.n3) {
            w1.sort(V6);
            L1.sort(W6);
        }
        if (g3) {
            Q3 = Z1e.n3;
            m5(Z1e.l3);
        }
        M6(z1);
        f6.render(d, e);
        P6(z1, e);
        if (g3) {
            Q3 = Z1e.e4;
            i6();
        }
        p4.calls = 0;
        p4.vertices = 0;
        p4.faces = 0;
        p4.points = 0;
        if (f === undefined) {
            f = Z1e.l3;
        }
        this.setRenderTarget(f);
        if (this.autoClear || i) {
            this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
        if (d.overrideMaterial) {
            var k = d.overrideMaterial, m = d.overrideMaterialInst;
            p5(w1, e, j, k, m);
            p5(L1, e, j, k, m);
        } else {
            p1.setBlending(THREE.NoBlending);
            p5(w1, e, j);
            p5(L1, e, j);
        }
        D6.render(d, e);
        C6.render(d, e, n1);
        if (f) {
            var n = f.texture;
            if (n.generateMipmaps && s5(f) && n.minFilter !== THREE.NearestFilter && n.minFilter !== THREE.LinearFilter) {
                g7(f);
            }
        }
        p1.setDepthTest(Z1e.n3);
        p1.setDepthWrite(Z1e.n3);
        p1.setColorWrite(Z1e.n3);
    };
    function P5(d, e, f, i, j) {
        var k, m;
        if (f.mix == Z1e.n3) {
            k = w1;
            m = ++u1;
        } else if (f.transparent) {
            k = L1;
            m = ++S1;
        } else {
            k = w1;
            m = ++u1;
        }
        var n = k[m];
        if (n !== undefined) {
            n.id = d.id;
            n.object = d;
            n.geometry = e;
            n.material = f;
            n.z = e3.z;
            n.group = j;
        } else {
            n = {id: d.id, object: d, geometry: e, material: f, z: e3.z, group: j};
            k.push(n);
        }
    }
    function k6(d) {
        var e = d.geometry;
        if (e.boundingSphere === Z1e.l3) e.computeBoundingSphere();
        var f = X5.copy(e.boundingSphere).applyMatrix4(d.matrixWorld);
        if (!g4.intersectsSphere(f))return Z1e.e4;
        if (K3 === 0)return Z1e.n3;
        var i = B1.clippingPlanes, j = f.center, k = -f.radius, m = 0;
        do {
            if (i[m].distanceToPoint(j) < k)return Z1e.e4;
        } while (++m !== K3);
        return Z1e.n3;
    }
    function l6(d, e) {
        if (d.visible === Z1e.e4)return;
        if (d.layers.test(e.layers)) {
            if (d instanceof THREE.Light) {
                z1.push(d);
            } else if (d instanceof THREE.Sprite) {
                if (d.frustumCulled === Z1e.e4 || k6(d) === Z1e.n3) {
                    a2.push(d);
                }
            } else if (d instanceof THREE.LensFlare) {
                P1.push(d);
            } else if (d instanceof THREE.ImmediateRenderObject) {
                if (B1.sortObjects === Z1e.n3) {
                    e3.setFromMatrixPosition(d.matrixWorld);
                    e3.applyProjection(v4);
                }
                P5(d, Z1e.l3, d.material, e3.z, Z1e.l3);
            } else if (d instanceof THREE.Mesh || d instanceof THREE.Line || d instanceof THREE.Points) {
                if (d instanceof THREE.SkinnedMesh) {
                    d.skeleton.update();
                }
                if (d.frustumCulled === Z1e.e4 || k6(d) === Z1e.n3) {
                    var f = d.material;
                    if (f.visible === Z1e.n3) {
                        if (B1.sortObjects === Z1e.n3) {
                            e3.setFromMatrixPosition(d.matrixWorld);
                            e3.applyProjection(v4);
                        }
                        var i = d5.update(d);
                        if (f instanceof THREE.MultiMaterial) {
                            var j = i.groups, k = f.materials;
                            for (var m = 0, n = j.length; m < n; m++) {
                                var u = j[m], v = k[u.materialIndex];
                                if (v.visible === Z1e.n3) {
                                    P5(d, i, v, e3.z, u);
                                }
                            }
                        } else {
                            P5(d, i, f, e3.z, Z1e.l3);
                        }
                    }
                }
            }
        }
        var B = d.children;
        for (var m = 0, n = B.length; m < n; m++) {
            l6(B[m], e);
        }
    }
    function p5(e, f, i, j, k) {
        for (var m = 0, n = e.length; m < n; m++) {
            var u = e[m], v = u.object, B = u.geometry, C = v.inst === undefined ? j : k,
                G = j === undefined ? u.material : C, L = u.group;
            v.modelViewMatrix.multiplyMatrices(f.matrixWorldInverse, v.matrixWorld);
            v.normalMatrix.getNormalMatrix(v.modelViewMatrix);
            if (v instanceof THREE.ImmediateRenderObject) {
                m6(G);
                var N = n6(f, i, G, v);
                f2 = '';
                v.render(function (d) {
                    B1.renderBufferImmediate(d, N, G);
                });
            } else {
                B1.renderBufferDirect(f, i, B, G, v, L);
            }
        }
    }
    function X6(d, e, f) {
        var i = w2.get(d), j = c5.getParameters(d, h2, e, K3, f), k = c5.getProgramCode(d, j), m = i.program,
            n = Z1e.n3;
        if (m === undefined) {
            d.addEventListener(Z1e.L0, b6);
        } else if (m.code !== k) {
            j6(d);
        } else if (j.shaderID !== undefined) {
            return;
        } else {
            n = Z1e.e4;
        }
        if (n) {
            if (j.shaderID) {
                var u = THREE.ShaderLib[j.shaderID];
                i.__webglShader = {
                    name: d.type,
                    uniforms: THREE.UniformsUtils.clone(u.uniforms),
                    vertexShader: u.vertexShader,
                    fragmentShader: u.fragmentShader
                };
            } else {
                i.__webglShader = {
                    name: d.type,
                    uniforms: d.uniforms,
                    vertexShader: d.vertexShader,
                    fragmentShader: d.fragmentShader
                };
            }
            d.__webglShader = i.__webglShader;
            m = c5.acquireProgram(d, j, k);
            i.program = m;
            d.program = m;
        }
        var v = m.getAttributes();
        if (d.morphTargets) {
            d.numSupportedMorphTargets = 0;
            for (var B = 0; B < B1.maxMorphTargets; B++) {
                if (v[P0 + B] >= 0) {
                    d.numSupportedMorphTargets++;
                }
            }
        }
        if (d.morphNormals) {
            d.numSupportedMorphNormals = 0;
            for (var B = 0; B < B1.maxMorphNormals; B++) {
                if (v[y0 + B] >= 0) {
                    d.numSupportedMorphNormals++;
                }
            }
        }
        var C = i.__webglShader.uniforms;
        if (!(d instanceof THREE.ShaderMaterial) && !(d instanceof THREE.RawShaderMaterial) || d.clipping === Z1e.n3) {
            i.numClippingPlanes = K3;
            C.clippingPlanes = x3;
        }
        if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshStandardMaterial || d.lights) {
            i.lightsHash = h2.hash;
            C.ambientLightColor.value = h2.ambient;
            C.directionalLights.value = h2.directional;
            C.spotLights.value = h2.spot;
            C.pointLights.value = h2.point;
            C.hemisphereLights.value = h2.hemi;
            C.directionalShadowMap.value = h2.directionalShadowMap;
            C.directionalShadowMatrix.value = h2.directionalShadowMatrix;
            C.spotShadowMap.value = h2.spotShadowMap;
            C.spotShadowMatrix.value = h2.spotShadowMatrix;
            C.pointShadowMap.value = h2.pointShadowMap;
            C.pointShadowMatrix.value = h2.pointShadowMatrix;
        }
        var G = i.program.getUniforms(), L = THREE.WebGLUniforms.seqWithValue(G.seq, C);
        i.uniformsList = L;
        i.dynamicUniforms = THREE.WebGLUniforms.splitDynamic(L, C);
    }
    function m6(d) {
        Y6(d);
        if (d.transparent === Z1e.n3) {
            p1.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst, d.blendEquationAlpha, d.blendSrcAlpha, d.blendDstAlpha, d.premultipliedAlpha);
        } else {
            p1.setBlending(THREE.NoBlending);
        }
        p1.setDepthFunc(d.depthFunc);
        p1.setDepthTest(d.depthTest);
        p1.setDepthWrite(d.depthWrite);
        p1.setColorWrite(d.colorWrite);
        p1.setPolygonOffset(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits);
    }
    function Y6(d) {
        d.side !== THREE.DoubleSide ? p1.enable(p0.CULL_FACE) : p1.disable(p0.CULL_FACE);
        p1.setFlipSided(d.side === THREE.BackSide);
    }
    function n6(d, e, f, i) {
        l2 = 0;
        var j = w2.get(f);
        if (g3) {
            if (E3 || d !== x2) {
                var k = d === x2 && f.id === t2;
                R6(f.clippingPlanes, f.clipShadows, d, j, k);
            }
            if (j.numClippingPlanes !== undefined && j.numClippingPlanes !== K3) {
                f.needsUpdate = Z1e.n3;
            }
        }
        if (j.program === undefined) {
            f.needsUpdate = Z1e.n3;
        }
        if (j.lightsHash !== undefined && j.lightsHash !== h2.hash) {
            f.needsUpdate = Z1e.n3;
        }
        if (f.needsUpdate) {
            X6(f, e, i);
            f.needsUpdate = Z1e.e4;
        }
        var m = Z1e.e4, n = Z1e.e4, u = Z1e.e4, v = j.program, B = v.getUniforms(), C = j.__webglShader.uniforms;
        if (v.id !== p2) {
            p0.useProgram(v.program);
            p2 = v.id;
            m = Z1e.n3;
            n = Z1e.n3;
            u = Z1e.n3;
        }
        if (f.id !== t2) {
            t2 = f.id;
            n = Z1e.n3;
        }
        if (m || d !== x2) {
            B.set(p0, d, Z1e.r3);
            if (X3.logarithmicDepthBuffer) {
                B.setValue(p0, 'logDepthBufFC', 2.0 / (Math.log(d.far + Z1e.d4) / Math.LN2));
            }
            if (d !== x2) {
                x2 = d;
                n = Z1e.n3;
                u = Z1e.n3;
            }
            if (f instanceof THREE.ShaderMaterial || f instanceof THREE.MeshPhongMaterial || f instanceof THREE.MeshStandardMaterial || f.envMap) {
                var G = B.map.cameraPosition;
                if (G !== undefined) {
                    G.setValue(p0, e3.setFromMatrixPosition(d.matrixWorld));
                }
            }
            if (f instanceof THREE.MeshPhongMaterial || f instanceof THREE.MeshLambertMaterial || f instanceof THREE.MeshBasicMaterial || f instanceof THREE.MeshStandardMaterial || f instanceof THREE.ShaderMaterial || f.skinning) {
                B.setValue(p0, 'viewMatrix', d.matrixWorldInverse);
            }
            B.set(p0, B1, 'toneMappingExposure');
            B.set(p0, B1, 'toneMappingWhitePoint');
        }
        if (f.skinning) {
            B.setOptional(p0, i, 'bindMatrix');
            B.setOptional(p0, i, 'bindMatrixInverse');
            var L = i.skeleton;
            if (L) {
                if (X3.floatVertexTextures && L.useVertexTexture) {
                    B.set(p0, L, 'boneTexture');
                    B.set(p0, L, 'boneTextureWidth');
                    B.set(p0, L, 'boneTextureHeight');
                } else {
                    B.setOptional(p0, L, 'boneMatrices');
                }
            }
        }
        if (n) {
            if (f instanceof THREE.MeshPhongMaterial || f instanceof THREE.MeshLambertMaterial || f instanceof THREE.MeshStandardMaterial || f.lights) {
                N6(C, u);
            }
            if (e && f.fog) {
                H6(C, e);
            }
            if (f instanceof THREE.MeshBasicMaterial || f instanceof THREE.MeshLambertMaterial || f instanceof THREE.MeshPhongMaterial || f instanceof THREE.MeshStandardMaterial || f instanceof THREE.MeshDepthMaterial) {
                Z6(C, f);
            }
            if (f instanceof THREE.LineBasicMaterial) {
                o6(C, f);
            } else if (f instanceof THREE.LineDashedMaterial) {
                o6(C, f);
                a7(C, f);
            } else if (f instanceof THREE.PointsMaterial) {
                I6(C, f);
            } else if (f instanceof THREE.MeshLambertMaterial) {
                K6(C, f);
            } else if (f instanceof THREE.MeshPhongMaterial) {
                J6(C, f);
            } else if (f instanceof THREE.MeshPhysicalMaterial) {
                L6(C, f);
            } else if (f instanceof THREE.MeshStandardMaterial) {
                h6(C, f);
            } else if (f instanceof THREE.MeshDepthMaterial) {
                if (f.displacementMap) {
                    C.displacementMap.value = f.displacementMap;
                    C.displacementScale.value = f.displacementScale;
                    C.displacementBias.value = f.displacementBias;
                }
            } else if (f instanceof THREE.MeshNormalMaterial) {
                C.opacity.value = f.opacity;
            }
            THREE.WebGLUniforms.upload(p0, j.uniformsList, C, B1);
        }
        B.set(p0, i, Z1e.A2);
        B.set(p0, i, 'normalMatrix');
        B.setValue(p0, 'modelMatrix', i.matrixWorld);
        var N = j.dynamicUniforms;
        if (N !== Z1e.l3) {
            THREE.WebGLUniforms.evalDynamic(N, C, i, d);
            THREE.WebGLUniforms.upload(p0, N, C, B1);
        }
        return v;
    }
    function Z6(d, e) {
        d.opacity.value = e.opacity;
        d.diffuse.value = e.color;
        if (e.emissive) {
            d.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity);
        }
        d.map.value = e.map;
        d.specularMap.value = e.specularMap;
        d.alphaMap.value = e.alphaMap;
        if (e.aoMap) {
            d.aoMap.value = e.aoMap;
            d.aoMapIntensity.value = e.aoMapIntensity;
        }
        var f;
        if (e.map) {
            f = e.map;
        } else if (e.specularMap) {
            f = e.specularMap;
        } else if (e.displacementMap) {
            f = e.displacementMap;
        } else if (e.normalMap) {
            f = e.normalMap;
        } else if (e.bumpMap) {
            f = e.bumpMap;
        } else if (e.roughnessMap) {
            f = e.roughnessMap;
        } else if (e.metalnessMap) {
            f = e.metalnessMap;
        } else if (e.alphaMap) {
            f = e.alphaMap;
        } else if (e.emissiveMap) {
            f = e.emissiveMap;
        }
        if (f !== undefined) {
            if (f instanceof THREE.WebGLRenderTarget) {
                f = f.texture;
            }
            var i = f.offset, j = f.repeat;
            d.offsetRepeat.value.set(i.x, i.y, j.x, j.y);
        }
        d.envMap.value = e.envMap;
        d.flipEnvMap.value = (e.envMap instanceof THREE.WebGLRenderTargetCube) ? 1 : -1;
        d.reflectivity.value = e.reflectivity;
        d.refractionRatio.value = e.refractionRatio;
    }
    function o6(d, e) {
        d.diffuse.value = e.color;
        d.opacity.value = e.opacity;
    }
    function a7(d, e) {
        d.dashSize.value = e.dashSize;
        d.totalSize.value = e.dashSize + e.gapSize;
        d.scale.value = e.scale;
    }
    function I6(d, e) {
        d.diffuse.value = e.color;
        d.opacity.value = e.opacity;
        d.size.value = e.size * N2;
        d.scale.value = b1.clientHeight * Z1e.k1;
        d.map.value = e.map;
        if (e.map !== Z1e.l3) {
            var f = e.map.offset, i = e.map.repeat;
            d.offsetRepeat.value.set(f.x, f.y, i.x, i.y);
        }
    }
    function H6(d, e) {
        d.fogColor.value = e.color;
        if (e instanceof THREE.Fog) {
            d.fogNear.value = e.near;
            d.fogFar.value = e.far;
        } else if (e instanceof THREE.FogExp2) {
            d.fogDensity.value = e.density;
        }
    }
    function K6(d, e) {
        if (e.lightMap) {
            d.lightMap.value = e.lightMap;
            d.lightMapIntensity.value = e.lightMapIntensity;
        }
        if (e.emissiveMap) {
            d.emissiveMap.value = e.emissiveMap;
        }
    }
    function J6(d, e) {
        d.specular.value = e.specular;
        d.shininess.value = Math.max(e.shininess, 1e-4);
        if (e.lightMap) {
            d.lightMap.value = e.lightMap;
            d.lightMapIntensity.value = e.lightMapIntensity;
        }
        if (e.emissiveMap) {
            d.emissiveMap.value = e.emissiveMap;
        }
        if (e.bumpMap) {
            d.bumpMap.value = e.bumpMap;
            d.bumpScale.value = e.bumpScale;
        }
        if (e.normalMap) {
            d.normalMap.value = e.normalMap;
            d.normalScale.value.copy(e.normalScale);
        }
        if (e.displacementMap) {
            d.displacementMap.value = e.displacementMap;
            d.displacementScale.value = e.displacementScale;
            d.displacementBias.value = e.displacementBias;
        }
    }
    function h6(d, e) {
        d.roughness.value = e.roughness;
        d.metalness.value = e.metalness;
        if (e.roughnessMap) {
            d.roughnessMap.value = e.roughnessMap;
        }
        if (e.metalnessMap) {
            d.metalnessMap.value = e.metalnessMap;
        }
        if (e.lightMap) {
            d.lightMap.value = e.lightMap;
            d.lightMapIntensity.value = e.lightMapIntensity;
        }
        if (e.emissiveMap) {
            d.emissiveMap.value = e.emissiveMap;
        }
        if (e.bumpMap) {
            d.bumpMap.value = e.bumpMap;
            d.bumpScale.value = e.bumpScale;
        }
        if (e.normalMap) {
            d.normalMap.value = e.normalMap;
            d.normalScale.value.copy(e.normalScale);
        }
        if (e.displacementMap) {
            d.displacementMap.value = e.displacementMap;
            d.displacementScale.value = e.displacementScale;
            d.displacementBias.value = e.displacementBias;
        }
        if (e.envMap) {
            d.envMapIntensity.value = e.envMapIntensity;
        }
    }
    function L6(d, e) {
        h6(d, e);
    }
    function N6(d, e) {
        d.ambientLightColor.needsUpdate = e;
        d.directionalLights.needsUpdate = e;
        d.pointLights.needsUpdate = e;
        d.spotLights.needsUpdate = e;
        d.hemisphereLights.needsUpdate = e;
    }
    function M6(d) {
        var e = 0;
        for (var f = 0, i = d.length; f < i; f++) {
            var j = d[f];
            if (j.castShadow) {
                h2.shadows[e++] = j;
            }
        }
        h2.shadows.length = e;
    }
    function P6(d, e) {
        var f, i, j, k = 0, m = 0, n = 0, u, v, B, C = e.matrixWorldInverse, G = 0, L = 0, N = 0, T = 0;
        for (f = 0, i = d.length; f < i; f++) {
            j = d[f];
            u = j.color;
            v = j.intensity;
            B = j.distance;
            if (j instanceof THREE.AmbientLight) {
                k += u.r * v;
                m += u.g * v;
                n += u.b * v;
            } else if (j instanceof THREE.DirectionalLight) {
                var S = l5.get(j);
                S.color.copy(j.color).multiplyScalar(j.intensity);
                S.direction.setFromMatrixPosition(j.matrixWorld);
                e3.setFromMatrixPosition(j.target.matrixWorld);
                S.direction.sub(e3);
                S.direction.transformDirection(C);
                S.shadow = j.castShadow;
                if (j.castShadow) {
                    S.shadowBias = j.shadow.bias;
                    S.shadowRadius = j.shadow.radius;
                    S.shadowMapSize = j.shadow.mapSize;
                }
                h2.directionalShadowMap[G] = j.shadow.map;
                h2.directionalShadowMatrix[G] = j.shadow.matrix;
                h2.directional[G++] = S;
            } else if (j instanceof THREE.SpotLight) {
                var S = l5.get(j);
                S.position.setFromMatrixPosition(j.matrixWorld);
                S.position.applyMatrix4(C);
                S.color.copy(u).multiplyScalar(v);
                S.distance = B;
                S.direction.setFromMatrixPosition(j.matrixWorld);
                e3.setFromMatrixPosition(j.target.matrixWorld);
                S.direction.sub(e3);
                S.direction.transformDirection(C);
                S.coneCos = Math.cos(j.angle);
                S.penumbraCos = Math.cos(j.angle * (1 - j.penumbra));
                S.decay = (j.distance === 0) ? Z1e.l1 : j.decay;
                S.shadow = j.castShadow;
                if (j.castShadow) {
                    S.shadowBias = j.shadow.bias;
                    S.shadowRadius = j.shadow.radius;
                    S.shadowMapSize = j.shadow.mapSize;
                }
                h2.spotShadowMap[N] = j.shadow.map;
                h2.spotShadowMatrix[N] = j.shadow.matrix;
                h2.spot[N++] = S;
            } else if (j instanceof THREE.PointLight) {
                var S = l5.get(j);
                S.position.setFromMatrixPosition(j.matrixWorld);
                S.position.applyMatrix4(C);
                S.color.copy(j.color).multiplyScalar(j.intensity);
                S.distance = j.distance;
                S.decay = (j.distance === 0) ? Z1e.l1 : j.decay;
                S.shadow = j.castShadow;
                if (j.castShadow) {
                    S.shadowBias = j.shadow.bias;
                    S.shadowRadius = j.shadow.radius;
                    S.shadowMapSize = j.shadow.mapSize;
                }
                h2.pointShadowMap[L] = j.shadow.map;
                if (h2.pointShadowMatrix[L] === undefined) {
                    h2.pointShadowMatrix[L] = new THREE.Matrix4();
                }
                e3.setFromMatrixPosition(j.matrixWorld).negate();
                h2.pointShadowMatrix[L].identity().setPosition(e3);
                h2.point[L++] = S;
            } else if (j instanceof THREE.HemisphereLight) {
                var S = l5.get(j);
                S.direction.setFromMatrixPosition(j.matrixWorld);
                S.direction.transformDirection(C);
                S.direction.normalize();
                S.skyColor.copy(j.color).multiplyScalar(v);
                S.groundColor.copy(j.groundColor).multiplyScalar(v);
                h2.hemi[T++] = S;
            }
        }
        h2.ambient[0] = k;
        h2.ambient[1] = m;
        h2.ambient[2] = n;
        h2.directional.length = G;
        h2.spot.length = N;
        h2.point.length = L;
        h2.hemi.length = T;
        h2.hash = G + ',' + L + ',' + N + ',' + T + ',' + h2.shadows.length;
    }
    function O6(d, e) {
        g3 = B1.clippingPlanes.length !== 0 || B1.localClippingEnabled || t3 !== 0 || E3;
        E3 = B1.localClippingEnabled;
        i4 = m5(d, e, 0);
        t3 = d !== Z1e.l3 ? d.length : 0;
    }
    function m5(d, e, f, i) {
        var j = d !== Z1e.l3 ? d.length : 0, k = Z1e.l3;
        if (j !== 0) {
            k = x3.value;
            if (i !== Z1e.n3 || k === Z1e.l3) {
                var m = f + j * 4, n = e.matrixWorldInverse, u = W4.getNormalMatrix(n);
                if (k === Z1e.l3 || k.length < m) {
                    k = new Float32Array(m);
                }
                for (var v = 0, B = f; v !== j; ++v, B += 4) {
                    var C = k5.copy(d[v]).applyMatrix4(n, u);
                    C.normal.toArray(k, B);
                    k[B + 3] = C.constant;
                }
            }
            x3.value = k;
            x3.needsUpdate = Z1e.n3;
        }
        K3 = j;
        return k;
    }
    function i6() {
        if (x3.value !== i4) {
            x3.value = i4;
            x3.needsUpdate = t3 > 0;
        }
        K3 = t3;
    }
    function R6(d, e, f, i, j) {
        if (!E3 || d === Z1e.l3 || d.length === 0 || Q3 && !e) {
            if (Q3) {
                m5(Z1e.l3);
            } else {
                i6();
            }
        } else {
            var k = Q3 ? 0 : t3, m = k * 4, n = i.clippingState || Z1e.l3;
            x3.value = n;
            n = m5(d, f, m, j);
            for (var u = 0; u !== m; ++u) {
                n[u] = i4[u];
            }
            i.clippingState = n;
            K3 += k;
        }
    }
    this.setFaceCulling = function (d, e) {
        if (d === THREE.CullFaceNone) {
            p1.disable(p0.CULL_FACE);
        } else {
            if (e === THREE.FrontFaceDirectionCW) {
                p0.frontFace(p0.CW);
            } else {
                p0.frontFace(p0.CCW);
            }
            if (d === THREE.CullFaceBack) {
                p0.cullFace(p0.BACK);
            } else if (d === THREE.CullFaceFront) {
                p0.cullFace(p0.FRONT);
            } else {
                p0.cullFace(p0.FRONT_AND_BACK);
            }
            p1.enable(p0.CULL_FACE);
        }
    };
    function Q6() {
        var d = l2;
        if (d >= X3.maxTextures) {
            console.warn('WebGLRenderer: trying to use ' + d + ' texture units while this GPU supports only ' + X3.maxTextures);
        }
        l2 += 1;
        return d;
    }
    function n5(d, e, f) {
        var i;
        if (f) {
            p0.texParameteri(d, p0.TEXTURE_WRAP_S, i3(e.wrapS));
            p0.texParameteri(d, p0.TEXTURE_WRAP_T, i3(e.wrapT));
            p0.texParameteri(d, p0.TEXTURE_MAG_FILTER, i3(e.magFilter));
            p0.texParameteri(d, p0.TEXTURE_MIN_FILTER, i3(e.minFilter));
        } else {
            p0.texParameteri(d, p0.TEXTURE_WRAP_S, p0.CLAMP_TO_EDGE);
            p0.texParameteri(d, p0.TEXTURE_WRAP_T, p0.CLAMP_TO_EDGE);
            if (e.wrapS !== THREE.ClampToEdgeWrapping || e.wrapT !== THREE.ClampToEdgeWrapping) {
                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', e);
            }
            p0.texParameteri(d, p0.TEXTURE_MAG_FILTER, s6(e.magFilter));
            p0.texParameteri(d, p0.TEXTURE_MIN_FILTER, s6(e.minFilter));
            if (e.minFilter !== THREE.NearestFilter && e.minFilter !== THREE.LinearFilter) {
                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', e);
            }
        }
        i = z2.get(Z1e.n0);
        if (i) {
            if (e.type === THREE.FloatType && z2.get(G0) === Z1e.l3)return;
            if (e.type === THREE.HalfFloatType && z2.get(M0) === Z1e.l3)return;
            if (e.anisotropy > 1 || w2.get(e).__currentAnisotropy) {
                p0.texParameterf(d, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, B1.getMaxAnisotropy()));
                w2.get(e).__currentAnisotropy = e.anisotropy;
            }
        }
    }
    function S6(d, e, f) {
        if (d.__webglInit === undefined) {
            d.__webglInit = Z1e.n3;
            e.addEventListener(Z1e.L0, M5);
            d.__webglTexture = p0.createTexture();
            r4.textures++;
        }
        p1.activeTexture(p0.TEXTURE0 + f);
        p1.bindTexture(p0.TEXTURE_2D, d.__webglTexture);
        p0.pixelStorei(p0.UNPACK_FLIP_Y_WEBGL, e.flipY);
        p0.pixelStorei(p0.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha);
        p0.pixelStorei(p0.UNPACK_ALIGNMENT, e.unpackAlignment);
        var i = r6(e.image, X3.maxTextureSize);
        if (e7(e) && s5(i) === Z1e.e4) {
            i = c7(i);
        }
        var j = s5(i), k = i3(e.format), m = i3(e.type);
        n5(p0.TEXTURE_2D, e, j);
        var n, u = e.mipmaps;
        if (e instanceof THREE.DepthTexture) {
            var v = p0.DEPTH_COMPONENT;
            if (e.type === THREE.FloatType) {
                if (!Z5)throw  new Error('Float Depth Texture only supported in WebGL2.0');
                v = p0.DEPTH_COMPONENT32F;
            } else if (Z5) {
                v = p0.DEPTH_COMPONENT16;
            }
            p1.texImage2D(p0.TEXTURE_2D, 0, v, i.width, i.height, 0, k, m, Z1e.l3);
        } else if (e instanceof THREE.DataTexture) {
            if (u.length > 0 && j) {
                for (var B = 0, C = u.length; B < C; B++) {
                    n = u[B];
                    p1.texImage2D(p0.TEXTURE_2D, B, k, n.width, n.height, 0, k, m, n.data);
                }
                e.generateMipmaps = Z1e.e4;
            } else {
                p1.texImage2D(p0.TEXTURE_2D, 0, k, i.width, i.height, 0, k, m, i.data);
            }
        } else if (e instanceof THREE.CompressedTexture) {
            for (var B = 0, C = u.length; B < C; B++) {
                n = u[B];
                if (e.format !== THREE.RGBAFormat && e.format !== THREE.RGBFormat) {
                    if (p1.getCompressedTextureFormats().indexOf(k) > -1) {
                        p1.compressedTexImage2D(p0.TEXTURE_2D, B, k, n.width, n.height, 0, n.data);
                    } else {
                        console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    }
                } else {
                    p1.texImage2D(p0.TEXTURE_2D, B, k, n.width, n.height, 0, k, m, n.data);
                }
            }
        } else {
            if (u.length > 0 && j) {
                for (var B = 0, C = u.length; B < C; B++) {
                    n = u[B];
                    p1.texImage2D(p0.TEXTURE_2D, B, k, k, m, n);
                }
                e.generateMipmaps = Z1e.e4;
            } else {
                p1.texImage2D(p0.TEXTURE_2D, 0, k, k, m, i);
            }
        }
        if (e.generateMipmaps && j) p0.generateMipmap(p0.TEXTURE_2D);
        d.__version = e.version;
        if (e.onUpdate) e.onUpdate(e);
    }
    function q6(d, e) {
        if (d instanceof THREE.WebGLRenderTarget) d = d.texture;
        var f = w2.get(d);
        if (d.version > 0 && f.__version !== d.version) {
            var i = d.image;
            if (i === undefined) {
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', d);
                return;
            }
            if (i.complete === Z1e.e4) {
                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', d);
                return;
            }
            S6(f, d, e);
            return;
        }
        p1.activeTexture(p0.TEXTURE0 + e);
        p1.bindTexture(p0.TEXTURE_2D, f.__webglTexture);
    }
    function r6(d, e) {
        if (d.width > e || d.height > e) {
            var f = e / Math.max(d.width, d.height), i = document.createElement(Z1e.M);
            i.width = Math.floor(d.width * f);
            i.height = Math.floor(d.height * f);
            var j = i.getContext('2d');
            j.drawImage(d, 0, 0, d.width, d.height, 0, 0, i.width, i.height);
            console.warn('THREE.WebGLRenderer: image is too big (' + d.width + 'x' + d.height + W0 + i.width + 'x' + i.height, d);
            return i;
        }
        return d;
    }
    function s5(d) {
        return THREE.Math.isPowerOfTwo(d.width) && THREE.Math.isPowerOfTwo(d.height);
    }
    function e7(d) {
        if (d.wrapS !== THREE.ClampToEdgeWrapping || d.wrapT !== THREE.ClampToEdgeWrapping)return Z1e.n3;
        if (d.minFilter !== THREE.NearestFilter && d.minFilter !== THREE.LinearFilter)return Z1e.n3;
        return Z1e.e4;
    }
    function c7(d) {
        if (d instanceof HTMLImageElement || d instanceof HTMLCanvasElement) {
            var e = document.createElement(Z1e.M);
            e.width = THREE.Math.nearestPowerOfTwo(d.width);
            e.height = THREE.Math.nearestPowerOfTwo(d.height);
            var f = e.getContext('2d');
            f.drawImage(d, 0, 0, e.width, e.height);
            console.warn('THREE.WebGLRenderer: image is not power of two (' + d.width + 'x' + d.height + W0 + e.width + 'x' + e.height, d);
            return e;
        }
        return d;
    }
    function d7(d, e) {
        var f = w2.get(d);
        if (d.image.length === 6) {
            if (d.version > 0 && f.__version !== d.version) {
                if (!f.__image__webglTextureCube) {
                    d.addEventListener(Z1e.L0, M5);
                    f.__image__webglTextureCube = p0.createTexture();
                    r4.textures++;
                }
                p1.activeTexture(p0.TEXTURE0 + e);
                p1.bindTexture(p0.TEXTURE_CUBE_MAP, f.__image__webglTextureCube);
                p0.pixelStorei(p0.UNPACK_FLIP_Y_WEBGL, d.flipY);
                var i = d instanceof THREE.CompressedTexture, j = d.image[0] instanceof THREE.DataTexture, k = [];
                for (var m = 0; m < 6; m++) {
                    if (B1.autoScaleCubemaps && !i && !j) {
                        k[m] = r6(d.image[m], X3.maxCubemapSize);
                    } else {
                        k[m] = j ? d.image[m].image : d.image[m];
                    }
                }
                var n = k[0], u = s5(n), v = i3(d.format), B = i3(d.type);
                n5(p0.TEXTURE_CUBE_MAP, d, u);
                for (var m = 0; m < 6; m++) {
                    if (!i) {
                        if (j) {
                            p1.texImage2D(p0.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, v, k[m].width, k[m].height, 0, v, B, k[m].data);
                        } else {
                            p1.texImage2D(p0.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, v, v, B, k[m]);
                        }
                    } else {
                        var C, G = k[m].mipmaps;
                        for (var L = 0, N = G.length; L < N; L++) {
                            C = G[L];
                            if (d.format !== THREE.RGBAFormat && d.format !== THREE.RGBFormat) {
                                if (p1.getCompressedTextureFormats().indexOf(v) > -1) {
                                    p1.compressedTexImage2D(p0.TEXTURE_CUBE_MAP_POSITIVE_X + m, L, v, C.width, C.height, 0, C.data);
                                } else {
                                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()");
                                }
                            } else {
                                p1.texImage2D(p0.TEXTURE_CUBE_MAP_POSITIVE_X + m, L, v, C.width, C.height, 0, v, B, C.data);
                            }
                        }
                    }
                }
                if (d.generateMipmaps && u) {
                    p0.generateMipmap(p0.TEXTURE_CUBE_MAP);
                }
                f.__version = d.version;
                if (d.onUpdate) d.onUpdate(d);
            } else {
                p1.activeTexture(p0.TEXTURE0 + e);
                p1.bindTexture(p0.TEXTURE_CUBE_MAP, f.__image__webglTextureCube);
            }
        }
    }
    function b7(d, e) {
        p1.activeTexture(p0.TEXTURE0 + e);
        p1.bindTexture(p0.TEXTURE_CUBE_MAP, w2.get(d).__webglTexture);
    }
    var p6 = Z1e.e4;
    this.setTexture = function (d, e) {
        if (!p6) {
            console.warn("THREE.WebGLRenderer: .setTexture is deprecated, " + "use setTexture2D instead.");
            p6 = Z1e.n3;
        }
        q6(d, e);
    };
    this.allocTextureUnit = Q6;
    this.setTexture2D = q6;
    this.setTextureCube = function (d, e) {
        if (d instanceof THREE.CubeTexture || (Array.isArray(d.image) && d.image.length === 6)) {
            d7(d, e);
        } else {
            b7(d.texture, e);
        }
    };
    function t6(d, e, f, i) {
        var j = i3(e.texture.format), k = i3(e.texture.type);
        p1.texImage2D(i, 0, j, e.width, e.height, 0, j, k, Z1e.l3);
        p0.bindFramebuffer(p0.FRAMEBUFFER, d);
        p0.framebufferTexture2D(p0.FRAMEBUFFER, f, i, w2.get(e.texture).__webglTexture, 0);
        p0.bindFramebuffer(p0.FRAMEBUFFER, Z1e.l3);
    }
    function u6(d, e) {
        p0.bindRenderbuffer(p0.RENDERBUFFER, d);
        if (e.depthBuffer && !e.stencilBuffer) {
            p0.renderbufferStorage(p0.RENDERBUFFER, p0.DEPTH_COMPONENT16, e.width, e.height);
            p0.framebufferRenderbuffer(p0.FRAMEBUFFER, p0.DEPTH_ATTACHMENT, p0.RENDERBUFFER, d);
        } else if (e.depthBuffer && e.stencilBuffer) {
            p0.renderbufferStorage(p0.RENDERBUFFER, p0.DEPTH_STENCIL, e.width, e.height);
            p0.framebufferRenderbuffer(p0.FRAMEBUFFER, p0.DEPTH_STENCIL_ATTACHMENT, p0.RENDERBUFFER, d);
        } else {
            p0.renderbufferStorage(p0.RENDERBUFFER, p0.RGBA4, e.width, e.height);
        }
        p0.bindRenderbuffer(p0.RENDERBUFFER, Z1e.l3);
    }
    function h7(d, e) {
        var f = (e instanceof THREE.WebGLRenderTargetCube);
        if (f)throw  new Error('Depth Texture with cube render targets is not supported!');
        p0.bindFramebuffer(p0.FRAMEBUFFER, d);
        if (!(e.depthTexture instanceof THREE.DepthTexture)) {
            throw  new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        }
        if (!w2.get(e.depthTexture).__webglTexture || e.depthTexture.image.width !== e.width || e.depthTexture.image.height !== e.height) {
            e.depthTexture.image.width = e.width;
            e.depthTexture.image.height = e.height;
            e.depthTexture.needsUpdate = Z1e.n3;
        }
        B1.setTexture(e.depthTexture, 0);
        var i = w2.get(e.depthTexture).__webglTexture;
        p0.framebufferTexture2D(p0.FRAMEBUFFER, p0.DEPTH_ATTACHMENT, p0.TEXTURE_2D, i, 0);
    }
    function i7(d) {
        var e = w2.get(d), f = (d instanceof THREE.WebGLRenderTargetCube);
        if (d.depthTexture) {
            if (f)throw  new Error('target.depthTexture not supported in Cube render targets');
            h7(e.__webglFramebuffer, d);
        } else {
            if (f) {
                e.__webglDepthbuffer = [];
                for (var i = 0; i < 6; i++) {
                    p0.bindFramebuffer(p0.FRAMEBUFFER, e.__webglFramebuffer[i]);
                    e.__webglDepthbuffer[i] = p0.createRenderbuffer();
                    u6(e.__webglDepthbuffer[i], d);
                }
            } else {
                p0.bindFramebuffer(p0.FRAMEBUFFER, e.__webglFramebuffer);
                e.__webglDepthbuffer = p0.createRenderbuffer();
                u6(e.__webglDepthbuffer, d);
            }
        }
        p0.bindFramebuffer(p0.FRAMEBUFFER, Z1e.l3);
    }
    function f7(d) {
        var e = w2.get(d), f = w2.get(d.texture);
        d.addEventListener(Z1e.L0, c6);
        f.__webglTexture = p0.createTexture();
        r4.textures++;
        var i = (d instanceof THREE.WebGLRenderTargetCube),
            j = THREE.Math.isPowerOfTwo(d.width) && THREE.Math.isPowerOfTwo(d.height);
        if (i) {
            e.__webglFramebuffer = [];
            for (var k = 0; k < 6; k++) {
                e.__webglFramebuffer[k] = p0.createFramebuffer();
            }
        } else {
            e.__webglFramebuffer = p0.createFramebuffer();
        }
        if (i) {
            p1.bindTexture(p0.TEXTURE_CUBE_MAP, f.__webglTexture);
            n5(p0.TEXTURE_CUBE_MAP, d.texture, j);
            for (var k = 0; k < 6; k++) {
                t6(e.__webglFramebuffer[k], d, p0.COLOR_ATTACHMENT0, p0.TEXTURE_CUBE_MAP_POSITIVE_X + k);
            }
            if (d.texture.generateMipmaps && j) p0.generateMipmap(p0.TEXTURE_CUBE_MAP);
            p1.bindTexture(p0.TEXTURE_CUBE_MAP, Z1e.l3);
        } else {
            p1.bindTexture(p0.TEXTURE_2D, f.__webglTexture);
            n5(p0.TEXTURE_2D, d.texture, j);
            t6(e.__webglFramebuffer, d, p0.COLOR_ATTACHMENT0, p0.TEXTURE_2D);
            if (d.texture.generateMipmaps && j) p0.generateMipmap(p0.TEXTURE_2D);
            p1.bindTexture(p0.TEXTURE_2D, Z1e.l3);
        }
        if (d.depthBuffer) {
            i7(d);
        }
    }
    this.getCurrentRenderTarget = function () {
        return K2;
    };
    this.setRenderTarget = function (d) {
        K2 = d;
        if (d && w2.get(d).__webglFramebuffer === undefined) {
            f7(d);
        }
        var e = (d instanceof THREE.WebGLRenderTargetCube), f;
        if (d) {
            var i = w2.get(d);
            if (e) {
                f = i.__webglFramebuffer[d.activeCubeFace];
            } else {
                f = i.__webglFramebuffer;
            }
            P2.copy(d.scissor);
            H2 = d.scissorTest;
            n1.copy(d.viewport);
        } else {
            f = Z1e.l3;
            P2.copy(d3).multiplyScalar(N2);
            H2 = s3;
            n1.copy(j3).multiplyScalar(N2);
        }
        if (h1 !== f) {
            p0.bindFramebuffer(p0.FRAMEBUFFER, f);
            h1 = f;
        }
        p1.scissor(P2);
        p1.setScissorTest(H2);
        p1.viewport(n1);
        if (e) {
            var j = w2.get(d.texture);
            p0.framebufferTexture2D(p0.FRAMEBUFFER, p0.COLOR_ATTACHMENT0, p0.TEXTURE_CUBE_MAP_POSITIVE_X + d.activeCubeFace, j.__webglTexture, d.activeMipMapLevel);
        }
    };
    this.readRenderTargetPixels = function (d, e, f, i, j, k) {
        if (d instanceof THREE.WebGLRenderTarget === Z1e.e4) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        var m = w2.get(d).__webglFramebuffer;
        if (m) {
            var n = Z1e.e4;
            if (m !== h1) {
                p0.bindFramebuffer(p0.FRAMEBUFFER, m);
                n = Z1e.n3;
            }
            try {
                var u = d.texture;
                if (u.format !== THREE.RGBAFormat && i3(u.format) !== p0.getParameter(p0.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                if (u.type !== THREE.UnsignedByteType && i3(u.type) !== p0.getParameter(p0.IMPLEMENTATION_COLOR_READ_TYPE) && !(u.type === THREE.FloatType && z2.get('WEBGL_color_buffer_float')) && !(u.type === THREE.HalfFloatType && z2.get('EXT_color_buffer_half_float'))) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                }
                if (p0.checkFramebufferStatus(p0.FRAMEBUFFER) === p0.FRAMEBUFFER_COMPLETE) {
                    if ((e > 0 && e <= (d.width - i)) && (f > 0 && f <= (d.height - j))) {
                        p0.readPixels(e, f, i, j, i3(u.format), i3(u.type), k);
                    }
                } else {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                }
            } finally {
                if (n) {
                    p0.bindFramebuffer(p0.FRAMEBUFFER, h1);
                }
            }
        }
    };
    function g7(d) {
        var e = d instanceof THREE.WebGLRenderTargetCube ? p0.TEXTURE_CUBE_MAP : p0.TEXTURE_2D,
            f = w2.get(d.texture).__webglTexture;
        p1.bindTexture(e, f);
        p0.generateMipmap(e);
        p1.bindTexture(e, Z1e.l3);
    }
    function s6(d) {
        if (d === THREE.NearestFilter || d === THREE.NearestMipMapNearestFilter || d === THREE.NearestMipMapLinearFilter) {
            return p0.NEAREST;
        }
        return p0.LINEAR;
    }
    function i3(d) {
        var e;
        if (d === THREE.RepeatWrapping)return p0.REPEAT;
        if (d === THREE.ClampToEdgeWrapping)return p0.CLAMP_TO_EDGE;
        if (d === THREE.MirroredRepeatWrapping)return p0.MIRRORED_REPEAT;
        if (d === THREE.NearestFilter)return p0.NEAREST;
        if (d === THREE.NearestMipMapNearestFilter)return p0.NEAREST_MIPMAP_NEAREST;
        if (d === THREE.NearestMipMapLinearFilter)return p0.NEAREST_MIPMAP_LINEAR;
        if (d === THREE.LinearFilter)return p0.LINEAR;
        if (d === THREE.LinearMipMapNearestFilter)return p0.LINEAR_MIPMAP_NEAREST;
        if (d === THREE.LinearMipMapLinearFilter)return p0.LINEAR_MIPMAP_LINEAR;
        if (d === THREE.UnsignedByteType)return p0.UNSIGNED_BYTE;
        if (d === THREE.UnsignedShort4444Type)return p0.UNSIGNED_SHORT_4_4_4_4;
        if (d === THREE.UnsignedShort5551Type)return p0.UNSIGNED_SHORT_5_5_5_1;
        if (d === THREE.UnsignedShort565Type)return p0.UNSIGNED_SHORT_5_6_5;
        if (d === THREE.ByteType)return p0.BYTE;
        if (d === THREE.ShortType)return p0.SHORT;
        if (d === THREE.UnsignedShortType)return p0.UNSIGNED_SHORT;
        if (d === THREE.IntType)return p0.INT;
        if (d === THREE.UnsignedIntType)return p0.UNSIGNED_INT;
        if (d === THREE.FloatType)return p0.FLOAT;
        e = z2.get(Z1e.P);
        if (e !== Z1e.l3) {
            if (d === THREE.HalfFloatType)return e.HALF_FLOAT_OES;
        }
        if (d === THREE.AlphaFormat)return p0.ALPHA;
        if (d === THREE.RGBFormat)return p0.RGB;
        if (d === THREE.RGBAFormat)return p0.RGBA;
        if (d === THREE.LuminanceFormat)return p0.LUMINANCE;
        if (d === THREE.LuminanceAlphaFormat)return p0.LUMINANCE_ALPHA;
        if (d === THREE.DepthFormat)return p0.DEPTH_COMPONENT;
        if (d === THREE.AddEquation)return p0.FUNC_ADD;
        if (d === THREE.SubtractEquation)return p0.FUNC_SUBTRACT;
        if (d === THREE.ReverseSubtractEquation)return p0.FUNC_REVERSE_SUBTRACT;
        if (d === THREE.ZeroFactor)return p0.ZERO;
        if (d === THREE.OneFactor)return p0.ONE;
        if (d === THREE.SrcColorFactor)return p0.SRC_COLOR;
        if (d === THREE.OneMinusSrcColorFactor)return p0.ONE_MINUS_SRC_COLOR;
        if (d === THREE.SrcAlphaFactor)return p0.SRC_ALPHA;
        if (d === THREE.OneMinusSrcAlphaFactor)return p0.ONE_MINUS_SRC_ALPHA;
        if (d === THREE.DstAlphaFactor)return p0.DST_ALPHA;
        if (d === THREE.OneMinusDstAlphaFactor)return p0.ONE_MINUS_DST_ALPHA;
        if (d === THREE.DstColorFactor)return p0.DST_COLOR;
        if (d === THREE.OneMinusDstColorFactor)return p0.ONE_MINUS_DST_COLOR;
        if (d === THREE.SrcAlphaSaturateFactor)return p0.SRC_ALPHA_SATURATE;
        e = z2.get(Z1e.k3);
        if (e !== Z1e.l3) {
            if (d === THREE.RGB_S3TC_DXT1_Format)return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (d === THREE.RGBA_S3TC_DXT1_Format)return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (d === THREE.RGBA_S3TC_DXT3_Format)return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (d === THREE.RGBA_S3TC_DXT5_Format)return e.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        e = z2.get(Z1e.R3);
        if (e !== Z1e.l3) {
            if (d === THREE.RGB_PVRTC_4BPPV1_Format)return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (d === THREE.RGB_PVRTC_2BPPV1_Format)return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (d === THREE.RGBA_PVRTC_4BPPV1_Format)return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (d === THREE.RGBA_PVRTC_2BPPV1_Format)return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        e = z2.get(Z1e.M1);
        if (e !== Z1e.l3) {
            if (d === THREE.RGB_ETC1_Format)return e.COMPRESSED_RGB_ETC1_WEBGL;
        }
        e = z2.get(Z1e.s4);
        if (e !== Z1e.l3) {
            if (d === THREE.MinEquation)return e.MIN_EXT;
            if (d === THREE.MaxEquation)return e.MAX_EXT;
        }
        return 0;
    }
};
THREE.WebGLRenderTarget = function (d, e, f) {
    this.uuid = THREE.Math.generateUUID();
    this.width = d;
    this.height = e;
    this.scissor = new THREE.Vector4(0, 0, d, e);
    this.scissorTest = Z1e.e4;
    this.viewport = new THREE.Vector4(0, 0, d, e);
    f = f || {};
    if (f.minFilter === undefined) f.minFilter = THREE.LinearFilter;
    this.texture = new THREE.Texture(undefined, undefined, f.wrapS, f.wrapT, f.magFilter, f.minFilter, f.format, f.type, f.anisotropy, f.encoding);
    this.depthBuffer = f.depthBuffer !== undefined ? f.depthBuffer : Z1e.n3;
    this.stencilBuffer = f.stencilBuffer !== undefined ? f.stencilBuffer : Z1e.n3;
    this.depthTexture = Z1e.l3;
};
THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget, setSize: function (d, e) {
        if (this.width !== d || this.height !== e) {
            this.width = d;
            this.height = e;
            this.dispose();
        }
        this.viewport.set(0, 0, d, e);
        this.scissor.set(0, 0, d, e);
    }, clone: function () {
        return new this.constructor().copy(this);
    }, copy: function (d) {
        this.width = d.width;
        this.height = d.height;
        this.viewport.copy(d.viewport);
        this.texture = d.texture.clone();
        this.depthBuffer = d.depthBuffer;
        this.stencilBuffer = d.stencilBuffer;
        this.depthTexture = d.depthTexture;
        return this;
    }, dispose: function () {
        this.dispatchEvent({type: Z1e.L0});
    }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube = function (d, e, f) {
    THREE.WebGLRenderTarget.call(this, d, e, f);
    this.activeCubeFace = 0;
    this.activeMipMapLevel = 0;
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
THREE.WebGLBufferRenderer = function (j, k, m) {
    var n;
    function u(d) {
        n = d;
    }
    function v(d, e) {
        j.drawArrays(n, d, e);
        m.calls++;
        m.vertices += e;
        if (n === j.TRIANGLES) m.faces += e / 3;
    }
    function B(d) {
        var e = k.get(Z1e.X2);
        if (e === Z1e.l3) {
            console.error(Z1e.O2);
            return;
        }
        var f = d.attributes.position, i = 0;
        if (f instanceof THREE.InterleavedBufferAttribute) {
            i = f.data.count;
            e.drawArraysInstancedANGLE(n, 0, i, d.maxInstancedCount);
        } else {
            i = f.count;
            e.drawArraysInstancedANGLE(n, 0, i, d.maxInstancedCount);
        }
        m.calls++;
        m.vertices += i * d.maxInstancedCount;
        if (n === j.TRIANGLES) m.faces += d.maxInstancedCount * i / 3;
    }
    this.setMode = u;
    this.render = v;
    this.renderInstances = B;
};
THREE.WebGLIndexedBufferRenderer = function (j, k, m) {
    var n;
    function u(d) {
        n = d;
    }
    var v, B;
    function C(d) {
        if (d.array instanceof Uint32Array && k.get(Z1e.h4)) {
            v = j.UNSIGNED_INT;
            B = 4;
        } else {
            v = j.UNSIGNED_SHORT;
            B = 2;
        }
    }
    function G(d, e) {
        j.drawElements(n, e, v, d * B);
        m.calls++;
        m.vertices += e;
        if (n === j.TRIANGLES) m.faces += e / 3;
    }
    function L(d, e, f) {
        var i = k.get(Z1e.X2);
        if (i === Z1e.l3) {
            console.error(Z1e.O2);
            return;
        }
        i.drawElementsInstancedANGLE(n, f, v, e * B, d.maxInstancedCount);
        m.calls++;
        m.vertices += f * d.maxInstancedCount;
        if (n === j.TRIANGLES) m.faces += d.maxInstancedCount * f / 3;
    }
    this.setMode = u;
    this.setIndex = C;
    this.render = G;
    this.renderInstances = L;
};
THREE.WebGLExtensions = function (f) {
    var i = {};
    this.get = function (d) {
        if (i[d] !== undefined) {
            return i[d];
        }
        var e;
        switch (d) {
            case Z1e.G3:
                e = f.getExtension(Z1e.G3) || f.getExtension('MOZ_WEBGL_depth_texture') || f.getExtension('WEBKIT_WEBGL_depth_texture');
            case Z1e.n0:
                e = f.getExtension(Z1e.n0) || f.getExtension('MOZ_EXT_texture_filter_anisotropic') || f.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
            case Z1e.k3:
                e = f.getExtension(Z1e.k3) || f.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || f.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
            case Z1e.R3:
                e = f.getExtension(Z1e.R3) || f.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
            case Z1e.M1:
                e = f.getExtension(Z1e.M1);
                break;
            default:
                e = f.getExtension(d);
        }
        if (e === Z1e.l3) {
            console.warn(Z1e.R + d + ' extension not supported.');
        }
        i[d] = e;
        return e;
    };
};
THREE.WebGLCapabilities = function (f, i, j) {
    function k(d) {
        var e = 'mediump';
        if (d === 'highp') {
            if (f.getShaderPrecisionFormat(f.VERTEX_SHADER, f.HIGH_FLOAT).precision > 0 && f.getShaderPrecisionFormat(f.FRAGMENT_SHADER, f.HIGH_FLOAT).precision > 0) {
                return 'highp';
            }
            d = e;
        }
        if (d === e) {
            if (f.getShaderPrecisionFormat(f.VERTEX_SHADER, f.MEDIUM_FLOAT).precision > 0 && f.getShaderPrecisionFormat(f.FRAGMENT_SHADER, f.MEDIUM_FLOAT).precision > 0) {
                return e;
            }
        }
        return 'lowp';
    }
    this.getMaxPrecision = k;
    this.precision = j.precision !== undefined ? j.precision : 'highp', this.logarithmicDepthBuffer = j.logarithmicDepthBuffer !== undefined ? j.logarithmicDepthBuffer : Z1e.e4;
    this.maxTextures = f.getParameter(f.MAX_TEXTURE_IMAGE_UNITS);
    this.maxVertexTextures = f.getParameter(f.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this.maxTextureSize = f.getParameter(f.MAX_TEXTURE_SIZE);
    this.maxCubemapSize = f.getParameter(f.MAX_CUBE_MAP_TEXTURE_SIZE);
    this.maxAttributes = f.getParameter(f.MAX_VERTEX_ATTRIBS);
    this.maxVertexUniforms = f.getParameter(f.MAX_VERTEX_UNIFORM_VECTORS);
    this.maxVaryings = f.getParameter(f.MAX_VARYING_VECTORS);
    this.maxFragmentUniforms = f.getParameter(f.MAX_FRAGMENT_UNIFORM_VECTORS);
    this.vertexTextures = this.maxVertexTextures > 0;
    this.floatFragmentTextures = !!i.get(Z1e.a0);
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
    var m = k(this.precision);
    if (m !== this.precision) {
        console.warn('THREE.WebGLRenderer:', this.precision, Z1e.T3, m, 'instead.');
        this.precision = m;
    }
    if (this.logarithmicDepthBuffer) {
        this.logarithmicDepthBuffer = !!i.get(Z1e.L3);
    }
};
THREE.WebGLGeometries = function (k, m, n) {
    var u = {};
    function v(d) {
        var e = d.geometry;
        if (u[e.id] !== undefined) {
            return u[e.id];
        }
        e.addEventListener(Z1e.L0, B);
        var f;
        if (e instanceof THREE.BufferGeometry) {
            f = e;
        } else if (e instanceof THREE.Geometry) {
            if (e._bufferGeometry === undefined) {
                e._bufferGeometry = new THREE.BufferGeometry().setFromObject(d);
            }
            f = e._bufferGeometry;
        }
        u[e.id] = f;
        n.memory.geometries++;
        return f;
    }
    function B(d) {
        var e = d.target, f = u[e.id];
        if (f.index !== Z1e.l3) {
            G(f.index);
        }
        L(f.attributes);
        e.removeEventListener(Z1e.L0, B);
        delete  u[e.id];
        var i = m.get(e);
        if (i.wireframe) {
            G(i.wireframe);
        }
        m.delete(e);
        var j = m.get(f);
        if (j.wireframe) {
            G(j.wireframe);
        }
        m.delete(f);
        n.memory.geometries--;
    }
    function C(d) {
        if (d instanceof THREE.InterleavedBufferAttribute) {
            return m.get(d.data).__webglBuffer;
        }
        return m.get(d).__webglBuffer;
    }
    function G(d) {
        var e = C(d);
        if (e !== undefined) {
            k.deleteBuffer(e);
            N(d);
        }
    }
    function L(d) {
        for (var e in d) {
            G(d[e]);
        }
    }
    function N(d) {
        if (d instanceof THREE.InterleavedBufferAttribute) {
            m.delete(d.data);
        } else {
            m.delete(d);
        }
    }
    this.get = v;
};
THREE.WebGLLights = function () {
    var f = {};
    this.get = function (d) {
        if (f[d.id] !== undefined) {
            return f[d.id];
        }
        var e;
        switch (d.type) {
            case Z1e.o2:
                e = {
                    direction: new THREE.Vector3(),
                    color: new THREE.Color(),
                    shadow: Z1e.e4,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new THREE.Vector2()
                };
                break;
            case Z1e.h3:
                e = {
                    position: new THREE.Vector3(),
                    direction: new THREE.Vector3(),
                    color: new THREE.Color(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                    shadow: Z1e.e4,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new THREE.Vector2()
                };
                break;
            case Z1e.N0:
                e = {
                    position: new THREE.Vector3(),
                    color: new THREE.Color(),
                    distance: 0,
                    decay: 0,
                    shadow: Z1e.e4,
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new THREE.Vector2()
                };
                break;
            case Z1e.Y1:
                e = {direction: new THREE.Vector3(), skyColor: new THREE.Color(), groundColor: new THREE.Color()};
                break;
        }
        f[d.id] = e;
        return e;
    };
};
THREE.WebGLObjects = function (T, S, b0) {
    var h0 = new THREE.WebGLGeometries(T, S, b0);
    function f0(d) {
        var e = h0.get(d);
        if (d.geometry instanceof THREE.Geometry) {
            e.updateFromObject(d);
        }
        var f = e.index, i = e.attributes;
        if (f !== Z1e.l3) {
            i0(f, T.ELEMENT_ARRAY_BUFFER);
        }
        for (var j in i) {
            i0(i[j], T.ARRAY_BUFFER);
        }
        var k = e.morphAttributes;
        for (var j in k) {
            var m = k[j];
            for (var n = 0, u = m.length; n < u; n++) {
                i0(m[n], T.ARRAY_BUFFER);
            }
        }
        return e;
    }
    function i0(d, e) {
        var f = (d instanceof THREE.InterleavedBufferAttribute) ? d.data : d, i = S.get(f);
        if (i.__webglBuffer === undefined) {
            s0(i, f, e);
        } else if (i.version !== f.version) {
            t0(i, f, e);
        }
    }
    function s0(d, e, f) {
        d.__webglBuffer = T.createBuffer();
        T.bindBuffer(f, d.__webglBuffer);
        var i = e.dynamic ? T.DYNAMIC_DRAW : T.STATIC_DRAW;
        T.bufferData(f, e.array, i);
        d.version = e.version;
    }
    function t0(d, e, f) {
        T.bindBuffer(f, d.__webglBuffer);
        if (e.dynamic === Z1e.e4 || e.updateRange.count === -1) {
            T.bufferSubData(f, 0, e.array);
        } else if (e.updateRange.count === 0) {
            console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
        } else {
            T.bufferSubData(f, e.updateRange.offset * e.array.BYTES_PER_ELEMENT, e.array.subarray(e.updateRange.offset, e.updateRange.offset + e.updateRange.count));
            e.updateRange.count = 0;
        }
        d.version = e.version;
    }
    function o0(d) {
        if (d instanceof THREE.InterleavedBufferAttribute) {
            return S.get(d.data).__webglBuffer;
        }
        return S.get(d).__webglBuffer;
    }
    function w0(d) {
        var e = S.get(d);
        if (e.wireframe !== undefined) {
            return e.wireframe;
        }
        var f = [], i = d.index, j = d.attributes, k = j.position;
        if (i !== Z1e.l3) {
            var m = {}, n = i.array;
            for (var u = 0, v = n.length; u < v; u += 3) {
                var B = n[u + 0], C = n[u + 1], G = n[u + 2];
                if (x0(m, B, C)) f.push(B, C);
                if (x0(m, C, G)) f.push(C, G);
                if (x0(m, G, B)) f.push(G, B);
            }
        } else {
            var n = j.position.array;
            for (var u = 0, v = (n.length / 3) - 1; u < v; u += 3) {
                var B = u + 0, C = u + 1, G = u + 2;
                f.push(B, C, C, G, G, B);
            }
        }
        var L = k.count > Z1e.P3 ? Uint32Array : Uint16Array, N = new THREE.BufferAttribute(new L(f), 1);
        i0(N, T.ELEMENT_ARRAY_BUFFER);
        e.wireframe = N;
        return N;
    }
    function x0(d, e, f) {
        if (e > f) {
            var i = e;
            e = f;
            f = i;
        }
        var j = d[e];
        if (j === undefined) {
            d[e] = [f];
            return Z1e.n3;
        } else if (j.indexOf(f) === -1) {
            j.push(f);
            return Z1e.n3;
        }
        return Z1e.e4;
    }
    this.getAttributeBuffer = o0;
    this.getWireframeAttribute = w0;
    this.update = f0;
};
THREE.WebGLProgram = (function () {
    var f2 = '#define ', x2 = 'EXT_shader_texture_lod', P2 = 0;
    function H2(d) {
        var e = '( value )';
        switch (d) {
            case THREE.LinearEncoding:
                return ['Linear', e];
            case THREE.sRGBEncoding:
                return ['sRGB', e];
            case THREE.RGBEEncoding:
                return ['RGBE', e];
            case THREE.RGBM7Encoding:
                return ['RGBM', '( value, 7.0 )'];
            case THREE.RGBM16Encoding:
                return ['RGBM', '( value, 16.0 )'];
            case THREE.RGBDEncoding:
                return ['RGBD', '( value, 256.0 )'];
            case THREE.GammaEncoding:
                return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
            default:
                throw  new Error('unsupported encoding: ' + d);
        }
    }
    function n1(d, e) {
        var f = H2(e);
        return "vec4 " + d + "( vec4 value ) { return " + f[0] + "ToLinear" + f[1] + "; }";
    }
    function l2(d, e) {
        var f = H2(e);
        return "vec4 " + d + "( vec4 value ) { return LinearTo" + f[0] + f[1] + "; }";
    }
    function r2(d, e) {
        var f;
        switch (e) {
            case THREE.LinearToneMapping:
                f = "Linear";
                break;
            case THREE.ReinhardToneMapping:
                f = "Reinhard";
                break;
            case THREE.Uncharted2ToneMapping:
                f = "Uncharted2";
                break;
            case THREE.CineonToneMapping:
                f = "OptimizedCineon";
                break;
            default:
                throw  new Error('unsupported toneMapping: ' + e);
        }
        return "vec3 " + d + "( vec3 color ) { return " + f + "ToneMapping( color ); }";
    }
    function y2(d, e, f) {
        d = d || {};
        var i = [(d.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '', (d.fragDepth || e.logarithmicDepthBuffer) && f.get(Z1e.L3) ? '#extension GL_EXT_frag_depth : enable' : '', (d.drawBuffers) && f.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (d.shaderTextureLOD || e.envMap) && f.get(x2) ? '#extension GL_EXT_shader_texture_lod : enable' : '',];
        return i.filter(N2).join(Z1e.g2);
    }
    function m3(d) {
        var e = [];
        for (var f in d) {
            var i = d[f];
            if (i === Z1e.e4)continue;
            e.push(f2 + f + ' ' + i);
        }
        return e.join(Z1e.g2);
    }
    function Z2(d, e, f) {
        var i = {}, j = d.getProgramParameter(e, d.ACTIVE_ATTRIBUTES);
        for (var k = 0; k < j; k++) {
            var m = d.getActiveAttrib(e, k), n = m.name;
            i[n] = d.getAttribLocation(e, n);
        }
        return i;
    }
    function N2(d) {
        return d !== '';
    }
    function d3(d, e) {
        return d.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
    }
    function s3(i) {
        var j = /#include +<([\w\d.]+)>/g;
        function k(d, e) {
            var f = THREE.ShaderChunk[e];
            if (f === undefined) {
                throw  new Error('Can not resolve #include <' + e + '>');
            }
            return s3(f);
        }
        return i.replace(j, k);
    }
    function j3(m) {
        var n = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        function u(d, e, f, i) {
            var j = '';
            for (var k = parseInt(e); k < parseInt(f); k++) {
                j += i.replace(/\[ i \]/g, '[ ' + k + ' ]');
            }
            return j;
        }
        return m.replace(n, u);
    }
    return function g4(d, e, f, i) {
        var j = '#endif', k = 'uniform vec3 cameraPosition;', m = 'uniform mat4 viewMatrix;',
            n = '#define USE_LOGDEPTHBUF_EXT', u = '#define USE_LOGDEPTHBUF', v = '#define USE_SHADOWMAP',
            B = '#define NUM_CLIPPING_PLANES ', C = '#define FLIP_SIDED', G = '#define DOUBLE_SIDED',
            L = '#define FLAT_SHADED', N = '#define USE_COLOR', T = '#define USE_ALPHAMAP',
            S = '#define USE_METALNESSMAP', b0 = '#define USE_ROUGHNESSMAP', h0 = '#define USE_SPECULARMAP',
            f0 = '#define USE_NORMALMAP', i0 = '#define USE_BUMPMAP', s0 = '#define USE_EMISSIVEMAP',
            t0 = '#define USE_AOMAP', o0 = '#define USE_LIGHTMAP', w0 = '#define USE_ENVMAP', x0 = '#define USE_MAP',
            D0 = '#define GAMMA_FACTOR ', F0 = '#define SHADER_NAME ', m0 = 'ENVMAP_BLENDING_MULTIPLY',
            W0 = 'ENVMAP_TYPE_CUBE', y0 = d.context, P0 = f.extensions, M0 = f.defines,
            G0 = f.__webglShader.vertexShader, a1 = f.__webglShader.fragmentShader, b1 = 'SHADOWMAP_TYPE_BASIC';
        if (i.shadowMapType === THREE.PCFShadowMap) {
            b1 = 'SHADOWMAP_TYPE_PCF';
        } else if (i.shadowMapType === THREE.PCFSoftShadowMap) {
            b1 = 'SHADOWMAP_TYPE_PCF_SOFT';
        } else if (i.shadowMapType === THREE.PCSSSoftShadowMap) {
            b1 = 'SHADOWMAP_TYPE_PCSS';
        }
        var X0 = W0, o1 = 'ENVMAP_MODE_REFLECTION', z0 = m0;
        if (i.envMap) {
            switch (f.envMap.mapping) {
                case THREE.CubeReflectionMapping:
                case THREE.CubeRefractionMapping:
                    X0 = W0;
                    break;
                case THREE.CubeUVReflectionMapping:
                case THREE.CubeUVRefractionMapping:
                    X0 = 'ENVMAP_TYPE_CUBE_UV';
                    break;
                case THREE.EquirectangularReflectionMapping:
                case THREE.EquirectangularRefractionMapping:
                    X0 = 'ENVMAP_TYPE_EQUIREC';
                    break;
                case THREE.SphericalReflectionMapping:
                    X0 = 'ENVMAP_TYPE_SPHERE';
                    break;
            }
            switch (f.envMap.mapping) {
                case THREE.CubeRefractionMapping:
                case THREE.EquirectangularRefractionMapping:
                    o1 = 'ENVMAP_MODE_REFRACTION';
                    break;
            }
            switch (f.combine) {
                case THREE.MultiplyOperation:
                    z0 = m0;
                    break;
                case THREE.MixOperation:
                    z0 = 'ENVMAP_BLENDING_MIX';
                    break;
                case THREE.AddOperation:
                    z0 = 'ENVMAP_BLENDING_ADD';
                    break;
            }
        }
        var Z0 = (d.gammaFactor > 0) ? d.gammaFactor : Z1e.d4, q1 = y2(P0, i, d.extensions), t1 = m3(M0),
            s1 = y0.createProgram(), z1, w1;
        if (f instanceof THREE.RawShaderMaterial) {
            z1 = '';
            w1 = '';
        } else {
            z1 = [Z1e.Y3 + i.precision + Z1e.d0, Z1e.Y3 + i.precision + ' int;', F0 + f.__webglShader.name, t1, i.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', D0 + Z0, '#define MAX_BONES ' + i.maxBones, i.map ? x0 : '', i.envMap ? w0 : '', i.envMap ? f2 + o1 : '', i.lightMap ? o0 : '', i.aoMap ? t0 : '', i.emissiveMap ? s0 : '', i.bumpMap ? i0 : '', i.normalMap ? f0 : '', i.displacementMap && i.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', i.specularMap ? h0 : '', i.roughnessMap ? b0 : '', i.metalnessMap ? S : '', i.alphaMap ? T : '', i.vertexColors ? N : '', i.flatShading ? L : '', i.skinning ? '#define USE_SKINNING' : '', i.useVertexTexture ? '#define BONE_TEXTURE' : '', i.morphTargets ? '#define USE_MORPHTARGETS' : '', i.morphNormals && i.flatShading === Z1e.e4 ? '#define USE_MORPHNORMALS' : '', i.doubleSided ? G : '', i.flipSided ? C : '', B + i.numClippingPlanes, i.shadowMapEnabled ? v : '', i.shadowMapEnabled ? f2 + b1 : '', i.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', i.logarithmicDepthBuffer ? u : '', i.logarithmicDepthBuffer && d.extensions.get(Z1e.L3) ? n : '', 'uniform mat4 modelMatrix;', Z1e.k2, Z1e.Z1, m, 'uniform mat3 normalMatrix;', k, 'attribute vec3 position;', 'attribute vec3 normal;', Z1e.E1, '#ifdef USE_COLOR', '	#ifdef USE_COLOR_OPACITY', '		attribute vec4 color;', '	#else', '		attribute vec3 color;', '	#endif', j, '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', j, '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', j, Z1e.g2].filter(N2).join(Z1e.g2);
            w1 = [q1, Z1e.Y3 + i.precision + Z1e.d0, Z1e.Y3 + i.precision + ' int;', F0 + f.__webglShader.name, t1, i.alphaTest ? '#define ALPHATEST ' + i.alphaTest : '', D0 + Z0, (i.useFog && i.fog) ? '#define USE_FOG' : '', (i.useFog && i.fogExp) ? '#define FOG_EXP2' : '', i.map ? x0 : '', i.envMap ? w0 : '', i.envMap ? f2 + X0 : '', i.envMap ? f2 + o1 : '', i.envMap ? f2 + z0 : '', i.lightMap ? o0 : '', i.aoMap ? t0 : '', i.emissiveMap ? s0 : '', i.bumpMap ? i0 : '', i.normalMap ? f0 : '', i.specularMap ? h0 : '', i.roughnessMap ? b0 : '', i.metalnessMap ? S : '', i.alphaMap ? T : '', i.vertexColors ? N : '', i.flatShading ? L : '', i.doubleSided ? G : '', i.flipSided ? C : '', B + i.numClippingPlanes, i.shadowMapEnabled ? v : '', i.shadowMapEnabled ? f2 + b1 : '', i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '', i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '', i.logarithmicDepthBuffer ? u : '', i.logarithmicDepthBuffer && d.extensions.get(Z1e.L3) ? n : '', i.envMap && d.extensions.get(x2) ? '#define TEXTURE_LOD_EXT' : '', m, k, (i.toneMapping !== THREE.NoToneMapping) ? "#define TONE_MAPPING" : '', (i.toneMapping !== THREE.NoToneMapping) ? THREE.ShaderChunk[Z1e.B2] : '', (i.toneMapping !== THREE.NoToneMapping) ? r2(Z1e.y3, i.toneMapping) : '', (i.outputEncoding || i.mapEncoding || i.envMapEncoding || i.emissiveMapEncoding) ? THREE.ShaderChunk[Z1e.E2] : '', i.mapEncoding ? n1('mapTexelToLinear', i.mapEncoding) : '', i.envMapEncoding ? n1('envMapTexelToLinear', i.envMapEncoding) : '', i.emissiveMapEncoding ? n1('emissiveMapTexelToLinear', i.emissiveMapEncoding) : '', i.outputEncoding ? l2("linearToOutputTexel", i.outputEncoding) : '', i.depthPacking ? "#define DEPTH_PACKING " + f.depthPacking : '', Z1e.g2].filter(N2).join(Z1e.g2);
        }
        G0 = s3(G0, i);
        G0 = d3(G0, i);
        a1 = s3(a1, i);
        a1 = d3(a1, i);
        if (f instanceof THREE.ShaderMaterial === Z1e.e4) {
            G0 = j3(G0);
            a1 = j3(a1);
        }
        var u1 = z1 + G0, L1 = w1 + a1, S1 = THREE.WebGLShader(y0, y0.VERTEX_SHADER, u1),
            y1 = THREE.WebGLShader(y0, y0.FRAGMENT_SHADER, L1);
        y0.attachShader(s1, S1);
        y0.attachShader(s1, y1);
        if (f.index0AttributeName !== undefined) {
            y0.bindAttribLocation(s1, 0, f.index0AttributeName);
        } else if (i.morphTargets === Z1e.n3) {
            y0.bindAttribLocation(s1, 0, Z1e.g1);
        }
        y0.linkProgram(s1);
        var a2 = y0.getProgramInfoLog(s1), P1 = y0.getShaderInfoLog(S1), B1 = y0.getShaderInfoLog(y1), p2 = Z1e.n3,
            K2 = Z1e.n3;
        if (y0.getProgramParameter(s1, y0.LINK_STATUS) === Z1e.e4) {
            p2 = Z1e.e4;
            console.error('THREE.WebGLProgram: shader error: ', y0.getError(), 'gl.VALIDATE_STATUS', y0.getProgramParameter(s1, y0.VALIDATE_STATUS), 'gl.getProgramInfoLog', a2, P1, B1);
        } else if (a2 !== '') {
            console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', a2);
        } else if (P1 === '' || B1 === '') {
            K2 = Z1e.e4;
        }
        if (K2) {
            this.diagnostics = {
                runnable: p2,
                material: f,
                programLog: a2,
                vertexShader: {log: P1, prefix: z1},
                fragmentShader: {log: B1, prefix: w1}
            };
        }
        y0.deleteShader(S1);
        y0.deleteShader(y1);
        var h1;
        this.getUniforms = function () {
            if (h1 === undefined) {
                h1 = new THREE.WebGLUniforms(y0, s1, d);
            }
            return h1;
        };
        var t2;
        this.getAttributes = function () {
            if (t2 === undefined) {
                t2 = Z2(y0, s1);
            }
            return t2;
        };
        this.destroy = function () {
            y0.deleteProgram(s1);
            this.program = undefined;
        };
        Object.defineProperties(this, {
            uniforms: {
                get: function () {
                    console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
                    return this.getUniforms();
                }
            }, attributes: {
                get: function () {
                    console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
                    return this.getAttributes();
                }
            }
        });
        this.id = P2++;
        this.code = e;
        this.usedTimes = 1;
        this.program = s1;
        this.vertexShader = S1;
        this.fragmentShader = y1;
        return this;
    };
})();
THREE.WebGLPrograms = function (v, B) {
    var C = [], G = {
            MeshDepthMaterial: 'depth',
            MeshNormalMaterial: Z1e.R2,
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshStandardMaterial: Z1e.W,
            MeshPhysicalMaterial: Z1e.W,
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points'
        },
        L = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "shadowMapType", Z1e.y3, 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"];
    function N(d) {
        if (B.floatVertexTextures && d && d.skeleton && d.skeleton.useVertexTexture) {
            return 1024;
        } else {
            var e = B.maxVertexUniforms, f = Math.floor((e - 20) / 4), i = f;
            if (d !== undefined && d instanceof THREE.SkinnedMesh) {
                i = Math.min(d.skeleton.bones.length, i);
                if (i < d.skeleton.bones.length) {
                    console.warn('WebGLRenderer: too many bones - ' + d.skeleton.bones.length + ', this GPU supports just ' + i + ' (try OpenGL instead of ANGLE)');
                }
            }
            return i;
        }
    }
    function T(d, e) {
        var f;
        if (!d) {
            f = THREE.LinearEncoding;
        } else if (d instanceof THREE.Texture) {
            f = d.encoding;
        } else if (d instanceof THREE.WebGLRenderTarget) {
            f = d.texture.encoding;
        }
        if (f === THREE.LinearEncoding && e) {
            f = THREE.GammaEncoding;
        }
        return f;
    }
    this.getParameters = function (d, e, f, i, j) {
        var k = G[d.type], m = N(j), n = v.getPrecision();
        if (d.precision !== Z1e.l3) {
            n = B.getMaxPrecision(d.precision);
            if (n !== d.precision) {
                console.warn('THREE.WebGLProgram.getParameters:', d.precision, Z1e.T3, n, 'instead.');
            }
        }
        var u = {
            shaderID: k,
            precision: n,
            supportsVertexTextures: B.vertexTextures,
            outputEncoding: T(v.getCurrentRenderTarget(), v.gammaOutput),
            map: !!d.map,
            mapEncoding: T(d.map, v.gammaInput),
            envMap: !!d.envMap,
            envMapMode: d.envMap && d.envMap.mapping,
            envMapEncoding: T(d.envMap, v.gammaInput),
            envMapCubeUV: (!!d.envMap) && ((d.envMap.mapping === THREE.CubeUVReflectionMapping) || (d.envMap.mapping === THREE.CubeUVRefractionMapping)),
            lightMap: !!d.lightMap,
            aoMap: !!d.aoMap,
            emissiveMap: !!d.emissiveMap,
            emissiveMapEncoding: T(d.emissiveMap, v.gammaInput),
            bumpMap: !!d.bumpMap,
            normalMap: !!d.normalMap,
            displacementMap: !!d.displacementMap,
            roughnessMap: !!d.roughnessMap,
            metalnessMap: !!d.metalnessMap,
            specularMap: !!d.specularMap,
            alphaMap: !!d.alphaMap,
            combine: d.combine,
            vertexColors: d.vertexColors,
            fog: f,
            useFog: d.fog,
            fogExp: f instanceof THREE.FogExp2,
            flatShading: d.shading === THREE.FlatShading,
            sizeAttenuation: d.sizeAttenuation,
            logarithmicDepthBuffer: B.logarithmicDepthBuffer,
            skinning: d.skinning,
            maxBones: m,
            useVertexTexture: B.floatVertexTextures && j && j.skeleton && j.skeleton.useVertexTexture,
            morphTargets: d.morphTargets,
            morphNormals: d.morphNormals,
            maxMorphTargets: v.maxMorphTargets,
            maxMorphNormals: v.maxMorphNormals,
            numDirLights: e.directional.length,
            numPointLights: e.point.length,
            numSpotLights: e.spot.length,
            numHemiLights: e.hemi.length,
            numClippingPlanes: i,
            shadowMapEnabled: v.shadowMap.enabled && j.receiveShadow && e.shadows.length > 0,
            shadowMapType: v.shadowMap.type,
            toneMapping: v.toneMapping,
            physicallyCorrectLights: v.physicallyCorrectLights,
            premultipliedAlpha: d.premultipliedAlpha,
            alphaTest: d.alphaTest,
            doubleSided: d.side === THREE.DoubleSide,
            flipSided: d.side === THREE.BackSide,
            depthPacking: (d.depthPacking !== undefined) ? d.depthPacking : Z1e.e4
        };
        return u;
    };
    this.getProgramCode = function (d, e) {
        var f = [];
        if (e.shaderID) {
            f.push(e.shaderID);
        } else {
            f.push(d.fragmentShader);
            f.push(d.vertexShader);
        }
        if (d.defines !== undefined) {
            for (var i in d.defines) {
                f.push(i);
                f.push(d.defines[i]);
            }
        }
        for (var j = 0; j < L.length; j++) {
            f.push(e[L[j]]);
        }
        return f.join();
    };
    this.acquireProgram = function (d, e, f) {
        var i;
        for (var j = 0, k = C.length; j < k; j++) {
            var m = C[j];
            if (m.code === f) {
                i = m;
                ++i.usedTimes;
                break;
            }
        }
        if (i === undefined) {
            i = new THREE.WebGLProgram(v, f, d, e);
            C.push(i);
        }
        return i;
    };
    this.releaseProgram = function (d) {
        if (--d.usedTimes === 0) {
            var e = C.indexOf(d);
            C[e] = C[C.length - 1];
            C.pop();
            d.destroy();
        }
    };
    this.programs = C;
};
THREE.WebGLProperties = function () {
    var i = {};
    this.get = function (d) {
        var e = d.uuid, f = i[e];
        if (f === undefined) {
            f = {};
            i[e] = f;
        }
        return f;
    };
    this.delete = function (d) {
        delete  i[d.uuid];
    };
    this.clear = function () {
        i = {};
    };
};
THREE.WebGLShader = (function () {
    function j(d) {
        var e = d.split(Z1e.g2);
        for (var f = 0; f < e.length; f++) {
            e[f] = (f + 1) + ': ' + e[f];
        }
        return e.join(Z1e.g2);
    }
    return function k(d, e, f) {
        var i = d.createShader(e);
        d.shaderSource(i, f);
        d.compileShader(i);
        if (d.getShaderParameter(i, d.COMPILE_STATUS) === Z1e.e4) {
            console.error('THREE.WebGLShader: Shader couldn\'t compile.');
        }
        if (d.getShaderInfoLog(i) !== '') {
            console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', e === d.VERTEX_SHADER ? 'vertex' : 'fragment', d.getShaderInfoLog(i), j(f));
        }
        return i;
    };
})();
THREE.WebGLShadowMap = function (y0, P0, M0) {
    var G0 = y0.context, a1 = y0.state, b1 = new THREE.Frustum(), X0 = new THREE.Matrix4(), o1 = P0.shadows,
        z0 = new THREE.Vector2(), Z0 = new THREE.Vector3(), q1 = new THREE.Vector3(), t1 = [], s1 = 1, z1 = 2,
        w1 = (s1 | z1) + 1, u1 = new Array(w1), L1 = new Array(w1), S1 = {},
        y1 = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)],
        a2 = [new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)],
        P1 = [new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()],
        B1 = new THREE.MeshDepthMaterial();
    B1.depthPacking = THREE.RGBADepthPacking;
    B1.clipping = Z1e.n3;
    var p2 = THREE.ShaderLib["distanceRGBA"], K2 = THREE.UniformsUtils.clone(p2.uniforms);
    for (var h1 = 0; h1 !== w1; ++h1) {
        var t2 = (h1 & s1) !== 0, f2 = (h1 & z1) !== 0, x2 = B1.clone();
        x2.morphTargets = t2;
        x2.skinning = f2;
        u1[h1] = x2;
        var P2 = new THREE.ShaderMaterial({
            defines: {'USE_SHADOWMAP': ''},
            uniforms: K2,
            vertexShader: p2.vertexShader,
            fragmentShader: p2.fragmentShader,
            morphTargets: t2,
            skinning: f2,
            clipping: Z1e.n3
        });
        L1[h1] = P2;
    }
    var H2 = this;
    this.enabled = Z1e.e4;
    this.autoUpdate = Z1e.n3;
    this.needsUpdate = Z1e.e4;
    this.type = THREE.PCFShadowMap;
    this.cullFace = THREE.CullFaceFront;
    this.render = function (d, e) {
        if (H2.enabled === Z1e.e4)return;
        if (H2.autoUpdate === Z1e.e4 && H2.needsUpdate === Z1e.e4)return;
        if (o1.length === 0)return;
        a1.clearColor(1, 1, 1, 1);
        a1.disable(G0.BLEND);
        a1.enable(G0.CULL_FACE);
        G0.frontFace(G0.CCW);
        G0.cullFace(H2.cullFace === THREE.CullFaceFront ? G0.FRONT : G0.BACK);
        a1.setDepthTest(Z1e.n3);
        a1.setScissorTest(Z1e.e4);
        var f, i;
        for (var j = 0, k = o1.length; j < k; j++) {
            var m = o1[j], n = m.shadow, u = n.camera;
            z0.copy(n.mapSize);
            if (m instanceof THREE.PointLight) {
                f = 6;
                i = Z1e.n3;
                var v = z0.x, B = z0.y;
                P1[0].set(v * 2, B, v, B);
                P1[1].set(0, B, v, B);
                P1[2].set(v * 3, B, v, B);
                P1[3].set(v, B, v, B);
                P1[4].set(v * 3, 0, v, B);
                P1[5].set(v, 0, v, B);
                z0.x *= 4.0;
                z0.y *= 2.0;
            } else {
                f = 1;
                i = Z1e.e4;
            }
            if (n.map === Z1e.l3) {
                var C = {minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat};
                n.map = new THREE.WebGLRenderTarget(z0.x, z0.y, C);
                u.updateProjectionMatrix();
            }
            if (n instanceof THREE.SpotLightShadow) {
                n.update(m);
            }
            var G = n.map, L = n.matrix;
            q1.setFromMatrixPosition(m.matrixWorld);
            u.position.copy(q1);
            y0.setRenderTarget(G);
            y0.clear();
            for (var N = 0; N < f; N++) {
                if (i) {
                    Z0.copy(u.position);
                    Z0.add(y1[N]);
                    u.up.copy(a2[N]);
                    u.lookAt(Z0);
                    var T = P1[N];
                    a1.viewport(T);
                } else {
                    Z0.setFromMatrixPosition(m.target.matrixWorld);
                    u.lookAt(Z0);
                }
                u.updateMatrixWorld();
                u.matrixWorldInverse.getInverse(u.matrixWorld);
                L.set(Z1e.k1, Z1e.l1, Z1e.l1, Z1e.k1, Z1e.l1, Z1e.k1, Z1e.l1, Z1e.k1, Z1e.l1, Z1e.l1, Z1e.k1, Z1e.k1, Z1e.l1, Z1e.l1, Z1e.l1, Z1e.d4);
                L.multiply(u.projectionMatrix);
                L.multiply(u.matrixWorldInverse);
                X0.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse);
                b1.setFromMatrix(X0);
                t1.length = 0;
                l2(d, e, u);
                for (var S = 0, b0 = t1.length; S < b0; S++) {
                    var h0 = t1[S], f0 = M0.update(h0), i0 = h0.material;
                    if (i0 instanceof THREE.MultiMaterial) {
                        var s0 = f0.groups, t0 = i0.materials;
                        for (var o0 = 0, w0 = s0.length; o0 < w0; o0++) {
                            var x0 = s0[o0], D0 = t0[x0.materialIndex];
                            if (D0.visible === Z1e.n3) {
                                var F0 = n1(h0, D0, i, q1);
                                y0.renderBufferDirect(u, Z1e.l3, f0, F0, h0, x0);
                            }
                        }
                    } else {
                        var F0 = n1(h0, i0, i, q1);
                        y0.renderBufferDirect(u, Z1e.l3, f0, F0, h0, Z1e.l3);
                    }
                }
            }
        }
        var m0 = y0.getClearColor(), W0 = y0.getClearAlpha();
        y0.setClearColor(m0, W0);
        a1.enable(G0.BLEND);
        if (H2.cullFace === THREE.CullFaceFront) {
            G0.cullFace(G0.BACK);
        }
        H2.needsUpdate = Z1e.e4;
    };
    function n1(d, e, f, i) {
        var j = d.geometry, k = Z1e.l3, m = u1, n = d.customDepthMaterial;
        if (f) {
            m = L1;
            n = d.customDistanceMaterial;
        }
        if (!n) {
            var u = j.morphTargets !== undefined && j.morphTargets.length > 0 && e.morphTargets,
                v = d instanceof THREE.SkinnedMesh && e.skinning, B = 0;
            if (u) B |= s1;
            if (v) B |= z1;
            k = m[B];
        } else {
            k = n;
        }
        if (y0.localClippingEnabled && e.clipShadows === Z1e.n3 && e.clippingPlanes.length !== 0) {
            var C = k.uuid, G = e.uuid, L = S1[C];
            if (L === undefined) {
                L = {};
                S1[C] = L;
            }
            var N = L[G];
            if (N === undefined) {
                N = k.clone();
                L[G] = N;
            }
            k = N;
        }
        k.visible = e.visible;
        k.wireframe = e.wireframe;
        k.side = e.side;
        k.clipShadows = e.clipShadows;
        k.clippingPlanes = e.clippingPlanes;
        k.wireframeLinewidth = e.wireframeLinewidth;
        k.linewidth = e.linewidth;
        if (f && k.uniforms.lightPos !== undefined) {
            k.uniforms.lightPos.value.copy(i);
        }
        return k;
    }
    function l2(d, e, f) {
        if (d.visible === Z1e.e4)return;
        if (d.layers.test(e.layers) && (d instanceof THREE.Mesh || d instanceof THREE.Line || d instanceof THREE.Points)) {
            if (d.castShadow && (d.frustumCulled === Z1e.e4 || b1.intersectsObject(d) === Z1e.n3)) {
                var i = d.material;
                if (i.visible === Z1e.n3) {
                    d.modelViewMatrix.multiplyMatrices(f.matrixWorldInverse, d.matrixWorld);
                    t1.push(d);
                }
            }
        }
        var j = d.children;
        for (var k = 0, m = j.length; k < m; k++) {
            l2(j[k], e, f);
        }
    }
};
THREE.WebGLState = function (u, v, B) {
    var C = this, G = new THREE.Vector4(), L = u.getParameter(u.MAX_VERTEX_ATTRIBS), N = new Uint8Array(L),
        T = new Uint8Array(L), S = new Uint8Array(L), b0 = {}, h0 = Z1e.l3, f0 = Z1e.l3, i0 = Z1e.l3, s0 = Z1e.l3,
        t0 = Z1e.l3, o0 = Z1e.l3, w0 = Z1e.l3, x0 = Z1e.l3, D0 = Z1e.e4, F0 = Z1e.l3, m0 = Z1e.l3, W0 = Z1e.l3,
        y0 = Z1e.l3, P0 = Z1e.l3, M0 = Z1e.l3, G0 = Z1e.l3, a1 = Z1e.l3, b1 = Z1e.l3, X0 = Z1e.l3, o1 = Z1e.l3,
        z0 = Z1e.l3, Z0 = Z1e.l3, q1 = Z1e.l3, t1 = Z1e.l3, s1 = u.getParameter(u.MAX_TEXTURE_IMAGE_UNITS),
        z1 = undefined, w1 = {}, u1 = new THREE.Vector4(), L1 = Z1e.l3, S1 = Z1e.l3, y1 = new THREE.Vector4(),
        a2 = new THREE.Vector4();
    this.init = function () {
        this.clearColor(0, 0, 0, 1);
        this.clearDepth(1);
        this.clearStencil(0);
        this.enable(u.DEPTH_TEST);
        u.depthFunc(u.LEQUAL);
        u.frontFace(u.CCW);
        u.cullFace(u.BACK);
        this.enable(u.CULL_FACE);
        this.enable(u.BLEND);
        u.blendEquation(u.FUNC_ADD);
        u.blendFunc(u.SRC_ALPHA, u.ONE_MINUS_SRC_ALPHA);
    };
    this.initAttributes = function () {
        for (var d = 0, e = N.length; d < e; d++) {
            N[d] = 0;
        }
    };
    this.enableAttribute = function (d) {
        N[d] = 1;
        if (T[d] === 0) {
            u.enableVertexAttribArray(d);
            T[d] = 1;
        }
        if (S[d] !== 0) {
            var e = v.get(Z1e.X2);
            e.vertexAttribDivisorANGLE(d, 0);
            S[d] = 0;
        }
    };
    this.enableAttributeAndDivisor = function (d, e, f) {
        N[d] = 1;
        if (T[d] === 0) {
            u.enableVertexAttribArray(d);
            T[d] = 1;
        }
        if (S[d] !== e) {
            f.vertexAttribDivisorANGLE(d, e);
            S[d] = e;
        }
    };
    this.disableUnusedAttributes = function () {
        for (var d = 0, e = T.length; d < e; d++) {
            if (T[d] !== N[d]) {
                u.disableVertexAttribArray(d);
                T[d] = 0;
            }
        }
    };
    this.enable = function (d) {
        if (b0[d] !== Z1e.n3) {
            u.enable(d);
            b0[d] = Z1e.n3;
        }
    };
    this.disable = function (d) {
        if (b0[d] !== Z1e.e4) {
            u.disable(d);
            b0[d] = Z1e.e4;
        }
    };
    this.getCompressedTextureFormats = function () {
        if (h0 === Z1e.l3) {
            h0 = [];
            if (v.get(Z1e.R3) || v.get(Z1e.k3) || v.get(Z1e.M1)) {
                var d = u.getParameter(u.COMPRESSED_TEXTURE_FORMATS);
                for (var e = 0; e < d.length; e++) {
                    h0.push(d[e]);
                }
            }
        }
        return h0;
    };
    this.setBlending = function (d, e, f, i, j, k, m, n) {
        if (d === THREE.NoBlending) {
            this.disable(u.BLEND);
        } else {
            this.enable(u.BLEND);
        }
        if (d !== f0 || n !== D0) {
            if (d === THREE.AdditiveBlending) {
                if (n) {
                    u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD);
                    u.blendFuncSeparate(u.ONE, u.ONE, u.ONE, u.ONE);
                } else {
                    u.blendEquation(u.FUNC_ADD);
                    u.blendFunc(u.SRC_ALPHA, u.ONE);
                }
            } else if (d === THREE.SubtractiveBlending) {
                if (n) {
                    u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD);
                    u.blendFuncSeparate(u.ZERO, u.ZERO, u.ONE_MINUS_SRC_COLOR, u.ONE_MINUS_SRC_ALPHA);
                } else {
                    u.blendEquation(u.FUNC_ADD);
                    u.blendFunc(u.ZERO, u.ONE_MINUS_SRC_COLOR);
                }
            } else if (d === THREE.MultiplyBlending) {
                if (n) {
                    u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD);
                    u.blendFuncSeparate(u.ZERO, u.ZERO, u.SRC_COLOR, u.SRC_ALPHA);
                } else {
                    u.blendEquation(u.FUNC_ADD);
                    u.blendFunc(u.ZERO, u.SRC_COLOR);
                }
            } else {
                if (n) {
                    u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD);
                    u.blendFuncSeparate(u.ONE, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA);
                } else {
                    u.blendEquationSeparate(u.FUNC_ADD, u.FUNC_ADD);
                    u.blendFuncSeparate(u.SRC_ALPHA, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA);
                }
            }
            f0 = d;
            D0 = n;
        }
        if (d === THREE.CustomBlending) {
            j = j || e;
            k = k || f;
            m = m || i;
            if (e !== i0 || j !== o0) {
                u.blendEquationSeparate(B(e), B(j));
                i0 = e;
                o0 = j;
            }
            if (f !== s0 || i !== t0 || k !== w0 || m !== x0) {
                u.blendFuncSeparate(B(f), B(i), B(k), B(m));
                s0 = f;
                t0 = i;
                w0 = k;
                x0 = m;
            }
        } else {
            i0 = Z1e.l3;
            s0 = Z1e.l3;
            t0 = Z1e.l3;
            o0 = Z1e.l3;
            w0 = Z1e.l3;
            x0 = Z1e.l3;
        }
    };
    this.setDepthFunc = function (d) {
        if (F0 !== d) {
            if (d) {
                switch (d) {
                    case THREE.NeverDepth:
                        u.depthFunc(u.NEVER);
                        break;
                    case THREE.AlwaysDepth:
                        u.depthFunc(u.ALWAYS);
                        break;
                    case THREE.LessDepth:
                        u.depthFunc(u.LESS);
                        break;
                    case THREE.LessEqualDepth:
                        u.depthFunc(u.LEQUAL);
                        break;
                    case THREE.EqualDepth:
                        u.depthFunc(u.EQUAL);
                        break;
                    case THREE.GreaterEqualDepth:
                        u.depthFunc(u.GEQUAL);
                        break;
                    case THREE.GreaterDepth:
                        u.depthFunc(u.GREATER);
                        break;
                    case THREE.NotEqualDepth:
                        u.depthFunc(u.NOTEQUAL);
                        break;
                    default:
                        u.depthFunc(u.LEQUAL);
                }
            } else {
                u.depthFunc(u.LEQUAL);
            }
            F0 = d;
        }
    };
    this.setDepthTest = function (d) {
        if (d) {
            this.enable(u.DEPTH_TEST);
        } else {
            this.disable(u.DEPTH_TEST);
        }
    };
    this.setDepthWrite = function (d) {
        if (m0 !== d) {
            u.depthMask(d);
            m0 = d;
        }
    };
    this.setColorWrite = function (d) {
        if (W0 !== d) {
            u.colorMask(d, d, d, d);
            W0 = d;
        }
    };
    this.setStencilFunc = function (d, e, f) {
        if (P0 !== d || M0 !== e || G0 !== f) {
            u.stencilFunc(d, e, f);
            P0 = d;
            M0 = e;
            G0 = f;
        }
    };
    this.setStencilOp = function (d, e, f) {
        if (a1 !== d || b1 !== e || X0 !== f) {
            u.stencilOp(d, e, f);
            a1 = d;
            b1 = e;
            X0 = f;
        }
    };
    this.setStencilTest = function (d) {
        if (d) {
            this.enable(u.STENCIL_TEST);
        } else {
            this.disable(u.STENCIL_TEST);
        }
    };
    this.setStencilWrite = function (d) {
        if (y0 !== d) {
            u.stencilMask(d);
            y0 = d;
        }
    };
    this.setFlipSided = function (d) {
        if (o1 !== d) {
            if (d) {
                u.frontFace(u.CW);
            } else {
                u.frontFace(u.CCW);
            }
            o1 = d;
        }
    };
    this.setLineWidth = function (d) {
        if (d !== z0) {
            u.lineWidth(d);
            z0 = d;
        }
    };
    this.setPolygonOffset = function (d, e, f) {
        if (d) {
            this.enable(u.POLYGON_OFFSET_FILL);
        } else {
            this.disable(u.POLYGON_OFFSET_FILL);
        }
        if (d && (Z0 !== e || q1 !== f)) {
            u.polygonOffset(e, f);
            Z0 = e;
            q1 = f;
        }
    };
    this.getScissorTest = function () {
        return t1;
    };
    this.setScissorTest = function (d) {
        t1 = d;
        if (d) {
            this.enable(u.SCISSOR_TEST);
        } else {
            this.disable(u.SCISSOR_TEST);
        }
    };
    this.activeTexture = function (d) {
        if (d === undefined) d = u.TEXTURE0 + s1 - 1;
        if (z1 !== d) {
            u.activeTexture(d);
            z1 = d;
        }
    };
    this.bindTexture = function (d, e) {
        if (z1 === undefined) {
            C.activeTexture();
        }
        var f = w1[z1];
        if (f === undefined) {
            f = {type: undefined, texture: undefined};
            w1[z1] = f;
        }
        if (f.type !== d || f.texture !== e) {
            u.bindTexture(d, e);
            f.type = d;
            f.texture = e;
        }
    };
    this.compressedTexImage2D = function () {
        try {
            u.compressedTexImage2D.apply(u, arguments);
        } catch (d) {
            console.error(d);
        }
    };
    this.texImage2D = function () {
        try {
            u.texImage2D.apply(u, arguments);
        } catch (d) {
            console.error(d);
        }
    };
    this.clearColor = function (d, e, f, i) {
        G.set(d, e, f, i);
        if (u1.equals(G) === Z1e.e4) {
            u.clearColor(d, e, f, i);
            u1.copy(G);
        }
    };
    this.clearDepth = function (d) {
        if (L1 !== d) {
            u.clearDepth(d);
            L1 = d;
        }
    };
    this.clearStencil = function (d) {
        if (S1 !== d) {
            u.clearStencil(d);
            S1 = d;
        }
    };
    this.scissor = function (d) {
        if (y1.equals(d) === Z1e.e4) {
            u.scissor(d.x, d.y, d.z, d.w);
            y1.copy(d);
        }
    };
    this.viewport = function (d) {
        if (a2.equals(d) === Z1e.e4) {
            u.viewport(d.x, d.y, d.z, d.w);
            a2.copy(d);
        }
    };
    this.reset = function () {
        for (var d = 0; d < T.length; d++) {
            if (T[d] === 1) {
                u.disableVertexAttribArray(d);
                T[d] = 0;
            }
        }
        b0 = {};
        h0 = Z1e.l3;
        z1 = undefined;
        w1 = {};
        f0 = Z1e.l3;
        W0 = Z1e.l3;
        m0 = Z1e.l3;
        y0 = Z1e.l3;
        o1 = Z1e.l3;
    };
};
THREE.WebGLUniforms = (function () {
    var G = function () {
        this.seq = [];
        this.map = {};
    }, L = [], N = [], T = function () {
        L.length = 0;
        N.length = 0;
    }, S = function (d, e, f) {
        var i = d[0];
        if (i <= 0 || i > 0)return d;
        var j = e * f, k = L[j];
        if (k === undefined) {
            k = new Float32Array(j);
            L[j] = k;
        }
        if (e !== 0) {
            i.toArray(k, 0);
            for (var m = 1, n = 0; m !== e; ++m) {
                n += f;
                d[m].toArray(k, n);
            }
        }
        return k;
    }, b0 = function (d, e) {
        var f = N[e];
        if (f === undefined) {
            f = new Int32Array(e);
            N[e] = f;
        }
        for (var i = 0; i !== e; ++i)f[i] = d.allocTextureUnit();
        return f;
    }, h0 = function (d, e) {
        d.uniform1f(this.addr, e);
    }, f0 = function (d, e) {
        d.uniform1i(this.addr, e);
    }, i0 = function (d, e) {
        if (e.x === undefined) d.uniform2fv(this.addr, e); else d.uniform2f(this.addr, e.x, e.y);
    }, s0 = function (d, e) {
        if (e.x !== undefined) d.uniform3f(this.addr, e.x, e.y, e.z); else if (e.r !== undefined) d.uniform3f(this.addr, e.r, e.g, e.b); else d.uniform3fv(this.addr, e);
    }, t0 = function (d, e) {
        if (e.x === undefined) d.uniform4fv(this.addr, e); else d.uniform4f(this.addr, e.x, e.y, e.z, e.w);
    }, o0 = function (d, e) {
        d.uniformMatrix2fv(this.addr, Z1e.e4, e.elements || e);
    }, w0 = function (d, e) {
        d.uniformMatrix3fv(this.addr, Z1e.e4, e.elements || e);
    }, x0 = function (d, e) {
        d.uniformMatrix4fv(this.addr, Z1e.e4, e.elements || e);
    }, D0 = function (d, e, f) {
        var i = f.allocTextureUnit();
        d.uniform1i(this.addr, i);
        if (e) f.setTexture2D(e, i);
    }, F0 = function (d, e, f) {
        var i = f.allocTextureUnit();
        d.uniform1i(this.addr, i);
        if (e) f.setTextureCube(e, i);
    }, m0 = function (d, e) {
        d.uniform2iv(this.addr, e);
    }, W0 = function (d, e) {
        d.uniform3iv(this.addr, e);
    }, y0 = function (d, e) {
        d.uniform4iv(this.addr, e);
    }, P0 = function (d) {
        switch (d) {
            case 0x1406:
                return h0;
            case 0x8b50:
                return i0;
            case 0x8b51:
                return s0;
            case 0x8b52:
                return t0;
            case 0x8b5a:
                return o0;
            case 0x8b5b:
                return w0;
            case 0x8b5c:
                return x0;
            case 0x8b5e:
                return D0;
            case 0x8b60:
                return F0;
            case 0x1404:
            case 0x8b56:
                return f0;
            case 0x8b53:
            case 0x8b57:
                return m0;
            case 0x8b54:
            case 0x8b58:
                return W0;
            case 0x8b55:
            case 0x8b59:
                return y0;
        }
    }, M0 = function (d, e) {
        d.uniform1fv(this.addr, e);
    }, G0 = function (d, e) {
        d.uniform1iv(this.addr, e);
    }, a1 = function (d, e) {
        d.uniform2fv(this.addr, S(e, this.size, 2));
    }, b1 = function (d, e) {
        d.uniform3fv(this.addr, S(e, this.size, 3));
    }, X0 = function (d, e) {
        d.uniform4fv(this.addr, S(e, this.size, 4));
    }, o1 = function (d, e) {
        d.uniformMatrix2fv(this.addr, Z1e.e4, S(e, this.size, 4));
    }, z0 = function (d, e) {
        d.uniformMatrix3fv(this.addr, Z1e.e4, S(e, this.size, 9));
    }, Z0 = function (d, e) {
        d.uniformMatrix4fv(this.addr, Z1e.e4, S(e, this.size, 16));
    }, q1 = function (d, e, f) {
        var i = e.length, j = b0(f, i);
        d.uniform1iv(this.addr, j);
        for (var k = 0; k !== i; ++k) {
            var m = e[k];
            if (m) f.setTexture2D(m, j[k]);
        }
    }, t1 = function (d, e, f) {
        var i = e.length, j = b0(f, i);
        d.uniform1iv(this.addr, j);
        for (var k = 0; k !== i; ++k) {
            var m = e[k];
            if (m) f.setTextureCube(m, j[k]);
        }
    }, s1 = function (d) {
        switch (d) {
            case 0x1406:
                return M0;
            case 0x8b50:
                return a1;
            case 0x8b51:
                return b1;
            case 0x8b52:
                return X0;
            case 0x8b5a:
                return o1;
            case 0x8b5b:
                return z0;
            case 0x8b5c:
                return Z0;
            case 0x8b5e:
                return q1;
            case 0x8b60:
                return t1;
            case 0x1404:
            case 0x8b56:
                return G0;
            case 0x8b53:
            case 0x8b57:
                return m0;
            case 0x8b54:
            case 0x8b58:
                return W0;
            case 0x8b55:
            case 0x8b59:
                return y0;
        }
    }, z1 = function z1(d, e, f) {
        this.id = d;
        this.addr = f;
        this.setValue = P0(e.type);
    }, w1 = function (d, e, f) {
        this.id = d;
        this.addr = f;
        this.size = e.size;
        this.setValue = s1(e.type);
    }, u1 = function (d) {
        this.id = d;
        G.call(this);
    };
    u1.prototype.setValue = function (d, e) {
        var f = this.seq;
        for (var i = 0, j = f.length; i !== j; ++i) {
            var k = f[i];
            k.setValue(d, e[k.id]);
        }
    };
    var L1 = /([\w\d_]+)(\])?(\[|\.)?/g, S1 = function (d, e) {
        d.seq.push(e);
        d.map[e.id] = e;
    }, y1 = function (d, e, f) {
        var i = d.name, j = i.length;
        L1.lastIndex = 0;
        for (; ;) {
            var k = L1.exec(i), m = L1.lastIndex, n = k[1], u = k[2] === ']', v = k[3];
            if (u) n = n | 0;
            if (v === undefined || v === '[' && m + 2 === j) {
                S1(f, v === undefined ? new z1(n, d, e) : new w1(n, d, e));
                break;
            } else {
                var B = f.map, C = B[n];
                if (C === undefined) {
                    C = new u1(n);
                    S1(f, C);
                }
                f = C;
            }
        }
    }, a2 = function a2(d, e, f) {
        G.call(this);
        this.renderer = f;
        var i = d.getProgramParameter(e, d.ACTIVE_UNIFORMS);
        for (var j = 0; j !== i; ++j) {
            var k = d.getActiveUniform(e, j), m = k.name, n = d.getUniformLocation(e, m);
            y1(k, n, this);
        }
    };
    a2.prototype.setValue = function (d, e, f) {
        var i = this.map[e];
        if (i !== undefined) i.setValue(d, f, this.renderer);
    };
    a2.prototype.set = function (d, e, f) {
        var i = this.map[f];
        if (i !== undefined) i.setValue(d, e[f], this.renderer);
    };
    a2.prototype.setOptional = function (d, e, f) {
        var i = e[f];
        if (i !== undefined) this.setValue(d, f, i);
    };
    a2.upload = function (d, e, f, i) {
        for (var j = 0, k = e.length; j !== k; ++j) {
            var m = e[j], n = f[m.id];
            if (n.needsUpdate !== Z1e.e4) {
                m.setValue(d, n.value, i);
            }
        }
    };
    a2.seqWithValue = function (d, e) {
        var f = [];
        for (var i = 0, j = d.length; i !== j; ++i) {
            var k = d[i];
            if (k.id in e) f.push(k);
        }
        return f;
    };
    a2.splitDynamic = function (d, e) {
        var f = Z1e.l3, i = d.length, j = 0;
        for (var k = 0; k !== i; ++k) {
            var m = d[k], n = e[m.id];
            if (n && n.dynamic === Z1e.n3) {
                if (f === Z1e.l3) f = [];
                f.push(m);
            } else {
                if (j < k) d[j] = m;
                ++j;
            }
        }
        if (j < i) d.length = j;
        return f;
    };
    a2.evalDynamic = function (d, e, f, i) {
        for (var j = 0, k = d.length; j !== k; ++j) {
            var m = e[d[j].id], n = m.onUpdateCallback;
            if (n !== undefined) n.call(m, f, i);
        }
    };
    return a2;
})();
THREE.LensFlarePlugin = function (h0, f0) {
    var i0 = h0.context, s0 = h0.state, t0, o0, w0, x0, D0, F0, m0, W0;
    function y0() {
        var d = "void main() {", e = "varying float vVisibility;", f = "varying vec2 vUV;",
            i = "uniform lowp int renderType;",
            j = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
            k = new Uint16Array([0, 1, 2, 0, 2, 3]);
        t0 = i0.createBuffer();
        o0 = i0.createBuffer();
        i0.bindBuffer(i0.ARRAY_BUFFER, t0);
        i0.bufferData(i0.ARRAY_BUFFER, j, i0.STATIC_DRAW);
        i0.bindBuffer(i0.ELEMENT_ARRAY_BUFFER, o0);
        i0.bufferData(i0.ELEMENT_ARRAY_BUFFER, k, i0.STATIC_DRAW);
        m0 = i0.createTexture();
        W0 = i0.createTexture();
        s0.bindTexture(i0.TEXTURE_2D, m0);
        i0.texImage2D(i0.TEXTURE_2D, 0, i0.RGB, 16, 16, 0, i0.RGB, i0.UNSIGNED_BYTE, Z1e.l3);
        i0.texParameteri(i0.TEXTURE_2D, i0.TEXTURE_WRAP_S, i0.CLAMP_TO_EDGE);
        i0.texParameteri(i0.TEXTURE_2D, i0.TEXTURE_WRAP_T, i0.CLAMP_TO_EDGE);
        i0.texParameteri(i0.TEXTURE_2D, i0.TEXTURE_MAG_FILTER, i0.NEAREST);
        i0.texParameteri(i0.TEXTURE_2D, i0.TEXTURE_MIN_FILTER, i0.NEAREST);
        s0.bindTexture(i0.TEXTURE_2D, W0);
        i0.texImage2D(i0.TEXTURE_2D, 0, i0.RGBA, 16, 16, 0, i0.RGBA, i0.UNSIGNED_BYTE, Z1e.l3);
        i0.texParameteri(i0.TEXTURE_2D, i0.TEXTURE_WRAP_S, i0.CLAMP_TO_EDGE);
        i0.texParameteri(i0.TEXTURE_2D, i0.TEXTURE_WRAP_T, i0.CLAMP_TO_EDGE);
        i0.texParameteri(i0.TEXTURE_2D, i0.TEXTURE_MAG_FILTER, i0.NEAREST);
        i0.texParameteri(i0.TEXTURE_2D, i0.TEXTURE_MIN_FILTER, i0.NEAREST);
        w0 = {
            vertexShader: [i, "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", f, e, d, "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: [i, "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", f, e, d, "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
        };
        x0 = P0(w0);
        D0 = {vertex: i0.getAttribLocation(x0, "position"), uv: i0.getAttribLocation(x0, "uv")};
        F0 = {
            renderType: i0.getUniformLocation(x0, "renderType"),
            map: i0.getUniformLocation(x0, "map"),
            occlusionMap: i0.getUniformLocation(x0, "occlusionMap"),
            opacity: i0.getUniformLocation(x0, "opacity"),
            color: i0.getUniformLocation(x0, "color"),
            scale: i0.getUniformLocation(x0, "scale"),
            rotation: i0.getUniformLocation(x0, "rotation"),
            screenPosition: i0.getUniformLocation(x0, "screenPosition")
        };
    }
    this.render = function (d, e, f) {
        if (f0.length === 0)return;
        var i = new THREE.Vector3(), j = f.w / f.z, k = f.z * Z1e.k1, m = f.w * Z1e.k1, n = 16 / f.w,
            u = new THREE.Vector2(n * j, n), v = new THREE.Vector3(1, 1, 0), B = new THREE.Vector2(1, 1),
            C = new THREE.Box2();
        C.min.set(0, 0);
        C.max.set(f.z - 16, f.w - 16);
        if (x0 === undefined) {
            y0();
        }
        i0.useProgram(x0);
        s0.initAttributes();
        s0.enableAttribute(D0.vertex);
        s0.enableAttribute(D0.uv);
        s0.disableUnusedAttributes();
        i0.uniform1i(F0.occlusionMap, 0);
        i0.uniform1i(F0.map, 1);
        i0.bindBuffer(i0.ARRAY_BUFFER, t0);
        i0.vertexAttribPointer(D0.vertex, 2, i0.FLOAT, Z1e.e4, 2 * 8, 0);
        i0.vertexAttribPointer(D0.uv, 2, i0.FLOAT, Z1e.e4, 2 * 8, 8);
        i0.bindBuffer(i0.ELEMENT_ARRAY_BUFFER, o0);
        s0.disable(i0.CULL_FACE);
        s0.setDepthWrite(Z1e.e4);
        for (var G = 0, L = f0.length; G < L; G++) {
            n = 16 / f.w;
            u.set(n * j, n);
            var N = f0[G];
            i.set(N.matrixWorld.elements[12], N.matrixWorld.elements[13], N.matrixWorld.elements[14]);
            i.applyMatrix4(e.matrixWorldInverse);
            i.applyProjection(e.projectionMatrix);
            v.copy(i);
            B.x = f.x + (v.x * k) + k - 8;
            B.y = f.y + (v.y * m) + m - 8;
            if (C.containsPoint(B) === Z1e.n3) {
                s0.activeTexture(i0.TEXTURE0);
                s0.bindTexture(i0.TEXTURE_2D, Z1e.l3);
                s0.activeTexture(i0.TEXTURE1);
                s0.bindTexture(i0.TEXTURE_2D, m0);
                i0.copyTexImage2D(i0.TEXTURE_2D, 0, i0.RGB, B.x, B.y, 16, 16, 0);
                i0.uniform1i(F0.renderType, 0);
                i0.uniform2f(F0.scale, u.x, u.y);
                i0.uniform3f(F0.screenPosition, v.x, v.y, v.z);
                s0.disable(i0.BLEND);
                s0.enable(i0.DEPTH_TEST);
                i0.drawElements(i0.TRIANGLES, 6, i0.UNSIGNED_SHORT, 0);
                s0.activeTexture(i0.TEXTURE0);
                s0.bindTexture(i0.TEXTURE_2D, W0);
                i0.copyTexImage2D(i0.TEXTURE_2D, 0, i0.RGBA, B.x, B.y, 16, 16, 0);
                i0.uniform1i(F0.renderType, 1);
                s0.disable(i0.DEPTH_TEST);
                s0.activeTexture(i0.TEXTURE1);
                s0.bindTexture(i0.TEXTURE_2D, m0);
                i0.drawElements(i0.TRIANGLES, 6, i0.UNSIGNED_SHORT, 0);
                N.positionScreen.copy(v);
                if (N.customUpdateCallback) {
                    N.customUpdateCallback(N);
                } else {
                    N.updateLensFlares();
                }
                i0.uniform1i(F0.renderType, 2);
                s0.enable(i0.BLEND);
                for (var T = 0, S = N.lensFlares.length; T < S; T++) {
                    var b0 = N.lensFlares[T];
                    if (b0.opacity > 0.001 && b0.scale > 0.001) {
                        v.x = b0.x;
                        v.y = b0.y;
                        v.z = b0.z;
                        n = b0.size * b0.scale / f.w;
                        u.x = n * j;
                        u.y = n;
                        i0.uniform3f(F0.screenPosition, v.x, v.y, v.z);
                        i0.uniform2f(F0.scale, u.x, u.y);
                        i0.uniform1f(F0.rotation, b0.rotation);
                        i0.uniform1f(F0.opacity, b0.opacity);
                        i0.uniform3f(F0.color, b0.color.r, b0.color.g, b0.color.b);
                        s0.setBlending(b0.blending, b0.blendEquation, b0.blendSrc, b0.blendDst);
                        h0.setTexture2D(b0.texture, 1);
                        i0.drawElements(i0.TRIANGLES, 6, i0.UNSIGNED_SHORT, 0);
                    }
                }
            }
        }
        s0.enable(i0.CULL_FACE);
        s0.enable(i0.DEPTH_TEST);
        s0.setDepthWrite(Z1e.n3);
        h0.resetGLState();
    };
    function P0(d) {
        var e = i0.createProgram(), f = i0.createShader(i0.FRAGMENT_SHADER), i = i0.createShader(i0.VERTEX_SHADER),
            j = "precision " + h0.getPrecision() + " float;\n";
        i0.shaderSource(f, j + d.fragmentShader);
        i0.shaderSource(i, j + d.vertexShader);
        i0.compileShader(f);
        i0.compileShader(i);
        i0.attachShader(e, f);
        i0.attachShader(e, i);
        i0.linkProgram(e);
        return e;
    }
};
THREE.SpritePlugin = function (C, G) {
    var L = C.context, N = C.state, T, S, b0, h0, f0, i0, s0 = new THREE.Vector3(), t0 = new THREE.Quaternion(),
        o0 = new THREE.Vector3();
    function w0() {
        var d = new Float32Array([-Z1e.k1, -Z1e.k1, 0, 0, Z1e.k1, -Z1e.k1, 1, 0, Z1e.k1, Z1e.k1, 1, 1, -Z1e.k1, Z1e.k1, 0, 1]),
            e = new Uint16Array([0, 1, 2, 0, 2, 3]);
        T = L.createBuffer();
        S = L.createBuffer();
        L.bindBuffer(L.ARRAY_BUFFER, T);
        L.bufferData(L.ARRAY_BUFFER, d, L.STATIC_DRAW);
        L.bindBuffer(L.ELEMENT_ARRAY_BUFFER, S);
        L.bufferData(L.ELEMENT_ARRAY_BUFFER, e, L.STATIC_DRAW);
        b0 = x0();
        h0 = {position: L.getAttribLocation(b0, Z1e.g1), uv: L.getAttribLocation(b0, Z1e.M3)};
        f0 = {
            uvOffset: L.getUniformLocation(b0, 'uvOffset'),
            uvScale: L.getUniformLocation(b0, 'uvScale'),
            rotation: L.getUniformLocation(b0, 'rotation'),
            scale: L.getUniformLocation(b0, 'scale'),
            color: L.getUniformLocation(b0, Z1e.X1),
            map: L.getUniformLocation(b0, 'map'),
            opacity: L.getUniformLocation(b0, 'opacity'),
            modelViewMatrix: L.getUniformLocation(b0, Z1e.A2),
            projectionMatrix: L.getUniformLocation(b0, Z1e.r3),
            fogType: L.getUniformLocation(b0, 'fogType'),
            fogDensity: L.getUniformLocation(b0, 'fogDensity'),
            fogNear: L.getUniformLocation(b0, 'fogNear'),
            fogFar: L.getUniformLocation(b0, 'fogFar'),
            fogColor: L.getUniformLocation(b0, 'fogColor'),
            alphaTest: L.getUniformLocation(b0, 'alphaTest')
        };
        var f = document.createElement(Z1e.M);
        f.width = 8;
        f.height = 8;
        var i = f.getContext('2d');
        i.fillStyle = 'white';
        i.fillRect(0, 0, 8, 8);
        i0 = new THREE.Texture(f);
        i0.needsUpdate = Z1e.n3;
    }
    this.render = function (d, e) {
        if (G.length === 0)return;
        if (b0 === undefined) {
            w0();
        }
        L.useProgram(b0);
        N.initAttributes();
        N.enableAttribute(h0.position);
        N.enableAttribute(h0.uv);
        N.disableUnusedAttributes();
        N.disable(L.CULL_FACE);
        N.enable(L.BLEND);
        L.bindBuffer(L.ARRAY_BUFFER, T);
        L.vertexAttribPointer(h0.position, 2, L.FLOAT, Z1e.e4, 2 * 8, 0);
        L.vertexAttribPointer(h0.uv, 2, L.FLOAT, Z1e.e4, 2 * 8, 8);
        L.bindBuffer(L.ELEMENT_ARRAY_BUFFER, S);
        L.uniformMatrix4fv(f0.projectionMatrix, Z1e.e4, e.projectionMatrix.elements);
        N.activeTexture(L.TEXTURE0);
        L.uniform1i(f0.map, 0);
        var f = 0, i = 0, j = d.fog;
        if (j) {
            L.uniform3f(f0.fogColor, j.color.r, j.color.g, j.color.b);
            if (j instanceof THREE.Fog) {
                L.uniform1f(f0.fogNear, j.near);
                L.uniform1f(f0.fogFar, j.far);
                L.uniform1i(f0.fogType, 1);
                f = 1;
                i = 1;
            } else if (j instanceof THREE.FogExp2) {
                L.uniform1f(f0.fogDensity, j.density);
                L.uniform1i(f0.fogType, 2);
                f = 2;
                i = 2;
            }
        } else {
            L.uniform1i(f0.fogType, 0);
            f = 0;
            i = 0;
        }
        for (var k = 0, m = G.length; k < m; k++) {
            var n = G[k];
            n.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, n.matrixWorld);
            n.z = -n.modelViewMatrix.elements[14];
        }
        G.sort(D0);
        var u = [];
        for (var k = 0, m = G.length; k < m; k++) {
            var n = G[k], v = n.material;
            L.uniform1f(f0.alphaTest, v.alphaTest);
            L.uniformMatrix4fv(f0.modelViewMatrix, Z1e.e4, n.modelViewMatrix.elements);
            n.matrixWorld.decompose(s0, t0, o0);
            u[0] = o0.x;
            u[1] = o0.y;
            var B = 0;
            if (d.fog && v.fog) {
                B = i;
            }
            if (f !== B) {
                L.uniform1i(f0.fogType, B);
                f = B;
            }
            if (v.map !== Z1e.l3) {
                L.uniform2f(f0.uvOffset, v.map.offset.x, v.map.offset.y);
                L.uniform2f(f0.uvScale, v.map.repeat.x, v.map.repeat.y);
            } else {
                L.uniform2f(f0.uvOffset, 0, 0);
                L.uniform2f(f0.uvScale, 1, 1);
            }
            L.uniform1f(f0.opacity, v.opacity);
            L.uniform3f(f0.color, v.color.r, v.color.g, v.color.b);
            L.uniform1f(f0.rotation, v.rotation);
            L.uniform2fv(f0.scale, u);
            N.setBlending(v.blending, v.blendEquation, v.blendSrc, v.blendDst);
            N.setDepthTest(v.depthTest);
            N.setDepthWrite(v.depthWrite);
            N.setPolygonOffset(v.polygonOffset, v.polygonOffsetFactor, v.polygonOffsetUnits);
            if (v.map) {
                C.setTexture2D(v.map, 0);
            } else {
                C.setTexture2D(i0, 0);
            }
            L.drawElements(L.TRIANGLES, 6, L.UNSIGNED_SHORT, 0);
        }
        N.enable(L.CULL_FACE);
        C.resetGLState();
    };
    function x0() {
        var d = 'void main() {', e = 'varying vec2 vUV;', f = L.createProgram(), i = L.createShader(L.VERTEX_SHADER),
            j = L.createShader(L.FRAGMENT_SHADER);
        L.shaderSource(i, [Z1e.Y3 + C.getPrecision() + Z1e.d0, Z1e.k2, Z1e.Z1, 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', Z1e.E1, e, d, 'vUV = uvOffset + uv * uvScale;', 'vec2 alignedPosition = position * scale;', 'vec2 rotatedPosition;', 'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', 'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', 'vec4 finalPosition;', 'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', 'finalPosition.xy += rotatedPosition;', 'finalPosition = projectionMatrix * finalPosition;', 'gl_Position = finalPosition;', '}'].join(Z1e.g2));
        L.shaderSource(j, [Z1e.Y3 + C.getPrecision() + Z1e.d0, 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', e, d, 'vec4 texture = texture2D( map, vUV );', 'if ( texture.a < alphaTest ) discard;', 'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', 'if ( fogType > 0 ) {', 'float depth = gl_FragCoord.z / gl_FragCoord.w;', 'float fogFactor = 0.0;', 'if ( fogType == 1 ) {', 'fogFactor = smoothstep( fogNear, fogFar, depth );', '} else {', 'const float LOG2 = 1.442695;', 'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );', 'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '}', 'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );', '}', '}'].join(Z1e.g2));
        L.compileShader(i);
        L.compileShader(j);
        L.attachShader(f, i);
        L.attachShader(f, j);
        L.linkProgram(f);
        return f;
    }
    function D0(d, e) {
        if (d.renderOrder !== e.renderOrder) {
            return d.renderOrder - e.renderOrder;
        } else if (d.z !== e.z) {
            return e.z - d.z;
        } else {
            return e.id - d.id;
        }
    }
};
Object.defineProperties(THREE.Box2.prototype, {
    empty: {
        value: function () {
            console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        }
    }, isIntersectionBox: {
        value: function (d) {
            console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(d);
        }
    }
});
Object.defineProperties(THREE.Box3.prototype, {
    empty: {
        value: function () {
            console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        }
    }, isIntersectionBox: {
        value: function (d) {
            console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(d);
        }
    }, isIntersectionSphere: {
        value: function (d) {
            console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(d);
        }
    }
});
Object.defineProperties(THREE.Matrix3.prototype, {
    multiplyVector3: {
        value: function (d) {
            console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
            return d.applyMatrix3(this);
        }
    }, multiplyVector3Array: {
        value: function (d) {
            console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
            return this.applyToVector3Array(d);
        }
    }
});
Object.defineProperties(THREE.Matrix4.prototype, {
    extractPosition: {
        value: function (d) {
            console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
            return this.copyPosition(d);
        }
    }, setRotationFromQuaternion: {
        value: function (d) {
            console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
            return this.makeRotationFromQuaternion(d);
        }
    }, multiplyVector3: {
        value: function (d) {
            console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
            return d.applyProjection(this);
        }
    }, multiplyVector4: {
        value: function (d) {
            console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return d.applyMatrix4(this);
        }
    }, multiplyVector3Array: {
        value: function (d) {
            console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
            return this.applyToVector3Array(d);
        }
    }, rotateAxis: {
        value: function (d) {
            console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
            d.transformDirection(this);
        }
    }, crossVector: {
        value: function (d) {
            console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return d.applyMatrix4(this);
        }
    }, translate: {
        value: function (d) {
            console.error('THREE.Matrix4: .translate() has been removed.');
        }
    }, rotateX: {
        value: function (d) {
            console.error('THREE.Matrix4: .rotateX() has been removed.');
        }
    }, rotateY: {
        value: function (d) {
            console.error('THREE.Matrix4: .rotateY() has been removed.');
        }
    }, rotateZ: {
        value: function (d) {
            console.error('THREE.Matrix4: .rotateZ() has been removed.');
        }
    }, rotateByAxis: {
        value: function (d, e) {
            console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
        }
    }
});
Object.defineProperties(THREE.Plane.prototype, {
    isIntersectionLine: {
        value: function (d) {
            console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
            return this.intersectsLine(d);
        }
    }
});
Object.defineProperties(THREE.Quaternion.prototype, {
    multiplyVector3: {
        value: function (d) {
            console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
            return d.applyQuaternion(this);
        }
    }
});
Object.defineProperties(THREE.Ray.prototype, {
    isIntersectionBox: {
        value: function (d) {
            console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(d);
        }
    }, isIntersectionPlane: {
        value: function (d) {
            console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
            return this.intersectsPlane(d);
        }
    }, isIntersectionSphere: {
        value: function (d) {
            console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(d);
        }
    }
});
Object.defineProperties(THREE.Vector3.prototype, {
    setEulerFromRotationMatrix: {
        value: function () {
            console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
        }
    }, setEulerFromQuaternion: {
        value: function () {
            console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
        }
    }, getPositionFromMatrix: {
        value: function (d) {
            console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
            return this.setFromMatrixPosition(d);
        }
    }, getScaleFromMatrix: {
        value: function (d) {
            console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
            return this.setFromMatrixScale(d);
        }
    }, getColumnFromMatrix: {
        value: function (d, e) {
            console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
            return this.setFromMatrixColumn(d, e);
        }
    }
});
THREE.Face4 = function (d, e, f, i, j, k, m) {
    console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
    return new THREE.Face3(d, e, f, j, k, m);
};
THREE.Vertex = function (d, e, f) {
    console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
    return new THREE.Vector3(d, e, f);
};
Object.defineProperties(THREE.Object3D.prototype, {
    eulerOrder: {
        get: function () {
            console.warn(Z1e.j1);
            return this.rotation.order;
        }, set: function (d) {
            console.warn(Z1e.j1);
            this.rotation.order = d;
        }
    }, getChildByName: {
        value: function (d) {
            console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
            return this.getObjectByName(d);
        }
    }, renderDepth: {
        set: function (d) {
            console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
        }
    }, translate: {
        value: function (d, e) {
            console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
            return this.translateOnAxis(e, d);
        }
    }, useQuaternion: {
        get: function () {
            console.warn(Z1e.J1);
        }, set: function (d) {
            console.warn(Z1e.J1);
        }
    }
});
Object.defineProperties(THREE, {
    PointCloud: {
        value: function (d, e) {
            console.warn('THREE.PointCloud has been renamed to THREE.Points.');
            return new THREE.Points(d, e);
        }
    }, ParticleSystem: {
        value: function (d, e) {
            console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
            return new THREE.Points(d, e);
        }
    }
});
Object.defineProperties(THREE.Light.prototype, {
    onlyShadow: {
        set: function (d) {
            console.warn('THREE.Light: .onlyShadow has been removed.');
        }
    }, shadowCameraFov: {
        set: function (d) {
            console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
            this.shadow.camera.fov = d;
        }
    }, shadowCameraLeft: {
        set: function (d) {
            console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
            this.shadow.camera.left = d;
        }
    }, shadowCameraRight: {
        set: function (d) {
            console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
            this.shadow.camera.right = d;
        }
    }, shadowCameraTop: {
        set: function (d) {
            console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
            this.shadow.camera.top = d;
        }
    }, shadowCameraBottom: {
        set: function (d) {
            console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
            this.shadow.camera.bottom = d;
        }
    }, shadowCameraNear: {
        set: function (d) {
            console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
            this.shadow.camera.near = d;
        }
    }, shadowCameraFar: {
        set: function (d) {
            console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
            this.shadow.camera.far = d;
        }
    }, shadowCameraVisible: {
        set: function (d) {
            console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
        }
    }, shadowBias: {
        set: function (d) {
            console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
            this.shadow.bias = d;
        }
    }, shadowDarkness: {
        set: function (d) {
            console.warn('THREE.Light: .shadowDarkness has been removed.');
        }
    }, shadowMapWidth: {
        set: function (d) {
            console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
            this.shadow.mapSize.width = d;
        }
    }, shadowMapHeight: {
        set: function (d) {
            console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
            this.shadow.mapSize.height = d;
        }
    }
});
Object.defineProperties(THREE.BufferAttribute.prototype, {
    length: {
        get: function () {
            console.warn(Z1e.c4);
            return this.array.length;
        }
    }
});
Object.defineProperties(THREE.BufferGeometry.prototype, {
    drawcalls: {
        get: function () {
            console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
            return this.groups;
        }
    }, offsets: {
        get: function () {
            console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
            return this.groups;
        }
    }, addIndex: {
        value: function (d) {
            console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
            this.setIndex(d);
        }
    }, addDrawCall: {
        value: function (d, e, f) {
            if (f !== undefined) {
                console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
            }
            console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
            this.addGroup(d, e);
        }
    }, clearDrawCalls: {
        value: function () {
            console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
            this.clearGroups();
        }
    }, computeTangents: {
        value: function () {
            console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
        }
    }, computeOffsets: {
        value: function () {
            console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
        }
    }
});
Object.defineProperties(THREE.Material.prototype, {
    wrapAround: {
        get: function () {
            console.warn(Z1e.I1 + this.type + Z1e.U0);
        }, set: function (d) {
            console.warn(Z1e.I1 + this.type + Z1e.U0);
        }
    }, wrapRGB: {
        get: function () {
            console.warn(Z1e.I1 + this.type + ': .wrapRGB has been removed.');
            return new THREE.Color();
        }
    }
});
Object.defineProperties(THREE, {
    PointCloudMaterial: {
        value: function (d) {
            console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
            return new THREE.PointsMaterial(d);
        }
    }, ParticleBasicMaterial: {
        value: function (d) {
            console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
            return new THREE.PointsMaterial(d);
        }
    }, ParticleSystemMaterial: {
        value: function (d) {
            console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
            return new THREE.PointsMaterial(d);
        }
    }
});
Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
    metal: {
        get: function () {
            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
            return Z1e.e4;
        }, set: function (d) {
            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
        }
    }
});
Object.defineProperties(THREE.ShaderMaterial.prototype, {
    derivatives: {
        get: function () {
            console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            return this.extensions.derivatives;
        }, set: function (d) {
            console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            this.extensions.derivatives = d;
        }
    }
});
Object.defineProperties(THREE.WebGLRenderer.prototype, {
    supportsFloatTextures: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
            return this.extensions.get(Z1e.a0);
        }
    }, supportsHalfFloatTextures: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
            return this.extensions.get(Z1e.P);
        }
    }, supportsStandardDerivatives: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
            return this.extensions.get(Z1e.J3);
        }
    }, supportsCompressedTextureS3TC: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
            return this.extensions.get(Z1e.k3);
        }
    }, supportsCompressedTexturePVRTC: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
            return this.extensions.get(Z1e.R3);
        }
    }, supportsBlendMinMax: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
            return this.extensions.get(Z1e.s4);
        }
    }, supportsVertexTextures: {
        value: function () {
            return this.capabilities.vertexTextures;
        }
    }, supportsInstancedArrays: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
            return this.extensions.get(Z1e.X2);
        }
    }, enableScissorTest: {
        value: function (d) {
            console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
            this.setScissorTest(d);
        }
    }, initMaterial: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
        }
    }, addPrePlugin: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
        }
    }, addPostPlugin: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
        }
    }, updateShadowMap: {
        value: function () {
            console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
        }
    }, shadowMapEnabled: {
        get: function () {
            return this.shadowMap.enabled;
        }, set: function (d) {
            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
            this.shadowMap.enabled = d;
        }
    }, shadowMapType: {
        get: function () {
            return this.shadowMap.type;
        }, set: function (d) {
            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
            this.shadowMap.type = d;
        }
    }, shadowMapCullFace: {
        get: function () {
            return this.shadowMap.cullFace;
        }, set: function (d) {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
            this.shadowMap.cullFace = d;
        }
    }
});
Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
    wrapS: {
        get: function () {
            console.warn(Z1e.H0);
            return this.texture.wrapS;
        }, set: function (d) {
            console.warn(Z1e.H0);
            this.texture.wrapS = d;
        }
    }, wrapT: {
        get: function () {
            console.warn(Z1e.Y0);
            return this.texture.wrapT;
        }, set: function (d) {
            console.warn(Z1e.Y0);
            this.texture.wrapT = d;
        }
    }, magFilter: {
        get: function () {
            console.warn(Z1e.G2);
            return this.texture.magFilter;
        }, set: function (d) {
            console.warn(Z1e.G2);
            this.texture.magFilter = d;
        }
    }, minFilter: {
        get: function () {
            console.warn(Z1e.R1);
            return this.texture.minFilter;
        }, set: function (d) {
            console.warn(Z1e.R1);
            this.texture.minFilter = d;
        }
    }, anisotropy: {
        get: function () {
            console.warn(Z1e.E0);
            return this.texture.anisotropy;
        }, set: function (d) {
            console.warn(Z1e.E0);
            this.texture.anisotropy = d;
        }
    }, offset: {
        get: function () {
            console.warn(Z1e.O3);
            return this.texture.offset;
        }, set: function (d) {
            console.warn(Z1e.O3);
            this.texture.offset = d;
        }
    }, repeat: {
        get: function () {
            console.warn(Z1e.l4);
            return this.texture.repeat;
        }, set: function (d) {
            console.warn(Z1e.l4);
            this.texture.repeat = d;
        }
    }, format: {
        get: function () {
            console.warn(Z1e.q2);
            return this.texture.format;
        }, set: function (d) {
            console.warn(Z1e.q2);
            this.texture.format = d;
        }
    }, type: {
        get: function () {
            console.warn(Z1e.u2);
            return this.texture.type;
        }, set: function (d) {
            console.warn(Z1e.u2);
            this.texture.type = d;
        }
    }, generateMipmaps: {
        get: function () {
            console.warn(Z1e.G1);
            return this.texture.generateMipmaps;
        }, set: function (d) {
            console.warn(Z1e.G1);
            this.texture.generateMipmaps = d;
        }
    }
});
Object.defineProperties(THREE.Audio.prototype, {
    load: {
        value: function (e) {
            console.warn('THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.');
            var f = this, i = new THREE.AudioLoader();
            i.load(e, function (d) {
                f.setBuffer(d);
            });
            return this;
        }
    }
});
THREE.GeometryUtils = {
    merge: function (d, e, f) {
        console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
        var i;
        if (e instanceof THREE.Mesh) {
            e.matrixAutoUpdate && e.updateMatrix();
            i = e.matrix;
            e = e.geometry;
        }
        d.merge(e, i, f);
    }, center: function (d) {
        console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
        return d.center();
    }
};
THREE.ImageUtils = {
    crossOrigin: undefined, loadTexture: function (d, e, f, i) {
        console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
        var j = new THREE.TextureLoader();
        j.setCrossOrigin(this.crossOrigin);
        var k = j.load(d, f, undefined, i);
        if (e) k.mapping = e;
        return k;
    }, loadTextureCube: function (d, e, f, i) {
        console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
        var j = new THREE.CubeTextureLoader();
        j.setCrossOrigin(this.crossOrigin);
        var k = j.load(d, f, undefined, i);
        if (e) k.mapping = e;
        return k;
    }, loadCompressedTexture: function () {
        console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
    }, loadCompressedTextureCube: function () {
        console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
    }
};
THREE.Projector = function () {
    console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
    this.projectVector = function (d, e) {
        console.warn('THREE.Projector: .projectVector() is now vector.project().');
        d.project(e);
    };
    this.unprojectVector = function (d, e) {
        console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
        d.unproject(e);
    };
    this.pickingRay = function (d, e) {
        console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
    };
};
THREE.CanvasRenderer = function () {
    console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
    this.domElement = document.createElement(Z1e.M);
    this.clear = function () {
    };
    this.render = function () {
    };
    this.setClearColor = function () {
    };
    this.setSize = function () {
    };
};
THREE.MeshFaceMaterial = THREE.MultiMaterial;
Object.defineProperties(THREE.LOD.prototype, {
    objects: {
        get: function () {
            console.warn('THREE.LOD: .objects has been renamed to .levels.');
            return this.levels;
        }
    }
});
THREE.CurveUtils = {
    tangentQuadraticBezier: function (d, e, f, i) {
        return 2 * (1 - d) * (f - e) + 2 * d * (i - f);
    }, tangentCubicBezier: function (d, e, f, i, j) {
        return -3 * e * (1 - d) * (1 - d) + 3 * f * (1 - d) * (1 - d) - 6 * d * f * (1 - d) + 6 * d * i * (1 - d) - 3 * d * d * i + 3 * d * d * j;
    }, tangentSpline: function (d, e, f, i, j) {
        var k = 6 * d * d - 6 * d, m = 3 * d * d - 4 * d + 1, n = -6 * d * d + 6 * d, u = 3 * d * d - 2 * d;
        return k + m + n + u;
    }, interpolate: function (d, e, f, i, j) {
        var k = (f - d) * Z1e.k1, m = (i - e) * Z1e.k1, n = j * j, u = j * n;
        return (2 * e - 2 * f + k + m) * u + (-3 * e + 3 * f - 2 * k - m) * n + k * j + e;
    }
};
THREE.SceneUtils = {
    createMultiMaterialObject: function (d, e) {
        var f = new THREE.Group();
        for (var i = 0, j = e.length; i < j; i++) {
            f.add(new THREE.Mesh(d, e[i]));
        }
        return f;
    }, detach: function (d, e, f) {
        d.applyMatrix(e.matrixWorld);
        e.remove(d);
        f.add(d);
    }, attach: function (d, e, f) {
        var i = new THREE.Matrix4();
        i.getInverse(f.matrixWorld);
        d.applyMatrix(i);
        e.remove(d);
        f.add(d);
    }
};
THREE.ShapeUtils = {
    area: function (d) {
        var e = d.length, f = Z1e.l1;
        for (var i = e - 1, j = 0; j < e; i = j++) {
            f += d[i].x * d[j].y - d[j].x * d[i].y;
        }
        return f * Z1e.k1;
    }, triangulate: (function () {
        function y0(d, e, f, i, j, k) {
            var m, n, u, v, B, C, G, L, N;
            n = d[k[e]].x;
            u = d[k[e]].y;
            v = d[k[f]].x;
            B = d[k[f]].y;
            C = d[k[i]].x;
            G = d[k[i]].y;
            if (Number.EPSILON > (((v - n) * (G - u)) - ((B - u) * (C - n))))return Z1e.e4;
            var T, S, b0, h0, f0, i0, s0, t0, o0, w0, x0, D0, F0, m0, W0;
            T = C - v;
            S = G - B;
            b0 = n - C;
            h0 = u - G;
            f0 = v - n;
            i0 = B - u;
            for (m = 0; m < j; m++) {
                L = d[k[m]].x;
                N = d[k[m]].y;
                if (((L === n) && (N === u)) || ((L === v) && (N === B)) || ((L === C) && (N === G)))continue;
                s0 = L - n;
                t0 = N - u;
                o0 = L - v;
                w0 = N - B;
                x0 = L - C;
                D0 = N - G;
                W0 = T * w0 - S * o0;
                F0 = f0 * t0 - i0 * s0;
                m0 = b0 * D0 - h0 * x0;
                if ((W0 >= -Number.EPSILON) && (m0 >= -Number.EPSILON) && (F0 >= -Number.EPSILON))return Z1e.e4;
            }
            return Z1e.n3;
        }
        return function (d, e) {
            var f = d.length;
            if (f < 3)return Z1e.l3;
            var i = [], j = [], k = [], m, n, u;
            if (THREE.ShapeUtils.area(d) > Z1e.l1) {
                for (n = 0; n < f; n++)j[n] = n;
            } else {
                for (n = 0; n < f; n++)j[n] = (f - 1) - n;
            }
            var v = f, B = 2 * v;
            for (n = v - 1; v > 2;) {
                if ((B--) <= 0) {
                    console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
                    if (e)return k;
                    return i;
                }
                m = n;
                if (v <= m) m = 0;
                n = m + 1;
                if (v <= n) n = 0;
                u = n + 1;
                if (v <= u) u = 0;
                if (y0(d, m, n, u, v, j)) {
                    var C, G, L, N, T;
                    C = j[m];
                    G = j[n];
                    L = j[u];
                    i.push([d[C], d[G], d[L]]);
                    k.push([j[m], j[n], j[u]]);
                    for (N = n, T = n + 1; T < v; N++, T++) {
                        j[N] = j[T];
                    }
                    v--;
                    B = 2 * v;
                }
            }
            if (e)return k;
            return i;
        };
    })(), triangulateShape: function (G0, a1) {
        function b1(d, e, f) {
            if (d.x !== e.x) {
                if (d.x < e.x) {
                    return ((d.x <= f.x) && (f.x <= e.x));
                } else {
                    return ((e.x <= f.x) && (f.x <= d.x));
                }
            } else {
                if (d.y < e.y) {
                    return ((d.y <= f.y) && (f.y <= e.y));
                } else {
                    return ((e.y <= f.y) && (f.y <= d.y));
                }
            }
        }
        function X0(d, e, f, i, j) {
            var k = e.x - d.x, m = e.y - d.y, n = i.x - f.x, u = i.y - f.y, v = d.x - f.x, B = d.y - f.y,
                C = m * n - k * u, G = m * v - k * B;
            if (Math.abs(C) > Number.EPSILON) {
                var L;
                if (C > 0) {
                    if ((G < 0) || (G > C))return [];
                    L = u * v - n * B;
                    if ((L < 0) || (L > C))return [];
                } else {
                    if ((G > 0) || (G < C))return [];
                    L = u * v - n * B;
                    if ((L > 0) || (L < C))return [];
                }
                if (L === 0) {
                    if ((j) && ((G === 0) || (G === C)))return [];
                    return [d];
                }
                if (L === C) {
                    if ((j) && ((G === 0) || (G === C)))return [];
                    return [e];
                }
                if (G === 0)return [f];
                if (G === C)return [i];
                var N = L / C;
                return [{x: d.x + N * k, y: d.y + N * m}];
            } else {
                if ((G !== 0) || (u * v !== n * B))return [];
                var T = ((k === 0) && (m === 0)), S = ((n === 0) && (u === 0));
                if (T && S) {
                    if ((d.x !== f.x) || (d.y !== f.y))return [];
                    return [d];
                }
                if (T) {
                    if (!b1(f, i, d))return [];
                    return [d];
                }
                if (S) {
                    if (!b1(d, e, f))return [];
                    return [f];
                }
                var b0, h0, f0, i0, s0, t0, o0, w0;
                if (k !== 0) {
                    if (d.x < e.x) {
                        b0 = d;
                        f0 = d.x;
                        h0 = e;
                        i0 = e.x;
                    } else {
                        b0 = e;
                        f0 = e.x;
                        h0 = d;
                        i0 = d.x;
                    }
                    if (f.x < i.x) {
                        s0 = f;
                        o0 = f.x;
                        t0 = i;
                        w0 = i.x;
                    } else {
                        s0 = i;
                        o0 = i.x;
                        t0 = f;
                        w0 = f.x;
                    }
                } else {
                    if (d.y < e.y) {
                        b0 = d;
                        f0 = d.y;
                        h0 = e;
                        i0 = e.y;
                    } else {
                        b0 = e;
                        f0 = e.y;
                        h0 = d;
                        i0 = d.y;
                    }
                    if (f.y < i.y) {
                        s0 = f;
                        o0 = f.y;
                        t0 = i;
                        w0 = i.y;
                    } else {
                        s0 = i;
                        o0 = i.y;
                        t0 = f;
                        w0 = f.y;
                    }
                }
                if (f0 <= o0) {
                    if (i0 < o0)return [];
                    if (i0 === o0) {
                        if (j)return [];
                        return [s0];
                    }
                    if (i0 <= w0)return [s0, h0];
                    return [s0, t0];
                } else {
                    if (f0 > w0)return [];
                    if (f0 === w0) {
                        if (j)return [];
                        return [b0];
                    }
                    if (i0 <= w0)return [b0, h0];
                    return [b0, t0];
                }
            }
        }
        function o1(d, e, f, i) {
            var j = e.x - d.x, k = e.y - d.y, m = f.x - d.x, n = f.y - d.y, u = i.x - d.x, v = i.y - d.y,
                B = j * n - k * m, C = j * v - k * u;
            if (Math.abs(B) > Number.EPSILON) {
                var G = u * n - v * m;
                if (B > 0) {
                    return ((C >= 0) && (G >= 0));
                } else {
                    return ((C >= 0) || (G >= 0));
                }
            } else {
                return (C > 0);
            }
        }
        function z0(v, B) {
            var C = v.concat(), G;
            function L(d, e) {
                var f = C.length - 1, i = d - 1;
                if (i < 0) i = f;
                var j = d + 1;
                if (j > f) j = 0;
                var k = o1(C[d], C[i], C[j], G[e]);
                if (!k) {
                    return Z1e.e4;
                }
                var m = G.length - 1, n = e - 1;
                if (n < 0) n = m;
                var u = e + 1;
                if (u > m) u = 0;
                k = o1(G[e], G[n], G[u], C[d]);
                if (!k) {
                    return Z1e.e4;
                }
                return Z1e.n3;
            }
            function N(d, e) {
                var f, i, j;
                for (f = 0; f < C.length; f++) {
                    i = f + 1;
                    i %= C.length;
                    j = X0(d, e, C[f], C[i], Z1e.n3);
                    if (j.length > 0)return Z1e.n3;
                }
                return Z1e.e4;
            }
            var T = [];
            function S(d, e) {
                var f, i, j, k, m;
                for (f = 0; f < T.length; f++) {
                    i = B[T[f]];
                    for (j = 0; j < i.length; j++) {
                        k = j + 1;
                        k %= i.length;
                        m = X0(d, e, i[j], i[k], Z1e.n3);
                        if (m.length > 0)return Z1e.n3;
                    }
                }
                return Z1e.e4;
            }
            var b0, h0, f0, i0, s0, t0, o0 = [], w0, x0, D0, F0;
            for (var m0 = 0, W0 = B.length; m0 < W0; m0++) {
                T.push(m0);
            }
            var y0 = 0, P0 = T.length * 2;
            while (T.length > 0) {
                P0--;
                if (P0 < 0) {
                    console.log("Infinite Loop! Holes left:" + T.length + ", Probably Hole outside Shape!");
                    break;
                }
                for (h0 = y0; h0 < C.length; h0++) {
                    f0 = C[h0];
                    b0 = -1;
                    for (var m0 = 0; m0 < T.length; m0++) {
                        s0 = T[m0];
                        t0 = f0.x + ":" + f0.y + ":" + s0;
                        if (o0[t0] !== undefined)continue;
                        G = B[s0];
                        for (var M0 = 0; M0 < G.length; M0++) {
                            i0 = G[M0];
                            if (!L(h0, M0))continue;
                            if (N(f0, i0))continue;
                            if (S(f0, i0))continue;
                            b0 = M0;
                            T.splice(m0, 1);
                            w0 = C.slice(0, h0 + 1);
                            x0 = C.slice(h0);
                            D0 = G.slice(b0);
                            F0 = G.slice(0, b0 + 1);
                            C = w0.concat(D0).concat(F0).concat(x0);
                            y0 = h0;
                            break;
                        }
                        if (b0 >= 0)break;
                        o0[t0] = Z1e.n3;
                    }
                    if (b0 >= 0)break;
                }
            }
            return C;
        }
        var Z0, q1, t1, s1, z1, w1, u1 = {}, L1 = G0.concat();
        for (var S1 = 0, y1 = a1.length; S1 < y1; S1++) {
            Array.prototype.push.apply(L1, a1[S1]);
        }
        for (Z0 = 0, q1 = L1.length; Z0 < q1; Z0++) {
            z1 = L1[Z0].x + ":" + L1[Z0].y;
            if (u1[z1] !== undefined) {
                console.warn("THREE.Shape: Duplicate point", z1);
            }
            u1[z1] = Z0;
        }
        var a2 = z0(G0, a1), P1 = THREE.ShapeUtils.triangulate(a2, Z1e.e4);
        for (Z0 = 0, q1 = P1.length; Z0 < q1; Z0++) {
            s1 = P1[Z0];
            for (t1 = 0; t1 < 3; t1++) {
                z1 = s1[t1].x + ":" + s1[t1].y;
                w1 = u1[z1];
                if (w1 !== undefined) {
                    s1[t1] = w1;
                }
            }
        }
        return P1.concat();
    }, isClockWise: function (d) {
        return THREE.ShapeUtils.area(d) < 0;
    }, b2: (function () {
        function j(d, e) {
            var f = 1 - d;
            return f * f * e;
        }
        function k(d, e) {
            return 2 * (1 - d) * d * e;
        }
        function m(d, e) {
            return d * d * e;
        }
        return function (d, e, f, i) {
            return j(d, e) + k(d, f) + m(d, i);
        };
    })(), b3: (function () {
        function k(d, e) {
            var f = 1 - d;
            return f * f * f * e;
        }
        function m(d, e) {
            var f = 1 - d;
            return 3 * f * f * d * e;
        }
        function n(d, e) {
            var f = 1 - d;
            return 3 * f * d * d * e;
        }
        function u(d, e) {
            return d * d * d * e;
        }
        return function (d, e, f, i, j) {
            return k(d, e) + m(d, f) + n(d, i) + u(d, j);
        };
    })()
};
THREE.Curve = function () {
};
THREE.Curve.prototype = {
    constructor: THREE.Curve, getPoint: function (d) {
        console.warn("THREE.Curve: Warning, getPoint() not implemented!");
        return Z1e.l3;
    }, getPointAt: function (d) {
        var e = this.getUtoTmapping(d);
        return this.getPoint(e);
    }, getPoints: function (d) {
        if (!d) d = 5;
        var e, f = [];
        for (e = 0; e <= d; e++) {
            f.push(this.getPoint(e / d));
        }
        return f;
    }, getSpacedPoints: function (d) {
        if (!d) d = 5;
        var e, f = [];
        for (e = 0; e <= d; e++) {
            f.push(this.getPointAt(e / d));
        }
        return f;
    }, getLength: function () {
        var d = this.getLengths();
        return d[d.length - 1];
    }, getLengths: function (d) {
        if (!d) d = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
        if (this.cacheArcLengths && (this.cacheArcLengths.length === d + 1) && !this.needsUpdate) {
            return this.cacheArcLengths;
        }
        this.needsUpdate = Z1e.e4;
        var e = [], f, i = this.getPoint(0), j, k = 0;
        e.push(0);
        for (j = 1; j <= d; j++) {
            f = this.getPoint(j / d);
            k += f.distanceTo(i);
            e.push(k);
            i = f;
        }
        this.cacheArcLengths = e;
        return e;
    }, updateArcLengths: function () {
        this.needsUpdate = Z1e.n3;
        this.getLengths();
    }, getUtoTmapping: function (d, e) {
        var f = this.getLengths(), i = 0, j = f.length, k;
        if (e) {
            k = e;
        } else {
            k = d * f[j - 1];
        }
        var m = 0, n = j - 1, u;
        while (m <= n) {
            i = Math.floor(m + (n - m) / 2);
            u = f[i] - k;
            if (u < 0) {
                m = i + 1;
            } else if (u > 0) {
                n = i - 1;
            } else {
                n = i;
                break;
            }
        }
        i = n;
        if (f[i] === k) {
            var v = i / (j - 1);
            return v;
        }
        var B = f[i], C = f[i + 1], G = C - B, L = (k - B) / G, v = (i + L) / (j - 1);
        return v;
    }, getTangent: function (d) {
        var e = 0.0001, f = d - e, i = d + e;
        if (f < 0) f = 0;
        if (i > 1) i = 1;
        var j = this.getPoint(f), k = this.getPoint(i), m = k.clone().sub(j);
        return m.normalize();
    }, getTangentAt: function (d) {
        var e = this.getUtoTmapping(d);
        return this.getTangent(e);
    }
};
THREE.Curve.create = function (d, e) {
    d.prototype = Object.create(THREE.Curve.prototype);
    d.prototype.constructor = d;
    d.prototype.getPoint = e;
    return d;
};
THREE.CurvePath = function () {
    this.curves = [];
    this.autoClose = Z1e.e4;
};
THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
THREE.CurvePath.prototype.constructor = THREE.CurvePath;
THREE.CurvePath.prototype.add = function (d) {
    this.curves.push(d);
};
THREE.CurvePath.prototype.closePath = function () {
    var d = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
    if (!d.equals(e)) {
        this.curves.push(new THREE.LineCurve(e, d));
    }
};
THREE.CurvePath.prototype.getPoint = function (d) {
    var e = d * this.getLength(), f = this.getCurveLengths(), i = 0;
    while (i < f.length) {
        if (f[i] >= e) {
            var j = f[i] - e, k = this.curves[i], m = 1 - j / k.getLength();
            return k.getPointAt(m);
        }
        i++;
    }
    return Z1e.l3;
};
THREE.CurvePath.prototype.getLength = function () {
    var d = this.getCurveLengths();
    return d[d.length - 1];
};
THREE.CurvePath.prototype.getCurveLengths = function () {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
    }
    var d = [], e = 0;
    for (var f = 0, i = this.curves.length; f < i; f++) {
        e += this.curves[f].getLength();
        d.push(e);
    }
    this.cacheLengths = d;
    return d;
};
THREE.CurvePath.prototype.createPointsGeometry = function (d) {
    var e = this.getPoints(d);
    return this.createGeometry(e);
};
THREE.CurvePath.prototype.createSpacedPointsGeometry = function (d) {
    var e = this.getSpacedPoints(d);
    return this.createGeometry(e);
};
THREE.CurvePath.prototype.createGeometry = function (d) {
    var e = new THREE.Geometry();
    for (var f = 0, i = d.length; f < i; f++) {
        var j = d[f];
        e.vertices.push(new THREE.Vector3(j.x, j.y, j.z || 0));
    }
    return e;
};
THREE.Font = function (d) {
    this.data = d;
};
THREE.Font.prototype = {
    constructor: THREE.Font, generateShapes: function (x0, D0, F0) {
        function m0(d) {
            var e = String(d).split(''), f = D0 / y0.resolution, i = 0, j = [];
            for (var k = 0; k < e.length; k++) {
                var m = W0(e[k], f, i);
                i += m.offset;
                j.push(m.path);
            }
            return j;
        }
        function W0(d, e, f) {
            var i = y0.glyphs[d] || y0.glyphs['?'];
            if (!i)return;
            var j = new THREE.Path(), k = [], m = THREE.ShapeUtils.b2, n = THREE.ShapeUtils.b3, u, v, B, C, G, L, N, T,
                S, b0, h0;
            if (i.o) {
                var f0 = i._cachedOutline || (i._cachedOutline = i.o.split(' '));
                for (var i0 = 0, s0 = f0.length; i0 < s0;) {
                    var t0 = f0[i0++];
                    switch (t0) {
                        case 'm':
                            u = f0[i0++] * e + f;
                            v = f0[i0++] * e;
                            j.moveTo(u, v);
                            break;
                        case 'l':
                            u = f0[i0++] * e + f;
                            v = f0[i0++] * e;
                            j.lineTo(u, v);
                            break;
                        case 'q':
                            B = f0[i0++] * e + f;
                            C = f0[i0++] * e;
                            N = f0[i0++] * e + f;
                            T = f0[i0++] * e;
                            j.quadraticCurveTo(N, T, B, C);
                            h0 = k[k.length - 1];
                            if (h0) {
                                G = h0.x;
                                L = h0.y;
                                for (var o0 = 1; o0 <= F0; o0++) {
                                    var w0 = o0 / F0;
                                    m(w0, G, N, B);
                                    m(w0, L, T, C);
                                }
                            }
                            break;
                        case 'b':
                            B = f0[i0++] * e + f;
                            C = f0[i0++] * e;
                            N = f0[i0++] * e + f;
                            T = f0[i0++] * e;
                            S = f0[i0++] * e + f;
                            b0 = f0[i0++] * e;
                            j.bezierCurveTo(N, T, S, b0, B, C);
                            h0 = k[k.length - 1];
                            if (h0) {
                                G = h0.x;
                                L = h0.y;
                                for (var o0 = 1; o0 <= F0; o0++) {
                                    var w0 = o0 / F0;
                                    n(w0, G, N, S, B);
                                    n(w0, L, T, b0, C);
                                }
                            }
                            break;
                    }
                }
            }
            return {offset: i.ha * e, path: j};
        }
        if (D0 === undefined) D0 = Z1e.j4;
        if (F0 === undefined) F0 = 4;
        var y0 = this.data, P0 = m0(x0), M0 = [];
        for (var G0 = 0, a1 = P0.length; G0 < a1; G0++) {
            Array.prototype.push.apply(M0, P0[G0].toShapes());
        }
        return M0;
    }
};
THREE.Path = function (d) {
    THREE.CurvePath.call(this);
    this.actions = [];
    if (d) {
        this.fromPoints(d);
    }
};
THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
THREE.Path.prototype.constructor = THREE.Path;
THREE.Path.prototype.fromPoints = function (d) {
    this.moveTo(d[0].x, d[0].y);
    for (var e = 1, f = d.length; e < f; e++) {
        this.lineTo(d[e].x, d[e].y);
    }
};
THREE.Path.prototype.moveTo = function (d, e) {
    this.actions.push({action: Z1e.a4, args: [d, e]});
};
THREE.Path.prototype.lineTo = function (d, e) {
    var f = this.actions[this.actions.length - 1].args, i = f[f.length - 2], j = f[f.length - 1],
        k = new THREE.LineCurve(new THREE.Vector2(i, j), new THREE.Vector2(d, e));
    this.curves.push(k);
    this.actions.push({action: 'lineTo', args: [d, e]});
};
THREE.Path.prototype.quadraticCurveTo = function (d, e, f, i) {
    var j = this.actions[this.actions.length - 1].args, k = j[j.length - 2], m = j[j.length - 1],
        n = new THREE.QuadraticBezierCurve(new THREE.Vector2(k, m), new THREE.Vector2(d, e), new THREE.Vector2(f, i));
    this.curves.push(n);
    this.actions.push({action: Z1e.l0, args: [d, e, f, i]});
};
THREE.Path.prototype.bezierCurveTo = function (d, e, f, i, j, k) {
    var m = this.actions[this.actions.length - 1].args, n = m[m.length - 2], u = m[m.length - 1],
        v = new THREE.CubicBezierCurve(new THREE.Vector2(n, u), new THREE.Vector2(d, e), new THREE.Vector2(f, i), new THREE.Vector2(j, k));
    this.curves.push(v);
    this.actions.push({action: Z1e.V0, args: [d, e, f, i, j, k]});
};
THREE.Path.prototype.splineThru = function (d) {
    var e = Array.prototype.slice.call(arguments), f = this.actions[this.actions.length - 1].args, i = f[f.length - 2],
        j = f[f.length - 1], k = [new THREE.Vector2(i, j)];
    Array.prototype.push.apply(k, d);
    var m = new THREE.SplineCurve(k);
    this.curves.push(m);
    this.actions.push({action: 'splineThru', args: e});
};
THREE.Path.prototype.arc = function (d, e, f, i, j, k) {
    var m = this.actions[this.actions.length - 1].args, n = m[m.length - 2], u = m[m.length - 1];
    this.absarc(d + n, e + u, f, i, j, k);
};
THREE.Path.prototype.absarc = function (d, e, f, i, j, k) {
    this.absellipse(d, e, f, f, i, j, k);
};
THREE.Path.prototype.ellipse = function (d, e, f, i, j, k, m, n) {
    var u = this.actions[this.actions.length - 1].args, v = u[u.length - 2], B = u[u.length - 1];
    this.absellipse(d + v, e + B, f, i, j, k, m, n);
};
THREE.Path.prototype.absellipse = function (d, e, f, i, j, k, m, n) {
    var u = [d, e, f, i, j, k, m, n || 0], v = new THREE.EllipseCurve(d, e, f, i, j, k, m, n);
    this.curves.push(v);
    var B = v.getPoint(1);
    u.push(B.x);
    u.push(B.y);
    this.actions.push({action: 'ellipse', args: u});
};
THREE.Path.prototype.getSpacedPoints = function (d) {
    if (!d) d = 40;
    var e = [];
    for (var f = 0; f < d; f++) {
        e.push(this.getPoint(f / d));
    }
    if (this.autoClose) {
        e.push(e[0]);
    }
    return e;
};
THREE.Path.prototype.getPoints = function (d) {
    d = d || 12;
    var e = THREE.ShapeUtils.b2, f = THREE.ShapeUtils.b3, i = [], j, k, m, n, u, v, B, C, G, L, N;
    for (var T = 0, S = this.actions.length; T < S; T++) {
        var b0 = this.actions[T], h0 = b0.action, f0 = b0.args;
        switch (h0) {
            case Z1e.a4:
                i.push(new THREE.Vector2(f0[0], f0[1]));
                break;
            case 'lineTo':
                i.push(new THREE.Vector2(f0[0], f0[1]));
                break;
            case Z1e.l0:
                j = f0[2];
                k = f0[3];
                u = f0[0];
                v = f0[1];
                if (i.length > 0) {
                    G = i[i.length - 1];
                    B = G.x;
                    C = G.y;
                } else {
                    G = this.actions[T - 1].args;
                    B = G[G.length - 2];
                    C = G[G.length - 1];
                }
                for (var i0 = 1; i0 <= d; i0++) {
                    var s0 = i0 / d;
                    L = e(s0, B, u, j);
                    N = e(s0, C, v, k);
                    i.push(new THREE.Vector2(L, N));
                }
                break;
            case Z1e.V0:
                j = f0[4];
                k = f0[5];
                u = f0[0];
                v = f0[1];
                m = f0[2];
                n = f0[3];
                if (i.length > 0) {
                    G = i[i.length - 1];
                    B = G.x;
                    C = G.y;
                } else {
                    G = this.actions[T - 1].args;
                    B = G[G.length - 2];
                    C = G[G.length - 1];
                }
                for (var i0 = 1; i0 <= d; i0++) {
                    var s0 = i0 / d;
                    L = f(s0, B, u, m, j);
                    N = f(s0, C, v, n, k);
                    i.push(new THREE.Vector2(L, N));
                }
                break;
            case 'splineThru':
                G = this.actions[T - 1].args;
                var t0 = new THREE.Vector2(G[G.length - 2], G[G.length - 1]), o0 = [t0], w0 = d * f0[0].length;
                o0 = o0.concat(f0[0]);
                var x0 = new THREE.SplineCurve(o0);
                for (var i0 = 1; i0 <= w0; i0++) {
                    i.push(x0.getPointAt(i0 / w0));
                }
                break;
            case 'arc':
                var D0 = f0[0], F0 = f0[1], m0 = f0[2], W0 = f0[3], y0 = f0[4], P0 = !!f0[5], M0 = y0 - W0, G0,
                    a1 = d * 2;
                for (var i0 = 1; i0 <= a1; i0++) {
                    var s0 = i0 / a1;
                    if (!P0) {
                        s0 = 1 - s0;
                    }
                    G0 = W0 + s0 * M0;
                    L = D0 + m0 * Math.cos(G0);
                    N = F0 + m0 * Math.sin(G0);
                    i.push(new THREE.Vector2(L, N));
                }
                break;
            case 'ellipse':
                var D0 = f0[0], F0 = f0[1], b1 = f0[2], X0 = f0[3], W0 = f0[4], y0 = f0[5], P0 = !!f0[6], o1 = f0[7],
                    M0 = y0 - W0, G0, a1 = d * 2, z0, Z0;
                if (o1 !== 0) {
                    z0 = Math.cos(o1);
                    Z0 = Math.sin(o1);
                }
                for (var i0 = 1; i0 <= a1; i0++) {
                    var s0 = i0 / a1;
                    if (!P0) {
                        s0 = 1 - s0;
                    }
                    G0 = W0 + s0 * M0;
                    L = D0 + b1 * Math.cos(G0);
                    N = F0 + X0 * Math.sin(G0);
                    if (o1 !== 0) {
                        var q1 = L, t1 = N;
                        L = (q1 - D0) * z0 - (t1 - F0) * Z0 + D0;
                        N = (q1 - D0) * Z0 + (t1 - F0) * z0 + F0;
                    }
                    i.push(new THREE.Vector2(L, N));
                }
                break;
        }
    }
    var s1 = i[i.length - 1];
    if (Math.abs(s1.x - i[0].x) < Number.EPSILON && Math.abs(s1.y - i[0].y) < Number.EPSILON) i.splice(i.length - 1, 1);
    if (this.autoClose) {
        i.push(i[0]);
    }
    return i;
};
THREE.Path.prototype.toShapes = function (C, G) {
    function L(d) {
        var e = [], f = new THREE.Path();
        for (var i = 0, j = d.length; i < j; i++) {
            var k = d[i], m = k.args, n = k.action;
            if (n === Z1e.a4) {
                if (f.actions.length !== 0) {
                    e.push(f);
                    f = new THREE.Path();
                }
            }
            f[n].apply(f, m);
        }
        if (f.actions.length !== 0) {
            e.push(f);
        }
        return e;
    }
    function N(d) {
        var e = [];
        for (var f = 0, i = d.length; f < i; f++) {
            var j = d[f], k = new THREE.Shape();
            k.actions = j.actions;
            k.curves = j.curves;
            e.push(k);
        }
        return e;
    }
    function T(d, e) {
        var f = e.length, i = Z1e.e4;
        for (var j = f - 1, k = 0; k < f; j = k++) {
            var m = e[j], n = e[k], u = n.x - m.x, v = n.y - m.y;
            if (Math.abs(v) > Number.EPSILON) {
                if (v < 0) {
                    m = e[k];
                    u = -u;
                    n = e[j];
                    v = -v;
                }
                if ((d.y < m.y) || (d.y > n.y))continue;
                if (d.y === m.y) {
                    if (d.x === m.x)return Z1e.n3;
                } else {
                    var B = v * (d.x - m.x) - u * (d.y - m.y);
                    if (B === 0)return Z1e.n3;
                    if (B < 0)continue;
                    i = !i;
                }
            } else {
                if (d.y !== m.y)continue;
                if (((n.x <= d.x) && (d.x <= m.x)) || ((m.x <= d.x) && (d.x <= n.x)))return Z1e.n3;
            }
        }
        return i;
    }
    var S = THREE.ShapeUtils.isClockWise, b0 = L(this.actions);
    if (b0.length === 0)return [];
    if (G === Z1e.n3)return N(b0);
    var h0, f0, i0, s0 = [];
    if (b0.length === 1) {
        f0 = b0[0];
        i0 = new THREE.Shape();
        i0.actions = f0.actions;
        i0.curves = f0.curves;
        s0.push(i0);
        return s0;
    }
    var t0 = !S(b0[0].getPoints());
    t0 = C ? !t0 : t0;
    var o0 = [], w0 = [], x0 = [], D0 = 0, F0;
    w0[D0] = undefined;
    x0[D0] = [];
    for (var m0 = 0, W0 = b0.length; m0 < W0; m0++) {
        f0 = b0[m0];
        F0 = f0.getPoints();
        h0 = S(F0);
        h0 = C ? !h0 : h0;
        if (h0) {
            if ((!t0) && (w0[D0])) D0++;
            w0[D0] = {s: new THREE.Shape(), p: F0};
            w0[D0].s.actions = f0.actions;
            w0[D0].s.curves = f0.curves;
            if (t0) D0++;
            x0[D0] = [];
        } else {
            x0[D0].push({h: f0, p: F0[0]});
        }
    }
    if (!w0[0])return N(b0);
    if (w0.length > 1) {
        var y0 = Z1e.e4, P0 = [];
        for (var M0 = 0, G0 = w0.length; M0 < G0; M0++) {
            o0[M0] = [];
        }
        for (var M0 = 0, G0 = w0.length; M0 < G0; M0++) {
            var a1 = x0[M0];
            for (var b1 = 0; b1 < a1.length; b1++) {
                var X0 = a1[b1], o1 = Z1e.n3;
                for (var z0 = 0; z0 < w0.length; z0++) {
                    if (T(X0.p, w0[z0].p)) {
                        if (M0 !== z0) P0.push({froms: M0, tos: z0, hole: b1});
                        if (o1) {
                            o1 = Z1e.e4;
                            o0[z0].push(X0);
                        } else {
                            y0 = Z1e.n3;
                        }
                    }
                }
                if (o1) {
                    o0[M0].push(X0);
                }
            }
        }
        if (P0.length > 0) {
            if (!y0) x0 = o0;
        }
    }
    var Z0;
    for (var m0 = 0, q1 = w0.length; m0 < q1; m0++) {
        i0 = w0[m0].s;
        s0.push(i0);
        Z0 = x0[m0];
        for (var t1 = 0, s1 = Z0.length; t1 < s1; t1++) {
            i0.holes.push(Z0[t1].h);
        }
    }
    return s0;
};
THREE.Shape = function () {
    THREE.Path.apply(this, arguments);
    this.holes = [];
};
THREE.Shape.prototype = Object.create(THREE.Path.prototype);
THREE.Shape.prototype.constructor = THREE.Shape;
THREE.Shape.prototype.extrude = function (d) {
    return new THREE.ExtrudeGeometry(this, d);
};
THREE.Shape.prototype.makeGeometry = function (d) {
    return new THREE.ShapeGeometry(this, d);
};
THREE.Shape.prototype.getPointsHoles = function (d) {
    var e = [];
    for (var f = 0, i = this.holes.length; f < i; f++) {
        e[f] = this.holes[f].getPoints(d);
    }
    return e;
};
THREE.Shape.prototype.extractAllPoints = function (d) {
    return {shape: this.getPoints(d), holes: this.getPointsHoles(d)};
};
THREE.Shape.prototype.extractPoints = function (d) {
    return this.extractAllPoints(d);
};
THREE.LineCurve = function (d, e) {
    this.v1 = d;
    this.v2 = e;
};
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.LineCurve.prototype.constructor = THREE.LineCurve;
THREE.LineCurve.prototype.getPoint = function (d) {
    var e = this.v2.clone().sub(this.v1);
    e.multiplyScalar(d).add(this.v1);
    return e;
};
THREE.LineCurve.prototype.getPointAt = function (d) {
    return this.getPoint(d);
};
THREE.LineCurve.prototype.getTangent = function (d) {
    var e = this.v2.clone().sub(this.v1);
    return e.normalize();
};
THREE.QuadraticBezierCurve = function (d, e, f) {
    this.v0 = d;
    this.v1 = e;
    this.v2 = f;
};
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
THREE.QuadraticBezierCurve.prototype.getPoint = function (d) {
    var e = THREE.ShapeUtils.b2;
    return new THREE.Vector2(e(d, this.v0.x, this.v1.x, this.v2.x), e(d, this.v0.y, this.v1.y, this.v2.y));
};
THREE.QuadraticBezierCurve.prototype.getTangent = function (d) {
    var e = THREE.CurveUtils.tangentQuadraticBezier;
    return new THREE.Vector2(e(d, this.v0.x, this.v1.x, this.v2.x), e(d, this.v0.y, this.v1.y, this.v2.y)).normalize();
};
THREE.CubicBezierCurve = function (d, e, f, i) {
    this.v0 = d;
    this.v1 = e;
    this.v2 = f;
    this.v3 = i;
};
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
THREE.CubicBezierCurve.prototype.getPoint = function (d) {
    var e = THREE.ShapeUtils.b3;
    return new THREE.Vector2(e(d, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e(d, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
};
THREE.CubicBezierCurve.prototype.getTangent = function (d) {
    var e = THREE.CurveUtils.tangentCubicBezier;
    return new THREE.Vector2(e(d, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e(d, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
};
THREE.SplineCurve = function (d) {
    this.points = (d == undefined) ? [] : d;
};
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
THREE.SplineCurve.prototype.getPoint = function (d) {
    var e = this.points, f = (e.length - 1) * d, i = Math.floor(f), j = f - i, k = e[i === 0 ? i : i - 1], m = e[i],
        n = e[i > e.length - 2 ? e.length - 1 : i + 1], u = e[i > e.length - 3 ? e.length - 1 : i + 2],
        v = THREE.CurveUtils.interpolate;
    return new THREE.Vector2(v(k.x, m.x, n.x, u.x, j), v(k.y, m.y, n.y, u.y, j));
};
THREE.EllipseCurve = function (d, e, f, i, j, k, m, n) {
    this.aX = d;
    this.aY = e;
    this.xRadius = f;
    this.yRadius = i;
    this.aStartAngle = j;
    this.aEndAngle = k;
    this.aClockwise = m;
    this.aRotation = n || 0;
};
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
THREE.EllipseCurve.prototype.getPoint = function (d) {
    var e = this.aEndAngle - this.aStartAngle;
    if (e < 0) e += Math.PI * 2;
    if (e > Math.PI * 2) e -= Math.PI * 2;
    var f;
    if (this.aClockwise === Z1e.n3) {
        f = this.aEndAngle + (1 - d) * (Math.PI * 2 - e);
    } else {
        f = this.aStartAngle + d * e;
    }
    var i = this.aX + this.xRadius * Math.cos(f), j = this.aY + this.yRadius * Math.sin(f);
    if (this.aRotation !== 0) {
        var k = Math.cos(this.aRotation), m = Math.sin(this.aRotation), n = i, u = j;
        i = (n - this.aX) * k - (u - this.aY) * m + this.aX;
        j = (n - this.aX) * m + (u - this.aY) * k + this.aY;
    }
    return new THREE.Vector2(i, j);
};
THREE.ArcCurve = function (d, e, f, i, j, k) {
    THREE.EllipseCurve.call(this, d, e, f, f, i, j, k);
};
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
THREE.LineCurve3 = THREE.Curve.create(function (d, e) {
    this.v1 = d;
    this.v2 = e;
}, function (d) {
    var e = new THREE.Vector3();
    e.subVectors(this.v2, this.v1);
    e.multiplyScalar(d);
    e.add(this.v1);
    return e;
});
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (d, e, f) {
    this.v0 = d;
    this.v1 = e;
    this.v2 = f;
}, function (d) {
    var e = THREE.ShapeUtils.b2;
    return new THREE.Vector3(e(d, this.v0.x, this.v1.x, this.v2.x), e(d, this.v0.y, this.v1.y, this.v2.y), e(d, this.v0.z, this.v1.z, this.v2.z));
});
THREE.CubicBezierCurve3 = THREE.Curve.create(function (d, e, f, i) {
    this.v0 = d;
    this.v1 = e;
    this.v2 = f;
    this.v3 = i;
}, function (d) {
    var e = THREE.ShapeUtils.b3;
    return new THREE.Vector3(e(d, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e(d, this.v0.y, this.v1.y, this.v2.y, this.v3.y), e(d, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
});
THREE.SplineCurve3 = THREE.Curve.create(function (d) {
    console.warn('THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3');
    this.points = (d == undefined) ? [] : d;
}, function (d) {
    var e = this.points, f = (e.length - 1) * d, i = Math.floor(f), j = f - i, k = e[i == 0 ? i : i - 1], m = e[i],
        n = e[i > e.length - 2 ? e.length - 1 : i + 1], u = e[i > e.length - 3 ? e.length - 1 : i + 2],
        v = THREE.CurveUtils.interpolate;
    return new THREE.Vector3(v(k.x, m.x, n.x, u.x, j), v(k.y, m.y, n.y, u.y, j), v(k.z, m.z, n.z, u.z, j));
});
THREE.CatmullRomCurve3 = (function () {
    var S = new THREE.Vector3(), b0 = new i0(), h0 = new i0(), f0 = new i0();
    function i0() {
    }
    i0.prototype.init = function (d, e, f, i) {
        this.c0 = d;
        this.c1 = f;
        this.c2 = -3 * d + 3 * e - 2 * f - i;
        this.c3 = 2 * d - 2 * e + f + i;
    };
    i0.prototype.initNonuniformCatmullRom = function (d, e, f, i, j, k, m) {
        var n = (e - d) / j - (f - d) / (j + k) + (f - e) / k, u = (f - e) / k - (i - e) / (k + m) + (i - f) / m;
        n *= k;
        u *= k;
        this.init(e, f, n, u);
    };
    i0.prototype.initCatmullRom = function (d, e, f, i, j) {
        this.init(e, f, j * (f - d), j * (i - e));
    };
    i0.prototype.calc = function (d) {
        var e = d * d, f = e * d;
        return this.c0 + this.c1 * d + this.c2 * e + this.c3 * f;
    };
    return THREE.Curve.create(function (d) {
        this.points = d || [];
        this.closed = Z1e.e4;
    }, function (d) {
        var e = this.points, f, i, j, k;
        k = e.length;
        if (k < 2) console.log('duh, you need at least 2 points');
        f = (k - (this.closed ? 0 : 1)) * d;
        i = Math.floor(f);
        j = f - i;
        if (this.closed) {
            i += i > 0 ? 0 : (Math.floor(Math.abs(i) / e.length) + 1) * e.length;
        } else if (j === 0 && i === k - 1) {
            i = k - 2;
            j = 1;
        }
        var m, n, u, v;
        if (this.closed || i > 0) {
            m = e[(i - 1) % k];
        } else {
            S.subVectors(e[0], e[1]).add(e[0]);
            m = S;
        }
        n = e[i % k];
        u = e[(i + 1) % k];
        if (this.closed || i + 2 < k) {
            v = e[(i + 2) % k];
        } else {
            S.subVectors(e[k - 1], e[k - 2]).add(e[k - 1]);
            v = S;
        }
        if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
            var B = this.type === 'chordal' ? Z1e.k1 : Z1e.k0, C = Math.pow(m.distanceToSquared(n), B),
                G = Math.pow(n.distanceToSquared(u), B), L = Math.pow(u.distanceToSquared(v), B);
            if (G < 1e-4) G = Z1e.d4;
            if (C < 1e-4) C = G;
            if (L < 1e-4) L = G;
            b0.initNonuniformCatmullRom(m.x, n.x, u.x, v.x, C, G, L);
            h0.initNonuniformCatmullRom(m.y, n.y, u.y, v.y, C, G, L);
            f0.initNonuniformCatmullRom(m.z, n.z, u.z, v.z, C, G, L);
        } else if (this.type === 'catmullrom') {
            var N = this.tension !== undefined ? this.tension : Z1e.k1;
            b0.initCatmullRom(m.x, n.x, u.x, v.x, N);
            h0.initCatmullRom(m.y, n.y, u.y, v.y, N);
            f0.initCatmullRom(m.z, n.z, u.z, v.z, N);
        }
        var T = new THREE.Vector3(b0.calc(j), h0.calc(j), f0.calc(j));
        return T;
    });
})();
THREE.ClosedSplineCurve3 = function (d) {
    console.warn('THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.');
    THREE.CatmullRomCurve3.call(this, d);
    this.type = 'catmullrom';
    this.closed = Z1e.n3;
};
THREE.ClosedSplineCurve3.prototype = Object.create(THREE.CatmullRomCurve3.prototype);
THREE.BoxGeometry = function (d, e, f, i, j, k) {
    THREE.Geometry.call(this);
    this.type = Z1e.F2;
    this.parameters = {width: d, height: e, depth: f, widthSegments: i, heightSegments: j, depthSegments: k};
    this.fromBufferGeometry(new THREE.BoxBufferGeometry(d, e, f, i, j, k));
    this.mergeVertices();
};
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
THREE.CubeGeometry = THREE.BoxGeometry;
THREE.BoxBufferGeometry = function (W0, y0, P0, M0, G0, a1) {
    THREE.BufferGeometry.call(this);
    this.type = Z1e.u3;
    this.parameters = {width: W0, height: y0, depth: P0, widthSegments: M0, heightSegments: G0, depthSegments: a1};
    var b1 = this;
    M0 = Math.floor(M0) || 1;
    G0 = Math.floor(G0) || 1;
    a1 = Math.floor(a1) || 1;
    var X0 = S1(M0, G0, a1), o1 = (X0 / 4) * 6, z0 = new (o1 > Z1e.P3 ? Uint32Array : Uint16Array)(o1),
        Z0 = new Float32Array(X0 * 3), q1 = new Float32Array(X0 * 3), t1 = new Float32Array(X0 * 2), s1 = 0, z1 = 0,
        w1 = 0, u1 = 0, L1 = 0;
    y1('z', 'y', 'x', -1, -1, P0, y0, W0, a1, G0, 0);
    y1('z', 'y', 'x', 1, -1, P0, y0, -W0, a1, G0, 1);
    y1('x', 'z', 'y', 1, 1, W0, P0, y0, M0, a1, 2);
    y1('x', 'z', 'y', 1, -1, W0, P0, -y0, M0, a1, 3);
    y1('x', 'y', 'z', 1, -1, W0, y0, P0, M0, G0, 4);
    y1('x', 'y', 'z', -1, -1, W0, y0, -P0, M0, G0, 5);
    this.setIndex(new THREE.BufferAttribute(z0, 1));
    this.addAttribute(Z1e.g1, new THREE.BufferAttribute(Z0, 3));
    this.addAttribute(Z1e.R2, new THREE.BufferAttribute(q1, 3));
    this.addAttribute(Z1e.M3, new THREE.BufferAttribute(t1, 2));
    function S1(d, e, f) {
        var i = 0;
        i += d * e * 2;
        i += d * f * 2;
        i += f * e * 2;
        return i * 4;
    }
    function y1(d, e, f, i, j, k, m, n, u, v, B) {
        var C = k / u, G = m / v, L = k / 2, N = m / 2, T = n / 2, S = u + 1, b0 = v + 1, h0 = 0, f0 = 0,
            i0 = new THREE.Vector3();
        for (var s0 = 0; s0 < b0; s0++) {
            var t0 = s0 * G - N;
            for (var o0 = 0; o0 < S; o0++) {
                var w0 = o0 * C - L;
                i0[d] = w0 * i;
                i0[e] = t0 * j;
                i0[f] = T;
                Z0[s1] = i0.x;
                Z0[s1 + 1] = i0.y;
                Z0[s1 + 2] = i0.z;
                i0[d] = 0;
                i0[e] = 0;
                i0[f] = n > 0 ? 1 : -1;
                q1[s1] = i0.x;
                q1[s1 + 1] = i0.y;
                q1[s1 + 2] = i0.z;
                t1[z1] = o0 / u;
                t1[z1 + 1] = 1 - (s0 / v);
                s1 += 3;
                z1 += 2;
                h0 += 1;
            }
        }
        for (s0 = 0; s0 < v; s0++) {
            for (o0 = 0; o0 < u; o0++) {
                var x0 = u1 + o0 + S * s0, D0 = u1 + o0 + S * (s0 + 1), F0 = u1 + (o0 + 1) + S * (s0 + 1),
                    m0 = u1 + (o0 + 1) + S * s0;
                z0[w1] = x0;
                z0[w1 + 1] = D0;
                z0[w1 + 2] = m0;
                z0[w1 + 3] = D0;
                z0[w1 + 4] = F0;
                z0[w1 + 5] = m0;
                w1 += 6;
                f0 += 6;
            }
        }
        b1.addGroup(L1, f0, B);
        L1 += f0;
        u1 += h0;
    }
};
THREE.BoxBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;
THREE.CircleGeometry = function (d, e, f, i) {
    THREE.Geometry.call(this);
    this.type = Z1e.L2;
    this.parameters = {radius: d, segments: e, thetaStart: f, thetaLength: i};
    this.fromBufferGeometry(new THREE.CircleBufferGeometry(d, e, f, i));
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
THREE.CircleBufferGeometry = function (d, e, f, i) {
    THREE.BufferGeometry.call(this);
    this.type = Z1e.q0;
    this.parameters = {radius: d, segments: e, thetaStart: f, thetaLength: i};
    d = d || 50;
    e = e !== undefined ? Math.max(3, e) : 8;
    f = f !== undefined ? f : 0;
    i = i !== undefined ? i : Math.PI * 2;
    var j = e + 2, k = new Float32Array(j * 3), m = new Float32Array(j * 3), n = new Float32Array(j * 2);
    m[2] = Z1e.d4;
    n[0] = Z1e.k1;
    n[1] = Z1e.k1;
    for (var u = 0, v = 3, B = 2; u <= e; u++, v += 3, B += 2) {
        var C = f + u / e * i;
        k[v] = d * Math.cos(C);
        k[v + 1] = d * Math.sin(C);
        m[v + 2] = 1;
        n[B] = (k[v] / d + 1) / 2;
        n[B + 1] = (k[v + 1] / d + 1) / 2;
    }
    var G = [];
    for (var v = 1; v <= e; v++) {
        G.push(v, v + 1, 0);
    }
    this.setIndex(new THREE.BufferAttribute(new Uint16Array(G), 1));
    this.addAttribute(Z1e.g1, new THREE.BufferAttribute(k, 3));
    this.addAttribute(Z1e.R2, new THREE.BufferAttribute(m, 3));
    this.addAttribute(Z1e.M3, new THREE.BufferAttribute(n, 2));
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), d);
};
THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;
THREE.CylinderBufferGeometry = function (N, T, S, b0, h0, f0, i0, s0) {
    THREE.BufferGeometry.call(this);
    this.type = Z1e.K0;
    this.parameters = {
        radiusTop: N,
        radiusBottom: T,
        height: S,
        radialSegments: b0,
        heightSegments: h0,
        openEnded: f0,
        thetaStart: i0,
        thetaLength: s0
    };
    var t0 = this;
    N = N !== undefined ? N : 20;
    T = T !== undefined ? T : 20;
    S = S !== undefined ? S : Z1e.j4;
    b0 = Math.floor(b0) || 8;
    h0 = Math.floor(h0) || 1;
    f0 = f0 !== undefined ? f0 : Z1e.e4;
    i0 = i0 !== undefined ? i0 : 0;
    s0 = s0 !== undefined ? s0 : 2 * Math.PI;
    var o0 = a1(), w0 = b1(), x0 = new THREE.BufferAttribute(new (w0 > Z1e.P3 ? Uint32Array : Uint16Array)(w0), 1),
        D0 = new THREE.BufferAttribute(new Float32Array(o0 * 3), 3),
        F0 = new THREE.BufferAttribute(new Float32Array(o0 * 3), 3),
        m0 = new THREE.BufferAttribute(new Float32Array(o0 * 2), 2), W0 = 0, y0 = 0, P0 = [], M0 = S / 2, G0 = 0;
    X0();
    if (f0 === Z1e.e4) {
        if (N > 0) o1(Z1e.n3);
        if (T > 0) o1(Z1e.e4);
    }
    this.setIndex(x0);
    this.addAttribute(Z1e.g1, D0);
    this.addAttribute(Z1e.R2, F0);
    this.addAttribute(Z1e.M3, m0);
    function a1() {
        var d = (b0 + 1) * (h0 + 1);
        if (f0 === Z1e.e4) {
            d += ((b0 + 1) * 2) + (b0 * 2);
        }
        return d;
    }
    function b1() {
        var d = b0 * h0 * 2 * 3;
        if (f0 === Z1e.e4) {
            d += b0 * 2 * 3;
        }
        return d;
    }
    function X0() {
        var d, e, f = new THREE.Vector3(), i = new THREE.Vector3(), j = 0, k = (T - N) / S;
        for (e = 0; e <= h0; e++) {
            var m = [], n = e / h0, u = n * (T - N) + N;
            for (d = 0; d <= b0; d++) {
                var v = d / b0;
                i.x = u * Math.sin(v * s0 + i0);
                i.y = -n * S + M0;
                i.z = u * Math.cos(v * s0 + i0);
                D0.setXYZ(W0, i.x, i.y, i.z);
                f.copy(i);
                if ((N === 0 && e === 0) || (T === 0 && e === h0)) {
                    f.x = Math.sin(v * s0 + i0);
                    f.z = Math.cos(v * s0 + i0);
                }
                f.setY(Math.sqrt(f.x * f.x + f.z * f.z) * k).normalize();
                F0.setXYZ(W0, f.x, f.y, f.z);
                m0.setXY(W0, v, 1 - n);
                m.push(W0);
                W0++;
            }
            P0.push(m);
        }
        for (d = 0; d < b0; d++) {
            for (e = 0; e < h0; e++) {
                var B = P0[e][d], C = P0[e + 1][d], G = P0[e + 1][d + 1], L = P0[e][d + 1];
                x0.setX(y0, B);
                y0++;
                x0.setX(y0, C);
                y0++;
                x0.setX(y0, L);
                y0++;
                x0.setX(y0, C);
                y0++;
                x0.setX(y0, G);
                y0++;
                x0.setX(y0, L);
                y0++;
                j += 6;
            }
        }
        t0.addGroup(G0, j, 0);
        G0 += j;
    }
    function o1(d) {
        var e, f, i, j = new THREE.Vector2(), k = new THREE.Vector3(), m = 0, n = (d === Z1e.n3) ? N : T,
            u = (d === Z1e.n3) ? 1 : -1;
        f = W0;
        for (e = 1; e <= b0; e++) {
            D0.setXYZ(W0, 0, M0 * u, 0);
            F0.setXYZ(W0, 0, u, 0);
            if (d === Z1e.n3) {
                j.x = e / b0;
                j.y = 0;
            } else {
                j.x = (e - 1) / b0;
                j.y = 1;
            }
            m0.setXY(W0, j.x, j.y);
            W0++;
        }
        i = W0;
        for (e = 0; e <= b0; e++) {
            var v = e / b0;
            k.x = n * Math.sin(v * s0 + i0);
            k.y = M0 * u;
            k.z = n * Math.cos(v * s0 + i0);
            D0.setXYZ(W0, k.x, k.y, k.z);
            F0.setXYZ(W0, 0, u, 0);
            m0.setXY(W0, v, (d === Z1e.n3) ? 1 : 0);
            W0++;
        }
        for (e = 0; e < b0; e++) {
            var B = f + e, C = i + e;
            if (d === Z1e.n3) {
                x0.setX(y0, C);
                y0++;
                x0.setX(y0, C + 1);
                y0++;
                x0.setX(y0, B);
                y0++;
            } else {
                x0.setX(y0, C + 1);
                y0++;
                x0.setX(y0, C);
                y0++;
                x0.setX(y0, B);
                y0++;
            }
            m += 3;
        }
        t0.addGroup(G0, m, d === Z1e.n3 ? 1 : 2);
        G0 += m;
    }
};
THREE.CylinderBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;
THREE.CylinderGeometry = function (d, e, f, i, j, k, m, n) {
    THREE.Geometry.call(this);
    this.type = Z1e.q3;
    this.parameters = {
        radiusTop: d,
        radiusBottom: e,
        height: f,
        radialSegments: i,
        heightSegments: j,
        openEnded: k,
        thetaStart: m,
        thetaLength: n
    };
    this.fromBufferGeometry(new THREE.CylinderBufferGeometry(d, e, f, i, j, k, m, n));
    this.mergeVertices();
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
THREE.EdgesGeometry = function (f, i) {
    THREE.BufferGeometry.call(this);
    i = (i !== undefined) ? i : 1;
    var j = Math.cos(THREE.Math.DEG2RAD * i), k = [0, 0], m = {};
    function n(d, e) {
        return d - e;
    }
    var u = ['a', 'b', 'c'], v;
    if (f instanceof THREE.BufferGeometry) {
        v = new THREE.Geometry();
        v.fromBufferGeometry(f);
    } else {
        v = f.clone();
    }
    v.mergeVertices();
    v.computeFaceNormals();
    var B = v.vertices, C = v.faces;
    for (var G = 0, L = C.length; G < L; G++) {
        var N = C[G];
        for (var T = 0; T < 3; T++) {
            k[0] = N[u[T]];
            k[1] = N[u[(T + 1) % 3]];
            k.sort(n);
            var S = k.toString();
            if (m[S] === undefined) {
                m[S] = {vert1: k[0], vert2: k[1], face1: G, face2: undefined};
            } else {
                m[S].face2 = G;
            }
        }
    }
    var b0 = [];
    for (var S in m) {
        var h0 = m[S];
        if (h0.face2 === undefined || C[h0.face1].normal.dot(C[h0.face2].normal) <= j) {
            var f0 = B[h0.vert1];
            b0.push(f0.x);
            b0.push(f0.y);
            b0.push(f0.z);
            f0 = B[h0.vert2];
            b0.push(f0.x);
            b0.push(f0.y);
            b0.push(f0.z);
        }
    }
    this.addAttribute(Z1e.g1, new THREE.BufferAttribute(new Float32Array(b0), 3));
};
THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
THREE.ExtrudeGeometry = function (d, e) {
    if (typeof (d) === "undefined") {
        d = [];
        return;
    }
    THREE.Geometry.call(this);
    this.type = 'ExtrudeGeometry';
    d = Array.isArray(d) ? d : [d];
    this.addShapeList(d, e);
    this.computeFaceNormals();
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
THREE.ExtrudeGeometry.prototype.addShapeList = function (d, e) {
    var f = d.length;
    for (var i = 0; i < f; i++) {
        var j = d[i];
        this.addShape(j, e);
    }
};
THREE.ExtrudeGeometry.prototype.addShape = function (s0, t0) {
    var o0 = t0.amount !== undefined ? t0.amount : Z1e.j4, w0 = t0.bevelThickness !== undefined ? t0.bevelThickness : 6,
        x0 = t0.bevelSize !== undefined ? t0.bevelSize : w0 - 2,
        D0 = t0.bevelSegments !== undefined ? t0.bevelSegments : 3,
        F0 = t0.bevelEnabled !== undefined ? t0.bevelEnabled : Z1e.n3,
        m0 = t0.curveSegments !== undefined ? t0.curveSegments : 12, W0 = t0.steps !== undefined ? t0.steps : 1,
        y0 = t0.extrudePath, P0, M0 = Z1e.e4,
        G0 = t0.UVGenerator !== undefined ? t0.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator, a1, b1, X0, o1;
    if (y0) {
        P0 = y0.getSpacedPoints(W0);
        M0 = Z1e.n3;
        F0 = Z1e.e4;
        a1 = t0.frames !== undefined ? t0.frames : new THREE.TubeGeometry.FrenetFrames(y0, W0, Z1e.e4);
        b1 = new THREE.Vector3();
        X0 = new THREE.Vector3();
        o1 = new THREE.Vector3();
    }
    if (!F0) {
        D0 = 0;
        w0 = 0;
        x0 = 0;
    }
    var z0, Z0, q1, t1 = this, s1 = this.vertices.length, z1 = s0.extractPoints(m0), w1 = z1.shape, u1 = z1.holes,
        L1 = !THREE.ShapeUtils.isClockWise(w1);
    if (L1) {
        w1 = w1.reverse();
        for (Z0 = 0, q1 = u1.length; Z0 < q1; Z0++) {
            z0 = u1[Z0];
            if (THREE.ShapeUtils.isClockWise(z0)) {
                u1[Z0] = z0.reverse();
            }
        }
        L1 = Z1e.e4;
    }
    var S1 = THREE.ShapeUtils.triangulateShape(w1, u1), y1 = w1;
    for (Z0 = 0, q1 = u1.length; Z0 < q1; Z0++) {
        z0 = u1[Z0];
        w1 = w1.concat(z0);
    }
    function a2(d, e, f) {
        if (!e) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return e.clone().multiplyScalar(f).add(d);
    }
    var P1, B1, p2, K2, h1, t2 = w1.length, f2, x2 = S1.length;
    function P2(d, e, f) {
        var i, j, k = 1, m = d.x - e.x, n = d.y - e.y, u = f.x - d.x, v = f.y - d.y, B = (m * m + n * n),
            C = (m * v - n * u);
        if (Math.abs(C) > Number.EPSILON) {
            var G = Math.sqrt(B), L = Math.sqrt(u * u + v * v), N = (e.x - n / G), T = (e.y + m / G), S = (f.x - v / L),
                b0 = (f.y + u / L), h0 = ((S - N) * v - (b0 - T) * u) / (m * v - n * u);
            i = (N + m * h0 - d.x);
            j = (T + n * h0 - d.y);
            var f0 = (i * i + j * j);
            if (f0 <= 2) {
                return new THREE.Vector2(i, j);
            } else {
                k = Math.sqrt(f0 / 2);
            }
        } else {
            var i0 = Z1e.e4;
            if (m > Number.EPSILON) {
                if (u > Number.EPSILON) {
                    i0 = Z1e.n3;
                }
            } else {
                if (m < -Number.EPSILON) {
                    if (u < -Number.EPSILON) {
                        i0 = Z1e.n3;
                    }
                } else {
                    if (Math.sign(n) === Math.sign(v)) {
                        i0 = Z1e.n3;
                    }
                }
            }
            if (i0) {
                i = -n;
                j = m;
                k = Math.sqrt(B);
            } else {
                i = m;
                j = n;
                k = Math.sqrt(B / 2);
            }
        }
        return new THREE.Vector2(i / k, j / k);
    }
    var H2 = [];
    for (var n1 = 0, l2 = y1.length, r2 = l2 - 1, y2 = n1 + 1; n1 < l2; n1++, r2++, y2++) {
        if (r2 === l2) r2 = 0;
        if (y2 === l2) y2 = 0;
        H2[n1] = P2(y1[n1], y1[r2], y1[y2]);
    }
    var m3 = [], Z2, N2 = H2.concat();
    for (Z0 = 0, q1 = u1.length; Z0 < q1; Z0++) {
        z0 = u1[Z0];
        Z2 = [];
        for (n1 = 0, l2 = z0.length, r2 = l2 - 1, y2 = n1 + 1; n1 < l2; n1++, r2++, y2++) {
            if (r2 === l2) r2 = 0;
            if (y2 === l2) y2 = 0;
            Z2[n1] = P2(z0[n1], z0[r2], z0[y2]);
        }
        m3.push(Z2);
        N2 = N2.concat(Z2);
    }
    for (P1 = 0; P1 < D0; P1++) {
        p2 = P1 / D0;
        K2 = w0 * (1 - p2);
        B1 = x0 * (Math.sin(p2 * Math.PI / 2));
        for (n1 = 0, l2 = y1.length; n1 < l2; n1++) {
            h1 = a2(y1[n1], H2[n1], B1);
            g3(h1.x, h1.y, -K2);
        }
        for (Z0 = 0, q1 = u1.length; Z0 < q1; Z0++) {
            z0 = u1[Z0];
            Z2 = m3[Z0];
            for (n1 = 0, l2 = z0.length; n1 < l2; n1++) {
                h1 = a2(z0[n1], Z2[n1], B1);
                g3(h1.x, h1.y, -K2);
            }
        }
    }
    B1 = x0;
    for (n1 = 0; n1 < t2; n1++) {
        h1 = F0 ? a2(w1[n1], N2[n1], B1) : w1[n1];
        if (!M0) {
            g3(h1.x, h1.y, 0);
        } else {
            X0.copy(a1.normals[0]).multiplyScalar(h1.x);
            b1.copy(a1.binormals[0]).multiplyScalar(h1.y);
            o1.copy(P0[0]).add(X0).add(b1);
            g3(o1.x, o1.y, o1.z);
        }
    }
    var d3;
    for (d3 = 1; d3 <= W0; d3++) {
        for (n1 = 0; n1 < t2; n1++) {
            h1 = F0 ? a2(w1[n1], N2[n1], B1) : w1[n1];
            if (!M0) {
                g3(h1.x, h1.y, o0 / W0 * d3);
            } else {
                X0.copy(a1.normals[d3]).multiplyScalar(h1.x);
                b1.copy(a1.binormals[d3]).multiplyScalar(h1.y);
                o1.copy(P0[d3]).add(X0).add(b1);
                g3(o1.x, o1.y, o1.z);
            }
        }
    }
    for (P1 = D0 - 1; P1 >= 0; P1--) {
        p2 = P1 / D0;
        K2 = w0 * (1 - p2);
        B1 = x0 * Math.sin(p2 * Math.PI / 2);
        for (n1 = 0, l2 = y1.length; n1 < l2; n1++) {
            h1 = a2(y1[n1], H2[n1], B1);
            g3(h1.x, h1.y, o0 + K2);
        }
        for (Z0 = 0, q1 = u1.length; Z0 < q1; Z0++) {
            z0 = u1[Z0];
            Z2 = m3[Z0];
            for (n1 = 0, l2 = z0.length; n1 < l2; n1++) {
                h1 = a2(z0[n1], Z2[n1], B1);
                if (!M0) {
                    g3(h1.x, h1.y, o0 + K2);
                } else {
                    g3(h1.x, h1.y + P0[W0 - 1].y, P0[W0 - 1].x + K2);
                }
            }
        }
    }
    s3();
    j3();
    function s3() {
        if (F0) {
            var d = 0, e = t2 * d;
            for (n1 = 0; n1 < x2; n1++) {
                f2 = S1[n1];
                E3(f2[2] + e, f2[1] + e, f2[0] + e);
            }
            d = W0 + D0 * 2;
            e = t2 * d;
            for (n1 = 0; n1 < x2; n1++) {
                f2 = S1[n1];
                E3(f2[0] + e, f2[1] + e, f2[2] + e);
            }
        } else {
            for (n1 = 0; n1 < x2; n1++) {
                f2 = S1[n1];
                E3(f2[2], f2[1], f2[0]);
            }
            for (n1 = 0; n1 < x2; n1++) {
                f2 = S1[n1];
                E3(f2[0] + t2 * W0, f2[1] + t2 * W0, f2[2] + t2 * W0);
            }
        }
    }
    function j3() {
        var d = 0;
        g4(y1, d);
        d += y1.length;
        for (Z0 = 0, q1 = u1.length; Z0 < q1; Z0++) {
            z0 = u1[Z0];
            g4(z0, d);
            d += z0.length;
        }
    }
    function g4(d, e) {
        var f, i;
        n1 = d.length;
        while (--n1 >= 0) {
            f = n1;
            i = n1 - 1;
            if (i < 0) i = d.length - 1;
            var j = 0, k = W0 + D0 * 2;
            for (j = 0; j < k; j++) {
                var m = t2 * j, n = t2 * (j + 1), u = e + f + m, v = e + i + m, B = e + i + n, C = e + f + n;
                Q3(u, v, B, C, d, j, k, f, i);
            }
        }
    }
    function g3(d, e, f) {
        t1.vertices.push(new THREE.Vector3(d, e, f));
    }
    function E3(d, e, f) {
        d += s1;
        e += s1;
        f += s1;
        t1.faces.push(new THREE.Face3(d, e, f, Z1e.l3, Z1e.l3, 0));
        var i = G0.generateTopUV(t1, d, e, f);
        t1.faceVertexUvs[0].push(i);
    }
    function Q3(d, e, f, i, j, k, m, n, u) {
        d += s1;
        e += s1;
        f += s1;
        i += s1;
        t1.faces.push(new THREE.Face3(d, e, i, Z1e.l3, Z1e.l3, 1));
        t1.faces.push(new THREE.Face3(e, f, i, Z1e.l3, Z1e.l3, 1));
        var v = G0.generateSideWallUV(t1, d, e, f, i);
        t1.faceVertexUvs[0].push([v[0], v[1], v[3]]);
        t1.faceVertexUvs[0].push([v[1], v[2], v[3]]);
    }
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function (d, e, f, i) {
        var j = d.vertices, k = j[e], m = j[f], n = j[i];
        return [new THREE.Vector2(k.x, k.y), new THREE.Vector2(m.x, m.y), new THREE.Vector2(n.x, n.y)];
    }, generateSideWallUV: function (d, e, f, i, j) {
        var k = d.vertices, m = k[e], n = k[f], u = k[i], v = k[j];
        if (Math.abs(m.y - n.y) < 0.01) {
            return [new THREE.Vector2(m.x, 1 - m.z), new THREE.Vector2(n.x, 1 - n.z), new THREE.Vector2(u.x, 1 - u.z), new THREE.Vector2(v.x, 1 - v.z)];
        } else {
            return [new THREE.Vector2(m.y, 1 - m.z), new THREE.Vector2(n.y, 1 - n.z), new THREE.Vector2(u.y, 1 - u.z), new THREE.Vector2(v.y, 1 - v.z)];
        }
    }
};
THREE.ShapeGeometry = function (d, e) {
    THREE.Geometry.call(this);
    this.type = 'ShapeGeometry';
    if (Array.isArray(d) === Z1e.e4) d = [d];
    this.addShapeList(d, e);
    this.computeFaceNormals();
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
THREE.ShapeGeometry.prototype.addShapeList = function (d, e) {
    for (var f = 0, i = d.length; f < i; f++) {
        this.addShape(d[f], e);
    }
    return this;
};
THREE.ShapeGeometry.prototype.addShape = function (d, e) {
    if (e === undefined) e = {};
    var f = e.curveSegments !== undefined ? e.curveSegments : 12, i = e.material,
        j = e.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : e.UVGenerator, k, m, n,
        u = this.vertices.length, v = d.extractPoints(f), B = v.shape, C = v.holes,
        G = !THREE.ShapeUtils.isClockWise(B);
    if (G) {
        B = B.reverse();
        for (k = 0, m = C.length; k < m; k++) {
            n = C[k];
            if (THREE.ShapeUtils.isClockWise(n)) {
                C[k] = n.reverse();
            }
        }
        G = Z1e.e4;
    }
    var L = THREE.ShapeUtils.triangulateShape(B, C);
    for (k = 0, m = C.length; k < m; k++) {
        n = C[k];
        B = B.concat(n);
    }
    var N, T = B.length, S, b0 = L.length;
    for (k = 0; k < T; k++) {
        N = B[k];
        this.vertices.push(new THREE.Vector3(N.x, N.y, 0));
    }
    for (k = 0; k < b0; k++) {
        S = L[k];
        var h0 = S[0] + u, f0 = S[1] + u, i0 = S[2] + u;
        this.faces.push(new THREE.Face3(h0, f0, i0, Z1e.l3, Z1e.l3, i));
        this.faceVertexUvs[0].push(j.generateTopUV(this, h0, f0, i0));
    }
};
THREE.LatheBufferGeometry = function (d, e, f, i) {
    THREE.BufferGeometry.call(this);
    this.type = Z1e.Q2;
    this.parameters = {points: d, segments: e, phiStart: f, phiLength: i};
    e = Math.floor(e) || 12;
    f = f || 0;
    i = i || Math.PI * 2;
    i = THREE.Math.clamp(i, 0, Math.PI * 2);
    var j = (e + 1) * d.length, k = e * d.length * 2 * 3,
        m = new THREE.BufferAttribute(new (k > Z1e.P3 ? Uint32Array : Uint16Array)(k), 1),
        n = new THREE.BufferAttribute(new Float32Array(j * 3), 3),
        u = new THREE.BufferAttribute(new Float32Array(j * 2), 2), v = 0, B = 0, C, G = Z1e.d4 / (d.length - 1),
        L = Z1e.d4 / e, N = new THREE.Vector3(), T = new THREE.Vector2(), S, b0;
    for (S = 0; S <= e; S++) {
        var h0 = f + S * L * i, f0 = Math.sin(h0), i0 = Math.cos(h0);
        for (b0 = 0; b0 <= (d.length - 1); b0++) {
            N.x = d[b0].x * f0;
            N.y = d[b0].y;
            N.z = d[b0].x * i0;
            n.setXYZ(v, N.x, N.y, N.z);
            T.x = S / e;
            T.y = b0 / (d.length - 1);
            u.setXY(v, T.x, T.y);
            v++;
        }
    }
    for (S = 0; S < e; S++) {
        for (b0 = 0; b0 < (d.length - 1); b0++) {
            C = b0 + S * d.length;
            var s0 = C, t0 = C + d.length, o0 = C + d.length + 1, w0 = C + 1;
            m.setX(B, s0);
            B++;
            m.setX(B, t0);
            B++;
            m.setX(B, w0);
            B++;
            m.setX(B, t0);
            B++;
            m.setX(B, o0);
            B++;
            m.setX(B, w0);
            B++;
        }
    }
    this.setIndex(m);
    this.addAttribute(Z1e.g1, n);
    this.addAttribute(Z1e.M3, u);
    this.computeVertexNormals();
    if (i === Math.PI * 2) {
        var x0 = this.attributes.normal.array, D0 = new THREE.Vector3(), F0 = new THREE.Vector3(),
            m0 = new THREE.Vector3();
        C = e * d.length * 3;
        for (S = 0, b0 = 0; S < d.length; S++, b0 += 3) {
            D0.x = x0[b0 + 0];
            D0.y = x0[b0 + 1];
            D0.z = x0[b0 + 2];
            F0.x = x0[C + b0 + 0];
            F0.y = x0[C + b0 + 1];
            F0.z = x0[C + b0 + 2];
            m0.addVectors(D0, F0).normalize();
            x0[b0 + 0] = x0[C + b0 + 0] = m0.x;
            x0[b0 + 1] = x0[C + b0 + 1] = m0.y;
            x0[b0 + 2] = x0[C + b0 + 2] = m0.z;
        }
    }
};
THREE.LatheBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;
THREE.LatheGeometry = function (d, e, f, i) {
    THREE.Geometry.call(this);
    this.type = Z1e.K1;
    this.parameters = {points: d, segments: e, phiStart: f, phiLength: i};
    this.fromBufferGeometry(new THREE.LatheBufferGeometry(d, e, f, i));
    this.mergeVertices();
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
THREE.PlaneGeometry = function (d, e, f, i) {
    THREE.Geometry.call(this);
    this.type = Z1e.q4;
    this.parameters = {width: d, height: e, widthSegments: f, heightSegments: i};
    this.fromBufferGeometry(new THREE.PlaneBufferGeometry(d, e, f, i));
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
THREE.PlaneBufferGeometry = function (d, e, f, i) {
    THREE.BufferGeometry.call(this);
    this.type = Z1e.f1;
    this.parameters = {width: d, height: e, widthSegments: f, heightSegments: i};
    var j = d / 2, k = e / 2, m = Math.floor(f) || 1, n = Math.floor(i) || 1, u = m + 1, v = n + 1, B = d / m,
        C = e / n, G = new Float32Array(u * v * 3), L = new Float32Array(u * v * 3), N = new Float32Array(u * v * 2),
        T = 0, S = 0;
    for (var b0 = 0; b0 < v; b0++) {
        var h0 = b0 * C - k;
        for (var f0 = 0; f0 < u; f0++) {
            var i0 = f0 * B - j;
            G[T] = i0;
            G[T + 1] = -h0;
            L[T + 2] = 1;
            N[S] = f0 / m;
            N[S + 1] = 1 - (b0 / n);
            T += 3;
            S += 2;
        }
    }
    T = 0;
    var s0 = new ((G.length / 3) > Z1e.P3 ? Uint32Array : Uint16Array)(m * n * 6);
    for (var b0 = 0; b0 < n; b0++) {
        for (var f0 = 0; f0 < m; f0++) {
            var t0 = f0 + u * b0, o0 = f0 + u * (b0 + 1), w0 = (f0 + 1) + u * (b0 + 1), x0 = (f0 + 1) + u * b0;
            s0[T] = t0;
            s0[T + 1] = o0;
            s0[T + 2] = x0;
            s0[T + 3] = o0;
            s0[T + 4] = w0;
            s0[T + 5] = x0;
            T += 6;
        }
    }
    this.setIndex(new THREE.BufferAttribute(s0, 1));
    this.addAttribute(Z1e.g1, new THREE.BufferAttribute(G, 3));
    this.addAttribute(Z1e.R2, new THREE.BufferAttribute(L, 3));
    this.addAttribute(Z1e.M3, new THREE.BufferAttribute(N, 2));
};
THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
THREE.RingBufferGeometry = function (d, e, f, i, j, k) {
    THREE.BufferGeometry.call(this);
    this.type = Z1e.J2;
    this.parameters = {innerRadius: d, outerRadius: e, thetaSegments: f, phiSegments: i, thetaStart: j, thetaLength: k};
    d = d || 20;
    e = e || 50;
    j = j !== undefined ? j : 0;
    k = k !== undefined ? k : Math.PI * 2;
    f = f !== undefined ? Math.max(3, f) : 8;
    i = i !== undefined ? Math.max(1, i) : 1;
    var m = (f + 1) * (i + 1), n = f * i * 2 * 3,
        u = new THREE.BufferAttribute(new (n > Z1e.P3 ? Uint32Array : Uint16Array)(n), 1),
        v = new THREE.BufferAttribute(new Float32Array(m * 3), 3),
        B = new THREE.BufferAttribute(new Float32Array(m * 3), 3),
        C = new THREE.BufferAttribute(new Float32Array(m * 2), 2), G = 0, L = 0, N, T = d, S = ((e - d) / i),
        b0 = new THREE.Vector3(), h0 = new THREE.Vector2(), f0, i0;
    for (f0 = 0; f0 <= i; f0++) {
        for (i0 = 0; i0 <= f; i0++) {
            N = j + i0 / f * k;
            b0.x = T * Math.cos(N);
            b0.y = T * Math.sin(N);
            v.setXYZ(G, b0.x, b0.y, b0.z);
            B.setXYZ(G, 0, 0, 1);
            h0.x = (b0.x / e + 1) / 2;
            h0.y = (b0.y / e + 1) / 2;
            C.setXY(G, h0.x, h0.y);
            G++;
        }
        T += S;
    }
    for (f0 = 0; f0 < i; f0++) {
        var s0 = f0 * (f + 1);
        for (i0 = 0; i0 < f; i0++) {
            N = i0 + s0;
            var t0 = N, o0 = N + f + 1, w0 = N + f + 2, x0 = N + 1;
            u.setX(L, t0);
            L++;
            u.setX(L, o0);
            L++;
            u.setX(L, w0);
            L++;
            u.setX(L, t0);
            L++;
            u.setX(L, w0);
            L++;
            u.setX(L, x0);
            L++;
        }
    }
    this.setIndex(u);
    this.addAttribute(Z1e.g1, v);
    this.addAttribute(Z1e.R2, B);
    this.addAttribute(Z1e.M3, C);
};
THREE.RingBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;
THREE.RingGeometry = function (d, e, f, i, j, k) {
    THREE.Geometry.call(this);
    this.type = Z1e.V3;
    this.parameters = {innerRadius: d, outerRadius: e, thetaSegments: f, phiSegments: i, thetaStart: j, thetaLength: k};
    this.fromBufferGeometry(new THREE.RingBufferGeometry(d, e, f, i, j, k));
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
THREE.SphereGeometry = function (d, e, f, i, j, k, m) {
    THREE.Geometry.call(this);
    this.type = Z1e.M2;
    this.parameters = {
        radius: d,
        widthSegments: e,
        heightSegments: f,
        phiStart: i,
        phiLength: j,
        thetaStart: k,
        thetaLength: m
    };
    this.fromBufferGeometry(new THREE.SphereBufferGeometry(d, e, f, i, j, k, m));
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
THREE.SphereBufferGeometry = function (d, e, f, i, j, k, m) {
    THREE.BufferGeometry.call(this);
    this.type = Z1e.U3;
    this.parameters = {
        radius: d,
        widthSegments: e,
        heightSegments: f,
        phiStart: i,
        phiLength: j,
        thetaStart: k,
        thetaLength: m
    };
    d = d || 50;
    e = Math.max(3, Math.floor(e) || 8);
    f = Math.max(2, Math.floor(f) || 6);
    i = i !== undefined ? i : 0;
    j = j !== undefined ? j : Math.PI * 2;
    k = k !== undefined ? k : 0;
    m = m !== undefined ? m : Math.PI;
    var n = k + m, u = ((e + 1) * (f + 1)), v = new THREE.BufferAttribute(new Float32Array(u * 3), 3),
        B = new THREE.BufferAttribute(new Float32Array(u * 3), 3),
        C = new THREE.BufferAttribute(new Float32Array(u * 2), 2), G = 0, L = [], N = new THREE.Vector3();
    for (var T = 0; T <= f; T++) {
        var S = [], b0 = T / f;
        for (var h0 = 0; h0 <= e; h0++) {
            var f0 = h0 / e, i0 = -d * Math.cos(i + f0 * j) * Math.sin(k + b0 * m), s0 = d * Math.cos(k + b0 * m),
                t0 = d * Math.sin(i + f0 * j) * Math.sin(k + b0 * m);
            N.set(i0, s0, t0).normalize();
            v.setXYZ(G, i0, s0, t0);
            B.setXYZ(G, N.x, N.y, N.z);
            C.setXY(G, f0, 1 - b0);
            S.push(G);
            G++;
        }
        L.push(S);
    }
    var o0 = [];
    for (var T = 0; T < f; T++) {
        for (var h0 = 0; h0 < e; h0++) {
            var w0 = L[T][h0 + 1], x0 = L[T][h0], D0 = L[T + 1][h0], F0 = L[T + 1][h0 + 1];
            if (T !== 0 || k > 0) o0.push(w0, x0, F0);
            if (T !== f - 1 || n < Math.PI) o0.push(x0, D0, F0);
        }
    }
    this.setIndex(new (v.count > Z1e.P3 ? THREE.Uint32Attribute : THREE.Uint16Attribute)(o0, 1));
    this.addAttribute(Z1e.g1, v);
    this.addAttribute(Z1e.R2, B);
    this.addAttribute(Z1e.M3, C);
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), d);
};
THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
THREE.TextGeometry = function (d, e) {
    e = e || {};
    var f = e.font;
    if (f instanceof THREE.Font === Z1e.e4) {
        console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
        return new THREE.Geometry();
    }
    var i = f.generateShapes(d, e.size, e.curveSegments);
    e.amount = e.height !== undefined ? e.height : 50;
    if (e.bevelThickness === undefined) e.bevelThickness = 10;
    if (e.bevelSize === undefined) e.bevelSize = 8;
    if (e.bevelEnabled === undefined) e.bevelEnabled = Z1e.e4;
    THREE.ExtrudeGeometry.call(this, i, e);
    this.type = 'TextGeometry';
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
THREE.TorusBufferGeometry = function (d, e, f, i, j) {
    THREE.BufferGeometry.call(this);
    this.type = Z1e.e0;
    this.parameters = {radius: d, tube: e, radialSegments: f, tubularSegments: i, arc: j};
    d = d || Z1e.j4;
    e = e || 40;
    f = Math.floor(f) || 8;
    i = Math.floor(i) || 6;
    j = j || Math.PI * 2;
    var k = ((f + 1) * (i + 1)), m = f * i * 2 * 3, n = new (m > Z1e.P3 ? Uint32Array : Uint16Array)(m),
        u = new Float32Array(k * 3), v = new Float32Array(k * 3), B = new Float32Array(k * 2), C = 0, G = 0, L = 0,
        N = new THREE.Vector3(), T = new THREE.Vector3(), S = new THREE.Vector3(), b0, h0;
    for (b0 = 0; b0 <= f; b0++) {
        for (h0 = 0; h0 <= i; h0++) {
            var f0 = h0 / i * j, i0 = b0 / f * Math.PI * 2;
            T.x = (d + e * Math.cos(i0)) * Math.cos(f0);
            T.y = (d + e * Math.cos(i0)) * Math.sin(f0);
            T.z = e * Math.sin(i0);
            u[C] = T.x;
            u[C + 1] = T.y;
            u[C + 2] = T.z;
            N.x = d * Math.cos(f0);
            N.y = d * Math.sin(f0);
            S.subVectors(T, N).normalize();
            v[C] = S.x;
            v[C + 1] = S.y;
            v[C + 2] = S.z;
            B[G] = h0 / i;
            B[G + 1] = b0 / f;
            C += 3;
            G += 2;
        }
    }
    for (b0 = 1; b0 <= f; b0++) {
        for (h0 = 1; h0 <= i; h0++) {
            var s0 = (i + 1) * b0 + h0 - 1, t0 = (i + 1) * (b0 - 1) + h0 - 1, o0 = (i + 1) * (b0 - 1) + h0,
                w0 = (i + 1) * b0 + h0;
            n[L] = s0;
            n[L + 1] = t0;
            n[L + 2] = w0;
            n[L + 3] = t0;
            n[L + 4] = o0;
            n[L + 5] = w0;
            L += 6;
        }
    }
    this.setIndex(new THREE.BufferAttribute(n, 1));
    this.addAttribute(Z1e.g1, new THREE.BufferAttribute(u, 3));
    this.addAttribute(Z1e.R2, new THREE.BufferAttribute(v, 3));
    this.addAttribute(Z1e.M3, new THREE.BufferAttribute(B, 2));
};
THREE.TorusBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;
THREE.TorusGeometry = function (d, e, f, i, j) {
    THREE.Geometry.call(this);
    this.type = Z1e.n4;
    this.parameters = {radius: d, tube: e, radialSegments: f, tubularSegments: i, arc: j};
    this.fromBufferGeometry(new THREE.TorusBufferGeometry(d, e, f, i, j));
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
THREE.TorusKnotBufferGeometry = function (v, B, C, G, L, N) {
    THREE.BufferGeometry.call(this);
    this.type = Z1e.r1;
    this.parameters = {radius: v, tube: B, tubularSegments: C, radialSegments: G, p: L, q: N};
    v = v || Z1e.j4;
    B = B || 40;
    C = Math.floor(C) || 64;
    G = Math.floor(G) || 8;
    L = L || 2;
    N = N || 3;
    var T = ((G + 1) * (C + 1)), S = G * C * 2 * 3,
        b0 = new THREE.BufferAttribute(new (S > Z1e.P3 ? Uint32Array : Uint16Array)(S), 1),
        h0 = new THREE.BufferAttribute(new Float32Array(T * 3), 3),
        f0 = new THREE.BufferAttribute(new Float32Array(T * 3), 3),
        i0 = new THREE.BufferAttribute(new Float32Array(T * 2), 2), s0, t0, o0 = 0, w0 = 0, x0 = new THREE.Vector3(),
        D0 = new THREE.Vector3(), F0 = new THREE.Vector2(), m0 = new THREE.Vector3(), W0 = new THREE.Vector3(),
        y0 = new THREE.Vector3(), P0 = new THREE.Vector3(), M0 = new THREE.Vector3();
    for (s0 = 0; s0 <= C; ++s0) {
        var G0 = s0 / C * L * Math.PI * 2;
        t1(G0, L, N, v, m0);
        t1(G0 + 0.01, L, N, v, W0);
        P0.subVectors(W0, m0);
        M0.addVectors(W0, m0);
        y0.crossVectors(P0, M0);
        M0.crossVectors(y0, P0);
        y0.normalize();
        M0.normalize();
        for (t0 = 0; t0 <= G; ++t0) {
            var a1 = t0 / G * Math.PI * 2, b1 = -B * Math.cos(a1), X0 = B * Math.sin(a1);
            x0.x = m0.x + (b1 * M0.x + X0 * y0.x);
            x0.y = m0.y + (b1 * M0.y + X0 * y0.y);
            x0.z = m0.z + (b1 * M0.z + X0 * y0.z);
            h0.setXYZ(o0, x0.x, x0.y, x0.z);
            D0.subVectors(x0, m0).normalize();
            f0.setXYZ(o0, D0.x, D0.y, D0.z);
            F0.x = s0 / C;
            F0.y = t0 / G;
            i0.setXY(o0, F0.x, F0.y);
            o0++;
        }
    }
    for (t0 = 1; t0 <= C; t0++) {
        for (s0 = 1; s0 <= G; s0++) {
            var o1 = (G + 1) * (t0 - 1) + (s0 - 1), z0 = (G + 1) * t0 + (s0 - 1), Z0 = (G + 1) * t0 + s0,
                q1 = (G + 1) * (t0 - 1) + s0;
            b0.setX(w0, o1);
            w0++;
            b0.setX(w0, z0);
            w0++;
            b0.setX(w0, q1);
            w0++;
            b0.setX(w0, z0);
            w0++;
            b0.setX(w0, Z0);
            w0++;
            b0.setX(w0, q1);
            w0++;
        }
    }
    this.setIndex(b0);
    this.addAttribute(Z1e.g1, h0);
    this.addAttribute(Z1e.R2, f0);
    this.addAttribute(Z1e.M3, i0);
    function t1(d, e, f, i, j) {
        var k = Math.cos(d), m = Math.sin(d), n = f / e * d, u = Math.cos(n);
        j.x = i * (2 + u) * Z1e.k1 * k;
        j.y = i * (2 + u) * m * Z1e.k1;
        j.z = i * Math.sin(n) * Z1e.k1;
    }
};
THREE.TorusKnotBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;
THREE.TorusKnotGeometry = function (d, e, f, i, j, k, m) {
    THREE.Geometry.call(this);
    this.type = Z1e.I3;
    this.parameters = {radius: d, tube: e, tubularSegments: f, radialSegments: i, p: j, q: k};
    if (m !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
    this.fromBufferGeometry(new THREE.TorusKnotBufferGeometry(d, e, f, i, j, k));
    this.mergeVertices();
};
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
THREE.TubeGeometry = function (i, j, k, m, n, u) {
    THREE.Geometry.call(this);
    this.type = 'TubeGeometry';
    this.parameters = {path: i, segments: j, radius: k, radialSegments: m, closed: n, taper: u};
    j = j || 64;
    k = k || 1;
    m = m || 8;
    n = n || Z1e.e4;
    u = u || THREE.TubeGeometry.NoTaper;
    var v = [], B = this, C, G, L, N = j + 1, T, S, b0, h0, f0, i0, s0 = new THREE.Vector3(), t0, o0, w0, x0, D0, F0,
        m0, W0, y0, P0, M0, G0, a1 = new THREE.TubeGeometry.FrenetFrames(i, j, n), b1 = a1.tangents, X0 = a1.normals,
        o1 = a1.binormals;
    this.tangents = b1;
    this.normals = X0;
    this.binormals = o1;
    function z0(d, e, f) {
        return B.vertices.push(new THREE.Vector3(d, e, f)) - 1;
    }
    for (t0 = 0; t0 < N; t0++) {
        v[t0] = [];
        T = t0 / (N - 1);
        i0 = i.getPointAt(T);
        C = b1[t0];
        G = X0[t0];
        L = o1[t0];
        b0 = k * u(T);
        for (o0 = 0; o0 < m; o0++) {
            S = o0 / m * 2 * Math.PI;
            h0 = -b0 * Math.cos(S);
            f0 = b0 * Math.sin(S);
            s0.copy(i0);
            s0.x += h0 * G.x + f0 * L.x;
            s0.y += h0 * G.y + f0 * L.y;
            s0.z += h0 * G.z + f0 * L.z;
            v[t0][o0] = z0(s0.x, s0.y, s0.z);
        }
    }
    for (t0 = 0; t0 < j; t0++) {
        for (o0 = 0; o0 < m; o0++) {
            w0 = (n) ? (t0 + 1) % j : t0 + 1;
            x0 = (o0 + 1) % m;
            D0 = v[t0][o0];
            F0 = v[w0][o0];
            m0 = v[w0][x0];
            W0 = v[t0][x0];
            y0 = new THREE.Vector2(t0 / j, o0 / m);
            P0 = new THREE.Vector2((t0 + 1) / j, o0 / m);
            M0 = new THREE.Vector2((t0 + 1) / j, (o0 + 1) / m);
            G0 = new THREE.Vector2(t0 / j, (o0 + 1) / m);
            this.faces.push(new THREE.Face3(D0, F0, W0));
            this.faceVertexUvs[0].push([y0, P0, G0]);
            this.faces.push(new THREE.Face3(F0, m0, W0));
            this.faceVertexUvs[0].push([P0.clone(), M0, G0.clone()]);
        }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
THREE.TubeGeometry.NoTaper = function (d) {
    return 1;
};
THREE.TubeGeometry.SinusoidalTaper = function (d) {
    return Math.sin(Math.PI * d);
};
THREE.TubeGeometry.FrenetFrames = function (d, e, f) {
    var i = new THREE.Vector3(), j = [], k = [], m = [], n = new THREE.Vector3(), u = new THREE.Matrix4(), v = e + 1, B,
        C, G, L, N, T, S;
    this.tangents = j;
    this.normals = k;
    this.binormals = m;
    for (T = 0; T < v; T++) {
        S = T / (v - 1);
        j[T] = d.getTangentAt(S);
        j[T].normalize();
    }
    b0();
    function b0() {
        k[0] = new THREE.Vector3();
        m[0] = new THREE.Vector3();
        C = Number.MAX_VALUE;
        G = Math.abs(j[0].x);
        L = Math.abs(j[0].y);
        N = Math.abs(j[0].z);
        if (G <= C) {
            C = G;
            i.set(1, 0, 0);
        }
        if (L <= C) {
            C = L;
            i.set(0, 1, 0);
        }
        if (N <= C) {
            i.set(0, 0, 1);
        }
        n.crossVectors(j[0], i).normalize();
        k[0].crossVectors(j[0], n);
        m[0].crossVectors(j[0], k[0]);
    }
    for (T = 1; T < v; T++) {
        k[T] = k[T - 1].clone();
        m[T] = m[T - 1].clone();
        n.crossVectors(j[T - 1], j[T]);
        if (n.length() > Number.EPSILON) {
            n.normalize();
            B = Math.acos(THREE.Math.clamp(j[T - 1].dot(j[T]), -1, 1));
            k[T].applyMatrix4(u.makeRotationAxis(n, B));
        }
        m[T].crossVectors(j[T], k[T]);
    }
    if (f) {
        B = Math.acos(THREE.Math.clamp(k[0].dot(k[v - 1]), -1, 1));
        B /= (v - 1);
        if (j[0].dot(n.crossVectors(k[0], k[v - 1])) > 0) {
            B = -B;
        }
        for (T = 1; T < v; T++) {
            k[T].applyMatrix4(u.makeRotationAxis(j[T], B * T));
            m[T].crossVectors(j[T], k[T]);
        }
    }
};
THREE.PolyhedronGeometry = function (N, T, S, b0) {
    THREE.Geometry.call(this);
    this.type = 'PolyhedronGeometry';
    this.parameters = {vertices: N, indices: T, radius: S, detail: b0};
    S = S || 1;
    b0 = b0 || 0;
    var h0 = this;
    for (var f0 = 0, i0 = N.length; f0 < i0; f0 += 3) {
        a1(new THREE.Vector3(N[f0], N[f0 + 1], N[f0 + 2]));
    }
    var s0 = this.vertices, t0 = [];
    for (var f0 = 0, o0 = 0, i0 = T.length; f0 < i0; f0 += 3, o0++) {
        var w0 = s0[T[f0]], x0 = s0[T[f0 + 1]], D0 = s0[T[f0 + 2]];
        t0[o0] = new THREE.Face3(w0.index, x0.index, D0.index, [w0.clone(), x0.clone(), D0.clone()], undefined, o0);
    }
    var F0 = new THREE.Vector3();
    for (var f0 = 0, i0 = t0.length; f0 < i0; f0++) {
        X0(t0[f0], b0);
    }
    for (var f0 = 0, i0 = this.faceVertexUvs[0].length; f0 < i0; f0++) {
        var m0 = this.faceVertexUvs[0][f0], W0 = m0[0].x, y0 = m0[1].x, P0 = m0[2].x, M0 = Math.max(W0, y0, P0),
            G0 = Math.min(W0, y0, P0);
        if (M0 > 0.9 && G0 < 0.1) {
            if (W0 < 0.2) m0[0].x += 1;
            if (y0 < 0.2) m0[1].x += 1;
            if (P0 < 0.2) m0[2].x += 1;
        }
    }
    for (var f0 = 0, i0 = this.vertices.length; f0 < i0; f0++) {
        this.vertices[f0].multiplyScalar(S);
    }
    this.mergeVertices();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), S);
    function a1(d) {
        var e = d.normalize().clone();
        e.index = h0.vertices.push(e) - 1;
        var f = o1(d) / 2 / Math.PI + Z1e.k1, i = z0(d) / Math.PI + Z1e.k1;
        e.uv = new THREE.Vector2(f, 1 - i);
        return e;
    }
    function b1(d, e, f, i) {
        var j = new THREE.Face3(d.index, e.index, f.index, [d.clone(), e.clone(), f.clone()], undefined, i);
        h0.faces.push(j);
        F0.copy(d).add(e).add(f).divideScalar(3);
        var k = o1(F0);
        h0.faceVertexUvs[0].push([Z0(d.uv, d, k), Z0(e.uv, e, k), Z0(f.uv, f, k)]);
    }
    function X0(d, e) {
        var f = Math.pow(2, e), i = a1(h0.vertices[d.a]), j = a1(h0.vertices[d.b]), k = a1(h0.vertices[d.c]), m = [],
            n = d.materialIndex;
        for (var u = 0; u <= f; u++) {
            m[u] = [];
            var v = a1(i.clone().lerp(k, u / f)), B = a1(j.clone().lerp(k, u / f)), C = f - u;
            for (var G = 0; G <= C; G++) {
                if (G === 0 && u === f) {
                    m[u][G] = v;
                } else {
                    m[u][G] = a1(v.clone().lerp(B, G / C));
                }
            }
        }
        for (var u = 0; u < f; u++) {
            for (var G = 0; G < 2 * (f - u) - 1; G++) {
                var L = Math.floor(G / 2);
                if (G % 2 === 0) {
                    b1(m[u][L + 1], m[u + 1][L], m[u][L], n);
                } else {
                    b1(m[u][L + 1], m[u + 1][L + 1], m[u + 1][L], n);
                }
            }
        }
    }
    function o1(d) {
        return Math.atan2(d.z, -d.x);
    }
    function z0(d) {
        return Math.atan2(-d.y, Math.sqrt((d.x * d.x) + (d.z * d.z)));
    }
    function Z0(d, e, f) {
        if ((f < 0) && (d.x === 1)) d = new THREE.Vector2(d.x - 1, d.y);
        if ((e.x === 0) && (e.z === 0)) d = new THREE.Vector2(f / 2 / Math.PI + Z1e.k1, d.y);
        return d.clone();
    }
};
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
THREE.DodecahedronGeometry = function (d, e) {
    var f = (1 + Math.sqrt(5)) / 2, i = 1 / f,
        j = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -f, 0, -i, f, 0, i, -f, 0, i, f, -i, -f, 0, -i, f, 0, i, -f, 0, i, f, 0, -f, 0, -i, f, 0, -i, -f, 0, i, f, 0, i],
        k = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    THREE.PolyhedronGeometry.call(this, j, k, d, e);
    this.type = Z1e.r0;
    this.parameters = {radius: d, detail: e};
};
THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
THREE.IcosahedronGeometry = function (d, e) {
    var f = (1 + Math.sqrt(5)) / 2,
        i = [-1, f, 0, 1, f, 0, -1, -f, 0, 1, -f, 0, 0, -1, f, 0, 1, f, 0, -1, -f, 0, 1, -f, f, 0, -1, f, 0, 1, -f, 0, -1, -f, 0, 1],
        j = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    THREE.PolyhedronGeometry.call(this, i, j, d, e);
    this.type = Z1e.I;
    this.parameters = {radius: d, detail: e};
};
THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
THREE.OctahedronGeometry = function (d, e) {
    var f = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
        i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    THREE.PolyhedronGeometry.call(this, f, i, d, e);
    this.type = Z1e.j2;
    this.parameters = {radius: d, detail: e};
};
THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
THREE.TetrahedronGeometry = function (d, e) {
    var f = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    THREE.PolyhedronGeometry.call(this, f, i, d, e);
    this.type = Z1e.C1;
    this.parameters = {radius: d, detail: e};
};
THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
THREE.ParametricGeometry = function (d, e, f) {
    THREE.Geometry.call(this);
    this.type = 'ParametricGeometry';
    this.parameters = {func: d, slices: e, stacks: f};
    var i = this.vertices, j = this.faces, k = this.faceVertexUvs[0], m, n, u, v, B, C = e + 1;
    for (m = 0; m <= f; m++) {
        B = m / f;
        for (n = 0; n <= e; n++) {
            v = n / e;
            u = d(v, B);
            i.push(u);
        }
    }
    var G, L, N, T, S, b0, h0, f0;
    for (m = 0; m < f; m++) {
        for (n = 0; n < e; n++) {
            G = m * C + n;
            L = m * C + n + 1;
            N = (m + 1) * C + n + 1;
            T = (m + 1) * C + n;
            S = new THREE.Vector2(n / e, m / f);
            b0 = new THREE.Vector2((n + 1) / e, m / f);
            h0 = new THREE.Vector2((n + 1) / e, (m + 1) / f);
            f0 = new THREE.Vector2(n / e, (m + 1) / f);
            j.push(new THREE.Face3(G, L, T));
            k.push([S, b0, f0]);
            j.push(new THREE.Face3(L, N, T));
            k.push([b0.clone(), h0, f0.clone()]);
        }
    }
    this.computeFaceNormals();
    this.computeVertexNormals();
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
THREE.WireframeGeometry = function (f) {
    THREE.BufferGeometry.call(this);
    var i = [0, 0], j = {};
    function k(d, e) {
        return d - e;
    }
    var m = ['a', 'b', 'c'];
    if (f instanceof THREE.Geometry) {
        var n = f.vertices, u = f.faces, v = 0, B = new Uint32Array(6 * u.length);
        for (var C = 0, G = u.length; C < G; C++) {
            var L = u[C];
            for (var N = 0; N < 3; N++) {
                i[0] = L[m[N]];
                i[1] = L[m[(N + 1) % 3]];
                i.sort(k);
                var T = i.toString();
                if (j[T] === undefined) {
                    B[2 * v] = i[0];
                    B[2 * v + 1] = i[1];
                    j[T] = Z1e.n3;
                    v++;
                }
            }
        }
        var S = new Float32Array(v * 2 * 3);
        for (var C = 0, G = v; C < G; C++) {
            for (var N = 0; N < 2; N++) {
                var b0 = n[B[2 * C + N]], h0 = 6 * C + 3 * N;
                S[h0 + 0] = b0.x;
                S[h0 + 1] = b0.y;
                S[h0 + 2] = b0.z;
            }
        }
        this.addAttribute(Z1e.g1, new THREE.BufferAttribute(S, 3));
    } else if (f instanceof THREE.BufferGeometry) {
        if (f.index !== Z1e.l3) {
            var f0 = f.index.array, n = f.attributes.position, i0 = f.groups, v = 0;
            if (i0.length === 0) {
                f.addGroup(0, f0.length);
            }
            var B = new Uint32Array(2 * f0.length);
            for (var s0 = 0, t0 = i0.length; s0 < t0; ++s0) {
                var o0 = i0[s0], w0 = o0.start, x0 = o0.count;
                for (var C = w0, D0 = w0 + x0; C < D0; C += 3) {
                    for (var N = 0; N < 3; N++) {
                        i[0] = f0[C + N];
                        i[1] = f0[C + (N + 1) % 3];
                        i.sort(k);
                        var T = i.toString();
                        if (j[T] === undefined) {
                            B[2 * v] = i[0];
                            B[2 * v + 1] = i[1];
                            j[T] = Z1e.n3;
                            v++;
                        }
                    }
                }
            }
            var S = new Float32Array(v * 2 * 3);
            for (var C = 0, G = v; C < G; C++) {
                for (var N = 0; N < 2; N++) {
                    var h0 = 6 * C + 3 * N, F0 = B[2 * C + N];
                    S[h0 + 0] = n.getX(F0);
                    S[h0 + 1] = n.getY(F0);
                    S[h0 + 2] = n.getZ(F0);
                }
            }
            this.addAttribute(Z1e.g1, new THREE.BufferAttribute(S, 3));
        } else {
            var n = f.attributes.position.array, v = n.length / 3, m0 = v / 3, S = new Float32Array(v * 2 * 3);
            for (var C = 0, G = m0; C < G; C++) {
                for (var N = 0; N < 3; N++) {
                    var h0 = 18 * C + 6 * N, W0 = 9 * C + 3 * N;
                    S[h0 + 0] = n[W0];
                    S[h0 + 1] = n[W0 + 1];
                    S[h0 + 2] = n[W0 + 2];
                    var F0 = 9 * C + 3 * ((N + 1) % 3);
                    S[h0 + 3] = n[F0];
                    S[h0 + 4] = n[F0 + 1];
                    S[h0 + 5] = n[F0 + 2];
                }
            }
            this.addAttribute(Z1e.g1, new THREE.BufferAttribute(S, 3));
        }
    }
};
THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
THREE.AxisHelper = function (d) {
    d = d || 1;
    var e = new Float32Array([0, 0, 0, d, 0, 0, 0, 0, 0, 0, d, 0, 0, 0, 0, 0, 0, d]),
        f = new Float32Array([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1]),
        i = new THREE.BufferGeometry();
    i.addAttribute(Z1e.g1, new THREE.BufferAttribute(e, 3));
    i.addAttribute(Z1e.X1, new THREE.BufferAttribute(f, 3));
    var j = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
    THREE.LineSegments.call(this, i, j);
};
THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
THREE.ArrowHelper = (function () {
    var m = new THREE.Geometry();
    m.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
    var n = new THREE.CylinderGeometry(0, Z1e.k1, 1, 5, 1);
    n.translate(0, -Z1e.k1, 0);
    return function u(d, e, f, i, j, k) {
        THREE.Object3D.call(this);
        if (i === undefined) i = 0xffff00;
        if (f === undefined) f = 1;
        if (j === undefined) j = 0.2 * f;
        if (k === undefined) k = 0.2 * j;
        this.position.copy(e);
        this.line = new THREE.Line(m, new THREE.LineBasicMaterial({color: i}));
        this.line.matrixAutoUpdate = Z1e.e4;
        this.add(this.line);
        this.cone = new THREE.Mesh(n, new THREE.MeshBasicMaterial({color: i}));
        this.cone.matrixAutoUpdate = Z1e.e4;
        this.add(this.cone);
        this.setDirection(d);
        this.setLength(f, j, k);
    };
}());
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
THREE.ArrowHelper.prototype.setDirection = (function () {
    var e = new THREE.Vector3(), f;
    return function i(d) {
        if (d.y > Z1e.V1) {
            this.quaternion.set(0, 0, 0, 1);
        } else if (d.y < -Z1e.V1) {
            this.quaternion.set(1, 0, 0, 0);
        } else {
            e.set(d.z, 0, -d.x).normalize();
            f = Math.acos(d.y);
            this.quaternion.setFromAxisAngle(e, f);
        }
    };
}());
THREE.ArrowHelper.prototype.setLength = function (d, e, f) {
    if (e === undefined) e = 0.2 * d;
    if (f === undefined) f = 0.2 * e;
    this.line.scale.set(1, Math.max(0, d - e), 1);
    this.line.updateMatrix();
    this.cone.scale.set(f, e, f);
    this.cone.position.y = d;
    this.cone.updateMatrix();
};
THREE.ArrowHelper.prototype.setColor = function (d) {
    this.line.material.color.set(d);
    this.cone.material.color.set(d);
};
THREE.ArrowHelper2 = (function () {
    var m = new THREE.CylinderGeometry(Z1e.k1, Z1e.k1, 1, 5, 5);
    m.translate(0, Z1e.k1, 0);
    var n = new THREE.CylinderGeometry(0, 1.5, 1, 5, 5);
    n.translate(0, -Z1e.k1, 0);
    return function u(d, e, f, i, j, k) {
        THREE.Object3D.call(this);
        if (i === undefined) i = 0xffff00;
        if (f === undefined) f = 1;
        if (j === undefined) j = 0.3 * f;
        if (k === undefined) k = 0.3 * j;
        this.position.copy(e);
        this.line = new THREE.Mesh(m, new THREE.MeshPhongMaterial({color: i}));
        this.line.matrixAutoUpdate = Z1e.e4;
        this.add(this.line);
        this.cone = new THREE.Mesh(n, new THREE.MeshPhongMaterial({color: i}));
        this.cone.matrixAutoUpdate = Z1e.e4;
        this.add(this.cone);
        this.setDirection(d);
        this.setLength(f, j, k);
    };
}());
THREE.ArrowHelper2.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper2.prototype.constructor = THREE.ArrowHelper2;
THREE.ArrowHelper2.prototype.setDirection = (function () {
    var e = new THREE.Vector3(), f;
    return function i(d) {
        if (d.y > Z1e.V1) {
            this.quaternion.set(0, 0, 0, 1);
        } else if (d.y < -Z1e.V1) {
            this.quaternion.set(1, 0, 0, 0);
        } else {
            e.set(d.z, 0, -d.x).normalize();
            f = Math.acos(d.y);
            this.quaternion.setFromAxisAngle(e, f);
        }
    };
}());
THREE.ArrowHelper2.prototype.setLength = function (d, e, f) {
    if (e === undefined) e = 0.2 * d;
    if (f === undefined) f = 0.2 * e;
    this.line.scale.set(1, Math.max(0, d - e), 1);
    this.line.updateMatrix();
    this.cone.scale.set(f, e, f);
    this.cone.position.y = d;
    this.cone.updateMatrix();
};
THREE.ArrowHelper2.prototype.setColor = function (d) {
    this.line.material.color.set(d);
    this.cone.material.color.set(d);
};
THREE.BoxHelper = function (d) {
    var e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
        f = new Float32Array(8 * 3), i = new THREE.BufferGeometry();
    i.setIndex(new THREE.BufferAttribute(e, 1));
    i.addAttribute(Z1e.g1, new THREE.BufferAttribute(f, 3));
    THREE.LineSegments.call(this, i, new THREE.LineBasicMaterial({color: 0xffff00}));
    if (d !== undefined) {
        this.update(d);
    }
};
THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
THREE.BoxHelper.prototype.update = (function () {
    var k = new THREE.Box3();
    return function (d) {
        if (d instanceof THREE.Box3) {
            k.copy(d);
        } else {
            k.setFromObject(d);
        }
        if (k.isEmpty())return;
        var e = k.min, f = k.max, i = this.geometry.attributes.position, j = i.array;
        j[0] = f.x;
        j[1] = f.y;
        j[2] = f.z;
        j[3] = e.x;
        j[4] = f.y;
        j[5] = f.z;
        j[6] = e.x;
        j[7] = e.y;
        j[8] = f.z;
        j[9] = f.x;
        j[10] = e.y;
        j[11] = f.z;
        j[12] = f.x;
        j[13] = f.y;
        j[14] = e.z;
        j[15] = e.x;
        j[16] = f.y;
        j[17] = e.z;
        j[18] = e.x;
        j[19] = e.y;
        j[20] = e.z;
        j[21] = f.x;
        j[22] = e.y;
        j[23] = e.z;
        i.needsUpdate = Z1e.n3;
        this.geometry.computeBoundingSphere();
    };
})();
THREE.BoundingBoxHelper = function (d, e) {
    var f = (e !== undefined) ? e : 0x888888;
    this.object = d;
    this.box = new THREE.Box3();
    THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({color: f, wireframe: Z1e.n3}));
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
THREE.BoundingBoxHelper.prototype.update = function () {
    this.box.setFromObject(this.object);
    this.box.size(this.scale);
    this.box.center(this.position);
};
THREE.CameraHelper = function (i) {
    var j = new THREE.Geometry(), k = new THREE.LineBasicMaterial({color: 0xffffff, vertexColors: THREE.FaceColors}),
        m = {}, n = 0xffaa00, u = 0xff0000, v = 0x00aaff, B = 0xffffff, C = 0x333333;
    G("n1", "n2", n);
    G("n2", "n4", n);
    G("n4", "n3", n);
    G("n3", "n1", n);
    G("f1", "f2", n);
    G("f2", "f4", n);
    G("f4", "f3", n);
    G("f3", "f1", n);
    G("n1", "f1", n);
    G("n2", "f2", n);
    G("n3", "f3", n);
    G("n4", "f4", n);
    G("p", "n1", u);
    G("p", "n2", u);
    G("p", "n3", u);
    G("p", "n4", u);
    G("u1", "u2", v);
    G("u2", "u3", v);
    G("u3", "u1", v);
    G(Z1e.Q0, Z1e.e2, B);
    G("p", Z1e.Q0, C);
    G("cn1", "cn2", C);
    G("cn3", "cn4", C);
    G("cf1", "cf2", C);
    G("cf3", "cf4", C);
    function G(d, e, f) {
        L(d, f);
        L(e, f);
    }
    function L(d, e) {
        j.vertices.push(new THREE.Vector3());
        j.colors.push(new THREE.Color(e));
        if (m[d] === undefined) {
            m[d] = [];
        }
        m[d].push(j.vertices.length - 1);
    }
    THREE.LineSegments.call(this, j, k);
    this.camera = i;
    this.camera.updateProjectionMatrix();
    this.matrix = i.matrixWorld;
    this.matrixAutoUpdate = Z1e.e4;
    this.pointMap = m;
    this.update();
};
THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
THREE.CameraHelper.prototype.update = function () {
    var n, u, v = new THREE.Vector3(), B = new THREE.Camera();
    function C(d, e, f, i) {
        v.set(e, f, i).unproject(B);
        var j = u[d];
        if (j !== undefined) {
            for (var k = 0, m = j.length; k < m; k++) {
                n.vertices[j[k]].copy(v);
            }
        }
    }
    return function () {
        n = this.geometry;
        u = this.pointMap;
        var d = 1, e = 1;
        B.projectionMatrix.copy(this.camera.projectionMatrix);
        C(Z1e.Q0, 0, 0, -1);
        C(Z1e.e2, 0, 0, 1);
        C("n1", -d, -e, -1);
        C("n2", d, -e, -1);
        C("n3", -d, e, -1);
        C("n4", d, e, -1);
        C("f1", -d, -e, 1);
        C("f2", d, -e, 1);
        C("f3", -d, e, 1);
        C("f4", d, e, 1);
        C("u1", d * 0.7, e * 1.1, -1);
        C("u2", -d * 0.7, e * 1.1, -1);
        C("u3", 0, e * 2, -1);
        C("cf1", -d, 0, 1);
        C("cf2", d, 0, 1);
        C("cf3", 0, -e, 1);
        C("cf4", 0, e, 1);
        C("cn1", -d, 0, -1);
        C("cn2", d, 0, -1);
        C("cn3", 0, -e, -1);
        C("cn4", 0, e, -1);
        n.verticesNeedUpdate = Z1e.n3;
    };
}();
THREE.DirectionalLightHelper = function (d, e) {
    THREE.Object3D.call(this);
    this.light = d;
    this.light.updateMatrixWorld();
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = Z1e.e4;
    e = e || 1;
    var f = new THREE.Geometry();
    f.vertices.push(new THREE.Vector3(-e, e, 0), new THREE.Vector3(e, e, 0), new THREE.Vector3(e, -e, 0), new THREE.Vector3(-e, -e, 0), new THREE.Vector3(-e, e, 0));
    var i = new THREE.LineBasicMaterial({fog: Z1e.e4});
    i.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.lightPlane = new THREE.Line(f, i);
    this.add(this.lightPlane);
    f = new THREE.Geometry();
    f.vertices.push(new THREE.Vector3(), new THREE.Vector3());
    i = new THREE.LineBasicMaterial({fog: Z1e.e4});
    i.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine = new THREE.Line(f, i);
    this.add(this.targetLine);
    this.update();
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
THREE.DirectionalLightHelper.prototype.dispose = function () {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
};
THREE.DirectionalLightHelper.prototype.update = function () {
    var d = new THREE.Vector3(), e = new THREE.Vector3(), f = new THREE.Vector3();
    return function () {
        d.setFromMatrixPosition(this.light.matrixWorld);
        e.setFromMatrixPosition(this.light.target.matrixWorld);
        f.subVectors(e, d);
        this.lightPlane.lookAt(f);
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine.geometry.vertices[1].copy(f);
        this.targetLine.geometry.verticesNeedUpdate = Z1e.n3;
        this.targetLine.material.color.copy(this.lightPlane.material.color);
    };
}();
THREE.EdgesHelper = function (d, e, f) {
    var i = (e !== undefined) ? e : 0xffffff;
    THREE.LineSegments.call(this, new THREE.EdgesGeometry(d.geometry, f), new THREE.LineBasicMaterial({color: i}));
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = Z1e.e4;
};
THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
THREE.FaceNormalsHelper = function (d, e, f, i) {
    this.object = d;
    this.size = (e !== undefined) ? e : 1;
    var j = (f !== undefined) ? f : 0xffff00, k = (i !== undefined) ? i : 1, m = 0, n = this.object.geometry;
    if (n instanceof THREE.Geometry) {
        m = n.faces.length;
    } else {
        console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
    }
    var u = new THREE.BufferGeometry(), v = new THREE.Float32Attribute(m * 2 * 3, 3);
    u.addAttribute(Z1e.g1, v);
    THREE.LineSegments.call(this, u, new THREE.LineBasicMaterial({color: j, linewidth: k}));
    this.matrixAutoUpdate = Z1e.e4;
    this.update();
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
THREE.FaceNormalsHelper.prototype.update = (function () {
    var B = new THREE.Vector3(), C = new THREE.Vector3(), G = new THREE.Matrix3();
    return function L() {
        this.object.updateMatrixWorld(Z1e.n3);
        G.getNormalMatrix(this.object.matrixWorld);
        var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry,
            i = f.vertices, j = f.faces, k = 0;
        for (var m = 0, n = j.length; m < n; m++) {
            var u = j[m], v = u.normal;
            B.copy(i[u.a]).add(i[u.b]).add(i[u.c]).divideScalar(3).applyMatrix4(d);
            C.copy(v).applyMatrix3(G).normalize().multiplyScalar(this.size).add(B);
            e.setXYZ(k, B.x, B.y, B.z);
            k = k + 1;
            e.setXYZ(k, C.x, C.y, C.z);
            k = k + 1;
        }
        e.needsUpdate = Z1e.n3;
        return this;
    };
}());
THREE.GridHelper = function (d, e) {
    var f = new THREE.Geometry(), i = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
    this.color1 = new THREE.Color(0x444444);
    this.color2 = new THREE.Color(0x888888);
    for (var j = -d; j <= d; j += e) {
        f.vertices.push(new THREE.Vector3(-d, 0, j), new THREE.Vector3(d, 0, j), new THREE.Vector3(j, 0, -d), new THREE.Vector3(j, 0, d));
        var k = j === 0 ? this.color1 : this.color2;
        f.colors.push(k, k, k, k);
    }
    THREE.LineSegments.call(this, f, i);
};
THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.GridHelper.prototype.constructor = THREE.GridHelper;
THREE.GridHelper.prototype.setColors = function (d, e) {
    this.color1.set(d);
    this.color2.set(e);
    this.geometry.colorsNeedUpdate = Z1e.n3;
};
THREE.HemisphereLightHelper = function (d, e) {
    THREE.Object3D.call(this);
    this.light = d;
    this.light.updateMatrixWorld();
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = Z1e.e4;
    this.colors = [new THREE.Color(), new THREE.Color()];
    var f = new THREE.SphereGeometry(e, 4, 2);
    f.rotateX(-Math.PI / 2);
    for (var i = 0, j = 8; i < j; i++) {
        f.faces[i].color = this.colors[i < 4 ? 0 : 1];
    }
    var k = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors, wireframe: Z1e.n3});
    this.lightSphere = new THREE.Mesh(f, k);
    this.add(this.lightSphere);
    this.update();
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
THREE.HemisphereLightHelper.prototype.dispose = function () {
    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose();
};
THREE.HemisphereLightHelper.prototype.update = function () {
    var d = new THREE.Vector3();
    return function () {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(d.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = Z1e.n3;
    };
}();
THREE.PointLightHelper = function (d, e) {
    this.light = d;
    this.light.updateMatrixWorld();
    var f = new THREE.SphereGeometry(e, 4, 2), i = new THREE.MeshBasicMaterial({wireframe: Z1e.n3, fog: Z1e.e4});
    i.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    THREE.Mesh.call(this, f, i);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = Z1e.e4;
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
THREE.PointLightHelper.prototype.dispose = function () {
    this.geometry.dispose();
    this.material.dispose();
};
THREE.PointLightHelper.prototype.update = function () {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};
THREE.SkeletonHelper = function (d) {
    this.bones = this.getBoneList(d);
    var e = new THREE.Geometry();
    for (var f = 0; f < this.bones.length; f++) {
        var i = this.bones[f];
        if (i.parent instanceof THREE.Bone) {
            e.vertices.push(new THREE.Vector3());
            e.vertices.push(new THREE.Vector3());
            e.colors.push(new THREE.Color(0, 0, 1));
            e.colors.push(new THREE.Color(0, 1, 0));
        }
    }
    e.dynamic = Z1e.n3;
    var j = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: Z1e.e4,
        depthWrite: Z1e.e4,
        transparent: Z1e.n3
    });
    THREE.LineSegments.call(this, e, j);
    this.root = d;
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = Z1e.e4;
    this.update();
};
THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
THREE.SkeletonHelper.prototype.getBoneList = function (d) {
    var e = [];
    if (d instanceof THREE.Bone) {
        e.push(d);
    }
    for (var f = 0; f < d.children.length; f++) {
        e.push.apply(e, this.getBoneList(d.children[f]));
    }
    return e;
};
THREE.SkeletonHelper.prototype.update = function () {
    var d = this.geometry, e = new THREE.Matrix4().getInverse(this.root.matrixWorld), f = new THREE.Matrix4(), i = 0;
    for (var j = 0; j < this.bones.length; j++) {
        var k = this.bones[j];
        if (k.parent instanceof THREE.Bone) {
            f.multiplyMatrices(e, k.matrixWorld);
            d.vertices[i].setFromMatrixPosition(f);
            f.multiplyMatrices(e, k.parent.matrixWorld);
            d.vertices[i + 1].setFromMatrixPosition(f);
            i += 2;
        }
    }
    d.verticesNeedUpdate = Z1e.n3;
    d.computeBoundingSphere();
};
THREE.SpotLightHelper = function (d) {
    THREE.Object3D.call(this);
    this.light = d;
    this.light.updateMatrixWorld();
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = Z1e.e4;
    var e = new THREE.BufferGeometry(),
        f = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (var i = 0, j = 1, k = 32; i < k; i++, j++) {
        var m = (i / k) * Math.PI * 2, n = (j / k) * Math.PI * 2;
        f.push(Math.cos(m), Math.sin(m), 1, Math.cos(n), Math.sin(n), 1);
    }
    e.addAttribute(Z1e.g1, new THREE.Float32Attribute(f, 3));
    var u = new THREE.LineBasicMaterial({fog: Z1e.e4});
    this.cone = new THREE.LineSegments(e, u);
    this.add(this.cone);
    this.update();
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
THREE.SpotLightHelper.prototype.dispose = function () {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
};
THREE.SpotLightHelper.prototype.update = function () {
    var f = new THREE.Vector3(), i = new THREE.Vector3();
    return function () {
        var d = this.light.distance ? this.light.distance : 1000, e = d * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, d);
        f.setFromMatrixPosition(this.light.matrixWorld);
        i.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(i.sub(f));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
}();
THREE.VertexNormalsHelper = function (d, e, f, i) {
    this.object = d;
    this.size = (e !== undefined) ? e : 1;
    var j = (f !== undefined) ? f : 0xff0000, k = (i !== undefined) ? i : 1, m = 0, n = this.object.geometry;
    if (n instanceof THREE.Geometry) {
        m = n.faces.length * 3;
    } else if (n instanceof THREE.BufferGeometry) {
        m = n.attributes.normal.count;
    }
    var u = new THREE.BufferGeometry(), v = new THREE.Float32Attribute(m * 2 * 3, 3);
    u.addAttribute(Z1e.g1, v);
    THREE.LineSegments.call(this, u, new THREE.LineBasicMaterial({color: j, linewidth: k}));
    this.matrixAutoUpdate = Z1e.e4;
    this.update();
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
THREE.VertexNormalsHelper.prototype.update = (function () {
    var S = new THREE.Vector3(), b0 = new THREE.Vector3(), h0 = new THREE.Matrix3();
    return function f0() {
        var d = ['a', 'b', 'c'];
        this.object.updateMatrixWorld(Z1e.n3);
        h0.getNormalMatrix(this.object.matrixWorld);
        var e = this.object.matrixWorld, f = this.geometry.attributes.position, i = this.object.geometry;
        if (i instanceof THREE.Geometry) {
            var j = i.vertices, k = i.faces, m = 0;
            for (var n = 0, u = k.length; n < u; n++) {
                var v = k[n];
                for (var B = 0, C = v.vertexNormals.length; B < C; B++) {
                    var G = j[v[d[B]]], L = v.vertexNormals[B];
                    S.copy(G).applyMatrix4(e);
                    b0.copy(L).applyMatrix3(h0).normalize().multiplyScalar(this.size).add(S);
                    f.setXYZ(m, S.x, S.y, S.z);
                    m = m + 1;
                    f.setXYZ(m, b0.x, b0.y, b0.z);
                    m = m + 1;
                }
            }
        } else if (i instanceof THREE.BufferGeometry) {
            var N = i.attributes.position, T = i.attributes.normal, m = 0;
            for (var B = 0, C = N.count; B < C; B++) {
                S.set(N.getX(B), N.getY(B), N.getZ(B)).applyMatrix4(e);
                b0.set(T.getX(B), T.getY(B), T.getZ(B));
                b0.applyMatrix3(h0).normalize().multiplyScalar(this.size).add(S);
                f.setXYZ(m, S.x, S.y, S.z);
                m = m + 1;
                f.setXYZ(m, b0.x, b0.y, b0.z);
                m = m + 1;
            }
        }
        f.needsUpdate = Z1e.n3;
        return this;
    };
}());
THREE.WireframeHelper = function (d, e) {
    var f = (e !== undefined) ? e : 0xffffff;
    THREE.LineSegments.call(this, new THREE.WireframeGeometry(d.geometry), new THREE.LineBasicMaterial({color: f}));
    this.matrix = d.matrixWorld;
    this.matrixAutoUpdate = Z1e.e4;
};
THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
THREE.ImmediateRenderObject = function (e) {
    THREE.Object3D.call(this);
    this.material = e;
    this.render = function (d) {
    };
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
THREE.MorphBlendMesh = function (d, e) {
    THREE.Mesh.call(this, d, e);
    this.animationsMap = {};
    this.animationsList = [];
    var f = this.geometry.morphTargets.length, i = "__default", j = 0, k = f - 1, m = f / 1;
    this.createAnimation(i, j, k, m);
    this.setAnimationWeight(i, 1);
};
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
THREE.MorphBlendMesh.prototype.createAnimation = function (d, e, f, i) {
    var j = {
        start: e,
        end: f,
        length: f - e + 1,
        fps: i,
        duration: (f - e) / i,
        lastFrame: 0,
        currentFrame: 0,
        active: Z1e.e4,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: Z1e.e4,
        mirroredLoop: Z1e.e4
    };
    this.animationsMap[d] = j;
    this.animationsList.push(j);
};
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (d) {
    var e = /([a-z]+)_?(\d+)/i, f, i = {}, j = this.geometry;
    for (var k = 0, m = j.morphTargets.length; k < m; k++) {
        var n = j.morphTargets[k], u = n.name.match(e);
        if (u && u.length > 1) {
            var v = u[1];
            if (!i[v]) i[v] = {start: Infinity, end: -Infinity};
            var B = i[v];
            if (k < B.start) B.start = k;
            if (k > B.end) B.end = k;
            if (!f) f = v;
        }
    }
    for (var v in i) {
        var B = i[v];
        this.createAnimation(v, B.start, B.end, d);
    }
    this.firstAnimation = f;
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (d) {
    var e = this.animationsMap[d];
    if (e) {
        e.direction = 1;
        e.directionBackwards = Z1e.e4;
    }
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (d) {
    var e = this.animationsMap[d];
    if (e) {
        e.direction = -1;
        e.directionBackwards = Z1e.n3;
    }
};
THREE.MorphBlendMesh.prototype.setAnimationFPS = function (d, e) {
    var f = this.animationsMap[d];
    if (f) {
        f.fps = e;
        f.duration = (f.end - f.start) / f.fps;
    }
};
THREE.MorphBlendMesh.prototype.setAnimationDuration = function (d, e) {
    var f = this.animationsMap[d];
    if (f) {
        f.duration = e;
        f.fps = (f.end - f.start) / f.duration;
    }
};
THREE.MorphBlendMesh.prototype.setAnimationWeight = function (d, e) {
    var f = this.animationsMap[d];
    if (f) {
        f.weight = e;
    }
};
THREE.MorphBlendMesh.prototype.setAnimationTime = function (d, e) {
    var f = this.animationsMap[d];
    if (f) {
        f.time = e;
    }
};
THREE.MorphBlendMesh.prototype.getAnimationTime = function (d) {
    var e = 0, f = this.animationsMap[d];
    if (f) {
        e = f.time;
    }
    return e;
};
THREE.MorphBlendMesh.prototype.getAnimationDuration = function (d) {
    var e = -1, f = this.animationsMap[d];
    if (f) {
        e = f.duration;
    }
    return e;
};
THREE.MorphBlendMesh.prototype.playAnimation = function (d) {
    var e = this.animationsMap[d];
    if (e) {
        e.time = 0;
        e.active = Z1e.n3;
    } else {
        console.warn("THREE.MorphBlendMesh: animation[" + d + "] undefined in .playAnimation()");
    }
};
THREE.MorphBlendMesh.prototype.stopAnimation = function (d) {
    var e = this.animationsMap[d];
    if (e) {
        e.active = Z1e.e4;
    }
};
THREE.MorphBlendMesh.prototype.update = function (d) {
    for (var e = 0, f = this.animationsList.length; e < f; e++) {
        var i = this.animationsList[e];
        if (!i.active)continue;
        var j = i.duration / i.length;
        i.time += i.direction * d;
        if (i.mirroredLoop) {
            if (i.time > i.duration || i.time < 0) {
                i.direction *= -1;
                if (i.time > i.duration) {
                    i.time = i.duration;
                    i.directionBackwards = Z1e.n3;
                }
                if (i.time < 0) {
                    i.time = 0;
                    i.directionBackwards = Z1e.e4;
                }
            }
        } else {
            i.time = i.time % i.duration;
            if (i.time < 0) i.time += i.duration;
        }
        var k = i.start + THREE.Math.clamp(Math.floor(i.time / j), 0, i.length - 1), m = i.weight;
        if (k !== i.currentFrame) {
            this.morphTargetInfluences[i.lastFrame] = 0;
            this.morphTargetInfluences[i.currentFrame] = 1 * m;
            this.morphTargetInfluences[k] = 0;
            i.lastFrame = i.currentFrame;
            i.currentFrame = k;
        }
        var n = (i.time % j) / j;
        if (i.directionBackwards) n = 1 - n;
        if (i.currentFrame !== i.lastFrame) {
            this.morphTargetInfluences[i.currentFrame] = n * m;
            this.morphTargetInfluences[i.lastFrame] = (1 - n) * m;
        } else {
            this.morphTargetInfluences[i.currentFrame] = m;
        }
    }
};
var F1w7G = {
    'i1G': function (D, M, H, V) {
        return D * M / H / V;
    },
    'K0G': function (D, M) {
        return D === M;
    },
    'R0G': function (D, M) {
        return D === M;
    },
    'U2G': function (D, M) {
        return D === M;
    },
    'H8G': function (D, M) {
        return D > M;
    },
    'Y9G': function (D, M) {
        return D * M;
    },
    'j0G': function (D, M) {
        return D > M;
    },
    'a0C': "constraint",
    'j9G': function (D, M) {
        return D === M;
    },
    'X8G': function (D, M) {
        return D * M;
    },
    'f2G': function (D, M) {
        return D !== M;
    },
    'B0G': function (D, M) {
        return D * M;
    },
    'O8G': function (D, M) {
        return D <= M;
    },
    'z2G': function (D, M) {
        return D === M;
    },
    'W9G': function (D, M) {
        return D instanceof M;
    },
    'k6v': function (D, M) {
        return D !== M;
    },
    'c9G': function (D, M) {
        return D * M;
    },
    'i8G': function (D, M) {
        return D != M;
    },
    'h0G': function (D, M) {
        return D === M;
    },
    'm1G': function (D, M) {
        return D === M;
    },
    'E2G': function (D, M) {
        return D === M;
    },
    'b8G': function (D, M, H, V, o) {
        return D * M * H / V * o;
    },
    'P1G': function (D, M, H, V) {
        return D * M * H / V;
    },
    'F8G': function (D, M) {
        return D !== M;
    },
    'T9G': function (D, M) {
        return D - M;
    },
    'Y5x': 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.',
    'F6v': function (D, M) {
        return D === M;
    },
    'v2G': function (D, M) {
        return D === M;
    },
    'J0C': 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.',
    'M1G': function (D, M, H, V) {
        return D * M * H / V;
    },
    'o0G': function (D, M) {
        return D - M;
    },
    'y2G': function (D, M) {
        return D === M;
    },
    'Z0G': function (D, M) {
        return D * M;
    },
    'A2G': function (D, M) {
        return D === M;
    },
    'r5x': "enableKeys",
    'B9G': function (D, M) {
        return D === M;
    },
    'q1C': 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.',
    'r6x': 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.',
    'g9G': function (D, M) {
        return D * M;
    },
    'w9G': function (D, M, H) {
        return D * M / H;
    },
    't8G': function (D, M) {
        return D - M;
    },
    't2C': "enableZoom",
    'v1G': function (D, M) {
        return D / M;
    },
    's6x': "enableDamping",
    'Q91': (function (B91) {
        return (function (F91, G91) {
            return (function (z91) {
                return {E91: z91, r91: z91,};
            })(function (i91) {
                var j91, x91 = 0;
                for (var n91 = F91; x91 < i91["length"]; x91++) {
                    var I91 = G91(i91, x91);
                    j91 = x91 === 0 ? I91 : j91 ^ I91;
                }
                return j91 ? n91 : !n91;
            });
        })((function (O91, k91, Z91, L91) {
            var U91 = 30;
            return O91(B91, U91) - L91(k91, Z91) > U91;
        })(parseInt, Date, (function (k91) {
            return ('' + k91)["substring"](1, (k91 + '')["length"] - 1);
        })('_getTime2'), function (k91, Z91) {
            return new k91()[Z91]();
        }), function (i91, x91) {
            var Y91 = parseInt(i91["charAt"](x91), 16)["toString"](2);
            return Y91["charAt"](Y91["length"] - 1);
        });
    })('b0d06k000'),
    'c0G': function (D, M, H, V, o) {
        return D * M * H / V * o;
    },
    'f1G': function (D, M) {
        return D instanceof M;
    },
    'O6v': function (D, M) {
        return D === M;
    },
    'm2G': function (D, M) {
        return D === M;
    },
    'e2G': function (D, M) {
        return D !== M;
    },
    'H6v': function (D, M) {
        return D === M;
    },
    'M0C': "target",
    'D5x': "enablePan",
    'k8G': function (D, M) {
        return D - M;
    },
    'k8C': "dampingFactor",
    'N6v': function (D, M) {
        return D === M;
    },
    'Q8G': function (D, M) {
        return D == M;
    },
    'Z9G': function (D, M) {
        return D * M;
    },
    'a0G': function (D, M) {
        return D === M;
    },
    'I6v': function (D, M) {
        return D !== M;
    },
    'w0G': function (D, M) {
        return D === M;
    },
    'I8G': function (D, M) {
        return D !== M;
    },
    's8G': function (D, M) {
        return D - M;
    },
    'h9G': function (D, M) {
        return D === M;
    },
    'J9G': function (D, M) {
        return D > M;
    },
    'l8G': function (D, M) {
        return D * M;
    },
    'z1C': "OrbitControls",
    'P2G': function (D, M) {
        return D === M;
    },
    'Q6v': function (D, M) {
        return D === M;
    },
    'h1C': "enableRotate",
    'd2G': function (D, M) {
        return D === M;
    },
    'u2G': function (D, M) {
        return D !== M;
    },
    'G1G': function (D, M) {
        return D instanceof M;
    },
    'S8G': function (D, M) {
        return D === M;
    },
    'e1G': function (D, M) {
        return D instanceof M;
    },
    'o9G': function (D, M) {
        return D * M;
    },
    'Y6x': "warn",
    'K9G': function (D, M, H, V, o) {
        return D * M / H / V * o;
    },
    'T0G': function (D, M) {
        return D === M;
    },
    'n1C': "create",
    'G2G': function (D, M) {
        return D === M;
    },
    'W0G': function (D, M) {
        return D === M;
    },
    'r6v': function (D, M) {
        return D !== M;
    },
    'M9G': function (D, M) {
        return D * M;
    },
    'D6v': function (D, M) {
        return D === M;
    },
    'b7G': function (D, M) {
        return D !== M;
    },
    'm6x': 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.',
    'N8G': function (D, M) {
        return D < M;
    },
    'a9G': function (D, M) {
        return D > M;
    },
    'D8G': function (D, M, H, V, o) {
        return D * M * H / V * o;
    },
    'C2G': function (D, M) {
        return D === M;
    },
    'i6v': function (D, M) {
        return D === M;
    },
    'z1G': function (D, M) {
        return D instanceof M;
    },
    'n0G': function (D, M) {
        return D < M;
    },
    'x2G': function (D, M) {
        return D === M;
    },
    'Q1G': function (D, M) {
        return D instanceof M;
    },
    'Y0G': function (D, M) {
        return D - M;
    },
    'V6v': function (D, M) {
        return D !== M;
    },
    'r8G': function (D, M) {
        return D > M;
    },
    'p6v': function (D, M) {
        return D === M;
    },
    'B1G': function (D, M, H, V) {
        return D * M / H / V;
    },
    'L2G': function (D, M) {
        return D === M;
    },
    'y1G': function (D, M) {
        return D * M;
    },
    'V8G': function (D, M) {
        return D < M;
    },
    'n9G': function (D, M) {
        return D - M;
    },
    'q1G': function (D, M, H, V, o) {
        return D * M * H / V * o;
    },
    'q2G': function (D, M) {
        return D === M;
    },
    'p8C': 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.',
    'j2C': "defineProperties",
    'J0G': function (D, M) {
        return D == M;
    }
};
F1w7G.G11 = function (l) {
    if (F1w7G && l)return F1w7G.Q91.E91(l);
};
F1w7G.j11 = function (k) {
    if (F1w7G && k)return F1w7G.Q91.r91(k);
};
F1w7G.L11 = function (a) {
    while (a)return F1w7G.Q91.E91(a);
};
F1w7G.O11 = function (j) {
    while (j)return F1w7G.Q91.E91(j);
};
F1w7G.B11 = function (j) {
    for (; F1w7G;)return F1w7G.Q91.E91(j);
};
F1w7G.U11 = function (d) {
    for (; F1w7G;)return F1w7G.Q91.r91(d);
};
F1w7G.Z11 = function (a) {
    for (; F1w7G;)return F1w7G.Q91.r91(a);
};
F1w7G.x11 = function (k) {
    if (F1w7G && k)return F1w7G.Q91.r91(k);
};
F1w7G.i11 = function (l) {
    if (F1w7G && l)return F1w7G.Q91.r91(l);
};
F1w7G.Y11 = function (i) {
    if (F1w7G && i)return F1w7G.Q91.E91(i);
};
F1w7G.Q11 = function (k) {
    if (F1w7G && k)return F1w7G.Q91.E91(k);
};
F1w7G.o11 = function (m) {
    for (; F1w7G;)return F1w7G.Q91.E91(m);
};
F1w7G.V11 = function (f) {
    if (F1w7G && f)return F1w7G.Q91.r91(f);
};
F1w7G.c11 = function (m) {
    if (F1w7G && m)return F1w7G.Q91.r91(m);
};
F1w7G.p11 = function (a) {
    while (a)return F1w7G.Q91.r91(a);
};
F1w7G.M11 = function (k) {
    if (F1w7G && k)return F1w7G.Q91.E91(k);
};
F1w7G.D11 = function (c) {
    for (; F1w7G;)return F1w7G.Q91.r91(c);
};
F1w7G.w91 = function (c) {
    for (; F1w7G;)return F1w7G.Q91.E91(c);
};
F1w7G.d91 = function (n) {
    while (n)return F1w7G.Q91.E91(n);
};
F1w7G.S91 = function (m) {
    while (m)return F1w7G.Q91.E91(m);
};
F1w7G.W91 = function (e) {
    for (; F1w7G;)return F1w7G.Q91.E91(e);
};
F1w7G.q91 = function (f) {
    for (; F1w7G;)return F1w7G.Q91.E91(f);
};
F1w7G.X91 = function (a) {
    for (; F1w7G;)return F1w7G.Q91.r91(a);
};
F1w7G.h91 = function (a) {
    while (a)return F1w7G.Q91.r91(a);
};
F1w7G.m91 = function (a) {
    while (a)return F1w7G.Q91.E91(a);
};
F1w7G.l91 = function (c) {
    while (c)return F1w7G.Q91.E91(c);
};
F1w7G.R91 = function (a) {
    if (F1w7G && a)return F1w7G.Q91.E91(a);
};
F1w7G.v91 = function (e) {
    for (; F1w7G;)return F1w7G.Q91.E91(e);
};
F1w7G.t91 = function (m) {
    while (m)return F1w7G.Q91.E91(m);
};
F1w7G.e91 = function (b) {
    while (b)return F1w7G.Q91.r91(b);
};
F1w7G.a91 = function (d) {
    for (; F1w7G;)return F1w7G.Q91.E91(d);
};
F1w7G.J91 = function (f) {
    while (f)return F1w7G.Q91.r91(f);
};
F1w7G.y91 = function (h) {
    while (h)return F1w7G.Q91.r91(h);
};
THREE[F1w7G.z1C] = F1w7G.y91("aaae") ? './' : function (R, P6, c6, C6, k6) {
    F1w7G.F11 = function (d) {
        for (; F1w7G;)return F1w7G.Q91.r91(d);
    };
    F1w7G.I11 = function (c) {
        while (c)return F1w7G.Q91.E91(c);
    };
    F1w7G.k11 = function (a) {
        for (; F1w7G;)return F1w7G.Q91.E91(a);
    };
    F1w7G.E11 = function (h) {
        if (F1w7G && h)return F1w7G.Q91.r91(h);
    };
    F1w7G.C11 = function (i) {
        if (F1w7G && i)return F1w7G.Q91.r91(i);
    };
    F1w7G.g11 = function (a) {
        for (; F1w7G;)return F1w7G.Q91.E91(a);
    };
    F1w7G.P11 = function (e) {
        for (; F1w7G;)return F1w7G.Q91.r91(e);
    };
    F1w7G.H11 = function (b) {
        if (F1w7G && b)return F1w7G.Q91.E91(b);
    };
    F1w7G.A11 = function (m) {
        while (m)return F1w7G.Q91.E91(m);
    };
    F1w7G.u11 = function (b) {
        if (F1w7G && b)return F1w7G.Q91.r91(b);
    };
    F1w7G.b91 = function (e) {
        if (F1w7G && e)return F1w7G.Q91.E91(e);
    };
    F1w7G.K91 = function (l) {
        while (l)return F1w7G.Q91.r91(l);
    };
    F1w7G.s91 = function (d) {
        for (; F1w7G;)return F1w7G.Q91.r91(d);
    };
    F1w7G.f91 = function (c) {
        if (F1w7G && c)return F1w7G.Q91.E91(c);
    };
    F1w7G.N91 = function (l) {
        for (; F1w7G;)return F1w7G.Q91.E91(l);
    };
    var o6 = F1w7G.J91("3b5e") ? "setFromMatrixColumn" : "colorMask", Y6 = F1w7G.N91("bf4") ? 'depthTest' : "Vector2",
        Z6 = F1w7G.f91("4455") ? "Skeleton" : "Spherical",
        B6 = F1w7G.a91("1fe") ? '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' : 0.000001,
        O6 = F1w7G.s91("dd64") ? "renderType" : 5, x6 = F1w7G.e91("7c2") ? 4 : 0x2F4F4F,
        j6 = F1w7G.K91("d8") ? 'end' : 'RawShaderMaterial', g6 = 'start', U6 = F1w7G.t91("3a71") ? 'change' : '#002',
        T6 = F1w7G.v91("364c") ? 'touchmove' : 'WEBGL_compressed_texture_etc1',
        n6 = F1w7G.R91("85e") ? 'touchend' : 'overdraw', a6 = F1w7G.l91("a86d") ? 'touchstart' : 40,
        G6 = 'MozMousePixelScroll',
        r6 = F1w7G.m91("358d") ? 'mousewheel' : "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n",
        z6 = 'mousedown',
        s6 = F1w7G.h91("71") ? "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n" : 'contextmenu',
        h6 = "dispose", R6 = "reset", w6 = F1w7G.X91("a8c7") ? "updateCamera" : "totalLength",
        K6 = F1w7G.q91("ed2f") ? "re" : "multiplyScalar", N6 = "quaternion", J6 = "applyQuaternion",
        t6 = F1w7G.W91("dbe") ? "PositionalAudio" : "flyViewPoint", A5 = F1w7G.S91("f8") ? "start" : "starttime",
        u5 = "removeHighSpeed", I6 = "onComplete", l6 = "z", c5 = F1w7G.d91("bb") ? "getAzimuthalAngle" : "onUpdate",
        P5 = "InOut", M5 = "Quadratic", C5 = "Easing", o5 = "easing", U5 = F1w7G.w91("d2") ? "to" : "response",
        B5 = "Tween", E5 = "requestHighSpeed", X6 = "sub", W6 = F1w7G.b91("b2cc") ? "flyFromTo" : "dot11",
        x5 = "lookAt", Z5 = "lookFromTo", b6 = "getAzimuthalAngle", g5 = "getPolarAngle",
        v5 = F1w7G.D11("d5e") ? "onMouseMove" : "isAnimate", z5 = F1w7G.u11("8d2") ? "moved" : "areaWeighted",
        j5 = "Quaternion", m5 = "zoom0", e5 = "position0", T5 = "clone", Y5 = F1w7G.M11("b247") ? 0xffaa00 : "target0",
        M3 = "MIDDLE", G5 = F1w7G.p11("e2b") ? "MOUSE" : "groupStart", w5 = 40,
        X5 = F1w7G.A11("36f") ? 'lightgrey' : 39, f5 = 38, A3 = 37,
        C3 = F1w7G.c11("11e") ? "  no animation in JSONLoader data" : 2.0,
        o3 = F1w7G.H11("1a3") ? "starttime" : "autoRotate", R5 = 7.0, x3 = F1w7G.P11("18ee") ? 1.0 : 0xFFFFF0,
        j3 = 0.25, B3 = F1w7G.g11("b54") ? "resourcePath" : "maxAzimuthAngle", S5 = "minAzimuthAngle",
        E3 = "maxPolarAngle", K3 = "minPolarAngle", T3 = "maxDistance", A4 = "minDistance", H3 = "Vector3",
        v3 = F1w7G.V11("17b7") ? 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' : "b7G",
        a5 = "centerMesh", y3 = F1w7G.C11("4ef") ? "add" : "MAX_VERTEX_UNIFORM_VECTORS", b5 = "position",
        c3 = F1w7G.o11("75") ? "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n" : 200,
        H4 = F1w7G.Q11("377") ? "stopPropagation" : "preserveDrawingBuffer", U4 = "zoomSpeed",
        d4 = F1w7G.E11("357") ? "autoRotateSpeed" : "onTouchMove", L3 = "RIGHT", h3 = "LEFT", L5 = "keyPanSpeed",
        L4 = "keys", l4 = F1w7G.Y11("34") ? "phi" : "getHexString", q4 = "theta", K5 = "removeEventListener",
        s7 = F1w7G.i11("7bab") ? "clientHeight" : "gl", P4 = F1w7G.x11("22c1") ? "rotateSpeed" : "handleTouchEnd",
        c7 = "clientWidth", i4 = F1w7G.Z11("a6") ? "inLegToPt" : "x", y4 = F1w7G.k11("1868") ? "PI" : "mieDirectionalG",
        r7 = "body", v4 = 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',
        I4 = true, G3 = F1w7G.U11("b7f8") ? "updateProjectionMatrix" : "factorSeg1",
        r4 = F1w7G.B11("3bf8") ? "maxZoom" : "MaterialLoader", u4 = F1w7G.O11("cfdb") ? "min" : "DEG2RAD",
        P3 = "minZoom", R3 = F1w7G.L11("444f") ? "max" : "hue", p4 = F1w7G.j11("1b") ? "_spriteCount" : "zoom",
        W3 = "OrthographicCamera", Q4 = "PerspectiveCamera", J5 = F1w7G.I11("6e8a") ? "RGB_S3TC_DXT1_Format" : "object",
        q3 = "clientY", b4 = "clientX", J7 = "TOUCH_PAN", m3 = F1w7G.G11("efc7") ? 0x800000 : 3, Q7 = "TOUCH_DOLLY",
        D3 = 2, D7 = "TOUCH_ROTATE", n3 = F1w7G.F11("6f3") ? "ThreeJsRender" : "dispatchEvent", U3 = 'mouseout',
        V4 = 'mouseup', d3 = 'mousemove', H7 = "addEventListener", f4 = "NONE", l5 = "PAN", e4 = "DOLLY", t4 = "ROTATE",
        x4 = "mouseButtons", N7 = "which", Z3 = null, w3 = "preventDefault", Y3 = "domElement", h5 = false,
        s4 = "enabled", q5 = "update", g3 = "copy", S4 = "y", v7 = "subVectors", E4 = "set", M7 = "sqrt", B7 = "pageY",
        F4 = 1, g7 = "pageX", d5 = 0, m4 = "touches";
    function t9(D) {
        var M = "n0G", H = "j0G", V = "B0G", o = "Z0G", Q = "Y0G", i = "o0G",
            k = F1w7G[i](D[m4][d5][g7], D[m4][F4][g7]), U = F1w7G[Q](D[m4][d5][B7], D[m4][F4][B7]),
            O = Math[M7](F1w7G[o](k, k) + F1w7G[V](U, U));
        f9[E4](d5, O);
        G9[v7](f9, N4);
        if (F1w7G[H](G9[S4], d5)) {
            Q9(n7());
        } else if (F1w7G[M](G9[S4], d5)) {
            k9(n7());
        }
        N4[g3](f9);
        S6[q5]();
    }
    function e7(D) {
        var M = "u2G", H = "w0G", V = "W0G", o = "h0G", Q = "ZOOM", i = "R0G", k = "K0G", U = "ORBIT", O = "button",
            I = "a0G", L = "J0G", G = "focus", F = "T0G";
        if (F1w7G[F](S6[s4], h5))return;
        S6[Y3][G]();
        D[w3]();
        O9 = Z3;
        if (F1w7G[L](D[N7], F4)) {
            O9 = new Date();
        }
        if (F1w7G[I](D[O], S6[x4][U])) {
            if (F1w7G[k](S6[F1w7G.h1C], h5))return;
            q7(D);
            z3 = f3[t4];
        } else if (F1w7G[i](D[O], S6[x4][Q])) {
            if (F1w7G[o](S6[F1w7G.t2C], h5))return;
            y9(D);
            z3 = f3[e4];
        } else if (F1w7G[V](D[O], S6[x4][l5])) {
            if (F1w7G[H](S6[F1w7G.D5x], h5))return;
            R7(D);
            z3 = f3[l5];
        }
        if (F1w7G[M](z3, f3[f4])) {
            document[H7](d3, W7, h5);
            document[H7](V4, O7, h5);
            document[H7](U3, O7, h5);
            S6[n3](g1);
        }
    }
    function r9(D) {
        var M = "V6v", H = "H6v", V = "p6v", o = "D6v", Q = "d2G";
        if (F1w7G[Q](S6[s4], h5))return;
        switch (D[m4].length) {
            case F4:
                if (F1w7G[o](S6[F1w7G.h1C], h5))return;
                S9(D);
                z3 = f3[D7];
                break;
            case D3:
                if (F1w7G[V](S6[F1w7G.t2C], h5))return;
                D9(D);
                z3 = f3[Q7];
                break;
            case m3:
                if (F1w7G[H](S6[F1w7G.D5x], h5))return;
                U9(D);
                z3 = f3[J7];
                break;
            default:
                z3 = f3[f4];
        }
        if (F1w7G[M](z3, f3[f4])) {
            S6[n3](g1);
        }
    }
    function U9(D) {
        Y7[E4](D[m4][d5][g7], D[m4][d5][B7]);
    }
    function X9(D) {
        var M = "V8G", H = "H8G";
        f9[E4](D[b4], D[q3]);
        G9[v7](f9, N4);
        if (F1w7G[H](G9[S4], d5)) {
            k9(n7());
        } else if (F1w7G[M](G9[S4], d5)) {
            Q9(n7());
        }
        N4[g3](f9);
        S6[q5]();
    }
    function c1(D) {
        D[w3]();
    }
    function k9(D) {
        var M = "y1G", H = "z1G", V = "G1G";
        if (F1w7G[V](S6[J5], THREE[Q4])) {
            Z7 /= D;
        } else if (F1w7G[H](S6[J5], THREE[W3])) {
            S6[J5][p4] = Math[R3](S6[P3], Math[u4](S6[r4], F1w7G[M](S6[J5][p4], D)));
            S6[J5][G3]();
            E9 = I4;
        } else {
            console[F1w7G.Y6x](v4);
            S6[F1w7G.t2C] = h5;
        }
    }
    function i1(D) {
        var M = "c0G", H = "b8G", V = "S8G";
        k4[E4](D[m4][d5][g7], D[m4][d5][B7]);
        u9[v7](k4, m7);
        var o = F1w7G[V](S6[Y3], document) ? S6[Y3][r7] : S6[Y3];
        L9(F1w7G[H](D3, Math[y4], u9[i4], o[c7], S6[P4]));
        V7(F1w7G[M](D3, Math[y4], u9[S4], o[s7], S6[P4]));
        m7[g3](k4);
        S6[q5]();
    }
    function h7(D) {
        var M = "D8G", H = "q1G", V = "m1G";
        k4[E4](D[b4], D[q3]);
        u9[v7](k4, m7);
        var o = F1w7G[V](S6[Y3], document) ? S6[Y3][r7] : S6[Y3];
        L9(F1w7G[H](D3, Math[y4], u9[i4], o[c7], S6[P4]));
        V7(F1w7G[M](D3, Math[y4], u9[S4], o[s7], S6[P4]));
        m7[g3](k4);
        S6[q5]();
    }
    function F7(D) {
        T7[E4](D[m4][d5][g7], D[m4][d5][B7]);
        t5[v7](T7, Y7);
        d7(t5[i4], t5[S4]);
        Y7[g3](T7);
        S6[q5]();
    }
    function m9(D) {
    }
    function O7(D) {
        var M = "G2G";
        if (F1w7G[M](S6[s4], h5))return;
        j7(D);
        document[K5](d3, W7, h5);
        document[K5](V4, O7, h5);
        document[K5](U3, O7, h5);
        S6[n3](e9);
        z3 = f3[f4];
    }
    function L9(D) {
        o7[q4] -= D;
    }
    function D9(D) {
        var M = "X8G", H = "l8G", V = "t8G", o = "s8G", Q = F1w7G[o](D[m4][d5][g7], D[m4][F4][g7]),
            i = F1w7G[V](D[m4][d5][B7], D[m4][F4][B7]), k = Math[M7](F1w7G[H](Q, Q) + F1w7G[M](i, i));
        N4[E4](d5, k);
    }
    function V7(D) {
        o7[l4] -= D;
    }
    function J3(D) {
        var M = "BOTTOM", H = "UP", V = "keyCode";
        switch (D[V]) {
            case S6[L4][H]:
                d7(d5, S6[L5]);
                S6[q5]();
                break;
            case S6[L4][M]:
                d7(d5, -S6[L5]);
                S6[q5]();
                break;
            case S6[L4][h3]:
                d7(S6[L5], d5);
                S6[q5]();
                break;
            case S6[L4][L3]:
                d7(-S6[L5], d5);
                S6[q5]();
                break;
        }
    }
    function I7(D) {
        var M = "N8G", H = "r8G", V = "detail", o = "F8G", Q = "wheelDelta", i = "I8G", k = d5;
        if (F1w7G[i](D[Q], undefined)) {
            k = D[Q];
        } else if (F1w7G[o](D[V], undefined)) {
            k = -D[V];
        }
        if (F1w7G[H](k, d5)) {
            Q9(n7());
        } else if (F1w7G[M](k, d5)) {
            k9(n7());
        }
        S6[q5]();
    }
    function q7(D) {
        m7[E4](D[b4], D[q3]);
    }
    function I9() {
        var D = 60, M = "K9G";
        return F1w7G[M](D3, Math[y4], D, D, S6[d4]);
    }
    function W7(D) {
        var M = "L2G", H = "U2G", V = "x2G", o = "E2G", Q = "C2G", i = "P2G", k = "A2G";
        if (F1w7G[k](S6[s4], h5))return;
        D[w3]();
        if (F1w7G[i](z3, f3[t4])) {
            if (F1w7G[Q](S6[F1w7G.h1C], h5))return;
            h7(D);
        } else if (F1w7G[o](z3, f3[e4])) {
            if (F1w7G[V](S6[F1w7G.t2C], h5))return;
            X9(D);
        } else if (F1w7G[H](z3, f3[l5])) {
            if (F1w7G[M](S6[F1w7G.D5x], h5))return;
            C9(D);
        }
    }
    function n7() {
        var D = 0.95, M = "pow";
        return Math[M](D, S6[U4]);
    }
    function S9(D) {
        m7[E4](D[m4][d5][g7], D[m4][d5][B7]);
    }
    function R7(D) {
        Y7[E4](D[b4], D[q3]);
    }
    function C9(D) {
        T7[E4](D[b4], D[q3]);
        t5[v7](T7, Y7);
        d7(t5[i4], t5[S4]);
        Y7[g3](T7);
        S6[q5]();
    }
    function H9(D) {
        var M = "e2G", H = "f2G", V = "y2G", o = "z2G";
        if (F1w7G[o](S6[s4], h5) || F1w7G[V](S6[F1w7G.t2C], h5) || (F1w7G[H](z3, f3[f4]) && F1w7G[M](z3, f3[t4])))return;
        D[w3]();
        D[H4]();
        I7(D);
        S6[n3](g1);
        S6[n3](e9);
    }
    function p7(D) {
        var M = "N6v";
        if (F1w7G[M](S6[s4], h5))return;
        m9(D);
        S6[n3](e9);
        z3 = f3[f4];
    }
    function Q9(D) {
        var M = "v1G", H = "e1G", V = "f1G";
        if (F1w7G[V](S6[J5], THREE[Q4])) {
            Z7 *= D;
        } else if (F1w7G[H](S6[J5], THREE[W3])) {
            S6[J5][p4] = Math[R3](S6[P3], Math[u4](S6[r4], F1w7G[M](S6[J5][p4], D)));
            S6[J5][G3]();
            E9 = I4;
        } else {
            console[F1w7G.Y6x](v4);
            S6[F1w7G.t2C] = h5;
        }
    }
    function y9(D) {
        N4[E4](D[b4], D[q3]);
    }
    function q9(D) {
        var M = "q2G", H = "m2G", V = "v2G";
        if (F1w7G[V](S6[s4], h5) || F1w7G[H](S6[F1w7G.r5x], h5) || F1w7G[M](S6[F1w7G.D5x], h5))return;
        J3(D);
    }
    function N9(D) {
        var M = "r6v", H = "F6v", V = "I6v", o = "O6v", Q = "k6v", i = "i6v", k = "Q6v";
        if (F1w7G[k](S6[s4], h5))return;
        D[w3]();
        D[H4]();
        switch (D[m4].length) {
            case F4:
                if (F1w7G[i](S6[F1w7G.h1C], h5))return;
                if (F1w7G[Q](z3, f3[D7]))return;
                i1(D);
                break;
            case D3:
                if (F1w7G[o](S6[F1w7G.t2C], h5))return;
                if (F1w7G[V](z3, f3[Q7]))return;
                t9(D);
                break;
            case m3:
                if (F1w7G[H](S6[F1w7G.D5x], h5))return;
                if (F1w7G[M](z3, f3[J7]))return;
                F7(D);
                break;
            default:
                z3 = f3[f4];
        }
    }
    function Z1() {
        var D = "Mesh", M = "MeshLambertMaterial", H = "BoxBufferGeometry", V = new THREE[H](c3, c3, c3),
            o = new THREE[M]({color: 0xff3300, depthWrite: h5, depthTest: h5}), Q = new THREE[D](V, o);
        Q[b5][E4](d5, d5, d5);
        c6[y3](Q);
        S6[a5] = Q;
    }
    function j7(D) {
        var M = "O8G", H = "getTime", V = "k8G", o = "i8G", Q = "Q8G";
        if (F1w7G[Q](D[N7], F4) && F1w7G[o](O9, Z3) && C6) {
            var i = new Date(), k = F1w7G[V](i[H](), O9[H]());
            if (F1w7G[M](k, c3)) {
                C6(D, k);
            }
        }
    }
    this[J5] = R;
    this[Y3] = (F1w7G[v3](P6, undefined)) ? P6 : document;
    this[s4] = I4;
    this[F1w7G.M0C] = new THREE[H3]();
    this[A4] = d5;
    this[T3] = Infinity;
    this[P3] = d5;
    this[r4] = Infinity;
    this[K3] = d5;
    this[E3] = Math[y4];
    this[S5] = -Infinity;
    this[B3] = Infinity;
    this[F1w7G.s6x] = h5;
    this[F1w7G.k8C] = j3;
    this[F1w7G.t2C] = I4;
    this[U4] = x3;
    this[F1w7G.h1C] = I4;
    this[P4] = x3;
    this[F1w7G.D5x] = I4;
    this[L5] = R5;
    this[o3] = h5;
    this[d4] = C3;
    this[F1w7G.r5x] = I4;
    this[L4] = {LEFT: A3, UP: f5, RIGHT: X5, BOTTOM: w5};
    this[x4] = {ORBIT: THREE[G5][h3], ZOOM: THREE[G5][M3], PAN: THREE[G5][L3]};
    this[Y5] = this[F1w7G.M0C][T5]();
    this[e5] = this[J5][b5][T5]();
    this[m5] = this[J5][p4];
    var O9 = Z3, D4 = new THREE[H3](), s9 = new THREE[j5]();
    this[a5] = Z3;
    this[z5] = h5;
    this[v5] = h5;
    this[g5] = function () {
        return phi;
    };
    this[b6] = function () {
        return theta;
    };
    this[Z5] = function (D, M) {
        var H = new THREE[H3]()[g3](M), V = new THREE[H3]()[g3](D);
        S6[J5][b5][g3](V);
        S6[J5][x5](H);
        S6[F1w7G.M0C][g3](H);
        D4[g3](V);
    };
    this[W6] = function (k, U, O) {
        var I = 2000, L = 'flyFromTo', G = new THREE[H3]()[g3](U), F = new THREE[H3]()[g3](k),
            T = new THREE[H3]()[g3](G)[X6](S6[F1w7G.M0C]), J = new THREE[H3]()[g3](F)[X6](S6[J5][b5]),
            N = new THREE[H3]()[g3](S6[J5][b5]), K = new THREE[H3]()[g3](S6[F1w7G.M0C]), W = {t: d5};
        k6[E5](L);
        var S = new TWEEN[B5](W)[U5]({t: F4}, I)[o5](TWEEN[C5][M5][P5])[c5](function () {
            var D = "Z9G", M = "Y9G", H = "o9G", V = "g9G", o = "c9G", Q = "t", i = "M9G";
            S6[J5][b5][i4] = N[i4] + F1w7G[i](J[i4], W[Q]);
            S6[J5][b5][S4] = N[S4] + F1w7G[o](J[S4], W[Q]);
            S6[J5][b5][l6] = N[l6] + F1w7G[V](J[l6], W[Q]);
            S6[F1w7G.M0C][i4] = K[i4] + F1w7G[H](T[i4], W[Q]);
            S6[F1w7G.M0C][S4] = K[S4] + F1w7G[M](T[S4], W[Q]);
            S6[F1w7G.M0C][l6] = K[l6] + F1w7G[D](T[l6], W[Q]);
            S6[J5][x5](S6[F1w7G.M0C]);
        })[I6](function () {
            D4[g3](S6[J5][b5]);
            S6[v5] = h5;
            if (O) {
                O();
            }
            k6[u5](L);
        })[A5]();
        S6[v5] = I4;
    };
    this[t6] = function (D, M, H) {
        var V = 1000, o = 'flyViewPoint', Q = new THREE[H3](), i = new THREE[H3](d5, d5, F4),
            k = S6[F1w7G.M0C][T5]()[X6](D4).length();
        Q[g3](i)[J6](S6[J5][N6]);
        Q = Q[K6](k);
        var U = new THREE[H3]()[g3](D)[y3](M), O = new THREE[H3]()[g3](U)[y3](Q);
        k6[E5](o);
        var I = new TWEEN[B5](S6[J5][b5])[U5]({
            x: O[i4],
            y: O[S4],
            z: O[l6],
        }, V)[o5](TWEEN[C5][M5][P5])[c5](function () {
        })[I6](function () {
            D4[g3](S6[J5][b5]);
            S6[F1w7G.M0C][g3](U);
            S6[J5][x5](S6[F1w7G.M0C]);
            S6[v5] = h5;
            k6[u5](o);
        })[A5]();
        S6[v5] = I4;
    };
    this[w6] = function () {
        if (S6[v5])return;
        var D = new THREE[H3](), M = new THREE[H3](d5, d5, -F4);
        D[g3](M)[J6](S6[J5][N6]);
        var H = S6[F1w7G.M0C][T5]()[X6](D4).length();
        D = D[K6](H);
        S6[F1w7G.M0C][g3](S6[J5][b5])[y3](D);
        D4[g3](S6[J5][b5]);
    };
    this[R6] = function () {
        S6[F1w7G.M0C][g3](S6[Y5]);
        S6[J5][b5][g3](S6[e5]);
        S6[J5][p4] = S6[m5];
        S6[J5][G3]();
        S6[n3](H1);
        S6[q5]();
        z3 = f3[f4];
    };
    this[q5] = function () {
        var N = "inverse", K = "up", W = "setFromUnitVectors", S = new THREE[H3](),
            M6 = new THREE[j5]()[W](R[K], new THREE[H3](d5, F4, d5)), u6 = M6[T5]()[N]();
        return function () {
            var D = 'mouse orbit', M = "requestOneUpdate", H = "dot", V = 8, o = "a9G", Q = "distanceToSquared",
                i = "J9G", k = "T9G", U = "n9G", O = "j9G", I = "setFromSpherical", L = "radius", G = "makeSafe",
                F = "B9G", T = "setFromVector3";
            if (S6[v5])return;
            var J = S6[J5][b5];
            S[g3](J)[X6](S6[F1w7G.M0C]);
            S[J6](M6);
            i7[T](S);
            if (S6[o3] && F1w7G[F](z3, f3[f4])) {
                L9(I9());
            }
            i7[q4] += o7[q4];
            i7[l4] += o7[l4];
            i7[q4] = Math[R3](S6[S5], Math[u4](S6[B3], i7[q4]));
            i7[l4] = Math[R3](S6[K3], Math[u4](S6[E3], i7[l4]));
            i7[G]();
            i7[L] *= Z7;
            i7[L] = Math[R3](S6[A4], Math[u4](S6[T3], i7[L]));
            S6[F1w7G.M0C][y3](z4);
            S[I](i7);
            S[J6](u6);
            J[g3](S6[F1w7G.M0C])[y3](S);
            S6[J5][x5](S6[F1w7G.M0C]);
            if (F1w7G[O](S6[F1w7G.s6x], I4)) {
                o7[q4] *= (F1w7G[U](F4, S6[F1w7G.k8C]));
                o7[l4] *= (F1w7G[k](F4, S6[F1w7G.k8C]));
            } else {
                o7[E4](d5, d5, d5);
            }
            Z7 = F4;
            z4[E4](d5, d5, d5);
            if (E9 || F1w7G[i](D4[Q](S6[J5][b5]), f7) || F1w7G[o](V * (F4 - s9[H](S6[J5][N6])), f7)) {
                S6[n3](H1);
                D4[g3](S6[J5][b5]);
                s9[g3](S6[J5][N6]);
                E9 = h5;
                S6[z5] = I4;
                k6[M](D);
                return I4;
            }
            S6[z5] = h5;
            return h5;
        };
    }();
    this[h6] = function () {
        S6[Y3][K5](s6, c1, h5);
        S6[Y3][K5](z6, e7, h5);
        S6[Y3][K5](r6, H9, h5);
        S6[Y3][K5](G6, H9, h5);
        S6[Y3][K5](a6, r9, h5);
        S6[Y3][K5](n6, p7, h5);
        S6[Y3][K5](T6, N9, h5);
        document[K5](d3, W7, h5);
        document[K5](V4, O7, h5);
        document[K5](U3, O7, h5);
    };
    var S6 = this, H1 = {type: U6}, g1 = {type: g6}, e9 = {type: j6},
        f3 = {NONE: -F4, ROTATE: d5, DOLLY: F4, PAN: D3, TOUCH_ROTATE: m3, TOUCH_DOLLY: x6, TOUCH_PAN: O6}, z3 = f3[f4],
        f7 = B6, i7 = new THREE[Z6](), o7 = new THREE[Z6](), Z7 = F4, z4 = new THREE[H3](), E9 = h5,
        m7 = new THREE[Y6](), k4 = new THREE[Y6](), u9 = new THREE[Y6](), Y7 = new THREE[Y6](), T7 = new THREE[Y6](),
        t5 = new THREE[Y6](), N4 = new THREE[Y6](), f9 = new THREE[Y6](), G9 = new THREE[Y6](), D1 = function () {
            var H = new THREE[H3]();
            return function V(D, M) {
                H[o6](M, d5);
                H[K6](-D);
                z4[y3](H);
            };
        }(), b9 = function () {
            var H = new THREE[H3]();
            return function V(D, M) {
                H[o6](M, F4);
                H[K6](D);
                z4[y3](H);
            };
        }(), k1 = function () {
            var H = new THREE[H3]();
            return function V(D, M) {
                H[o6](M, D3);
                H[K6](D);
                z4[y3](H);
            };
        }(), d7 = function () {
            var u6 = new THREE[H3]();
            return function (D, M) {
                var H = 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.', V = "bottom",
                    o = "B1G", Q = "left", i = "right", k = "i1G", U = "Q1G", O = "P1G", I = "matrix", L = "M1G", G = 180.0,
                    F = "fov", T = "w9G", J = "tan", N = "W9G", K = "h9G",
                    W = F1w7G[K](S6[Y3], document) ? S6[Y3][r7] : S6[Y3];
                if (F1w7G[N](S6[J5], THREE[Q4])) {
                    var S = S6[J5][b5];
                    u6[g3](S)[X6](S6[F1w7G.M0C]);
                    var M6 = u6.length();
                    M6 *= Math[J](F1w7G[T]((S6[J5][F] / D3), Math[y4], G));
                    D1(F1w7G[L](D3, D, M6, W[s7]), S6[J5][I]);
                    b9(F1w7G[O](D3, M, M6, W[s7]), S6[J5][I]);
                } else if (F1w7G[U](S6[J5], THREE[W3])) {
                    D1(F1w7G[k](D, (S6[J5][i] - S6[J5][Q]), S6[J5][p4], W[c7]), S6[J5][I]);
                    b9(F1w7G[o](M, (S6.object.top - S6[J5][V]), S6[J5][p4], W[s7]), S6[J5][I]);
                } else {
                    console[F1w7G.Y6x](H);
                    S6[F1w7G.D5x] = h5;
                }
            };
        }();
    S6[Y3][H7](s6, c1, h5);
    S6[Y3][H7](z6, e7, h5);
    S6[Y3][H7](r6, H9, h5);
    S6[Y3][H7](G6, H9, h5);
    S6[Y3][H7](a6, r9, h5);
    S6[Y3][H7](n6, p7, h5);
    S6[Y3][H7](T6, N9, h5);
    this[q5]();
};
THREE.OrbitControls.prototype = Object[F1w7G.n1C](THREE.EventDispatcher.prototype);
THREE.OrbitControls.prototype.constructor = THREE[F1w7G.z1C];
Object[F1w7G.j2C](THREE.OrbitControls.prototype, {
    center: {
        get: function () {
            var D = 'THREE.OrbitControls: .center has been renamed to .target';
            console[F1w7G.Y6x](D);
            return this[F1w7G.M0C];
        }
    }, noZoom: {
        get: function () {
            console[F1w7G.Y6x](F1w7G.q1C);
            return !this[F1w7G.t2C];
        }, set: function (D) {
            console[F1w7G.Y6x](F1w7G.q1C);
            this[F1w7G.t2C] = !D;
        }
    }, noRotate: {
        get: function () {
            console[F1w7G.Y6x](F1w7G.r6x);
            return !this[F1w7G.h1C];
        }, set: function (D) {
            console[F1w7G.Y6x](F1w7G.r6x);
            this[F1w7G.h1C] = !D;
        }
    }, noPan: {
        get: function () {
            console[F1w7G.Y6x](F1w7G.p8C);
            return !this[F1w7G.D5x];
        }, set: function (D) {
            console[F1w7G.Y6x](F1w7G.p8C);
            this[F1w7G.D5x] = !D;
        }
    }, noKeys: {
        get: function () {
            console[F1w7G.Y6x](F1w7G.m6x);
            return !this[F1w7G.r5x];
        }, set: function (D) {
            console[F1w7G.Y6x](F1w7G.m6x);
            this[F1w7G.r5x] = !D;
        }
    }, staticMoving: {
        get: function () {
            console[F1w7G.Y6x](F1w7G.Y5x);
            return !this[F1w7G.a0C][F1w7G.s6x];
        }, set: function (D) {
            console[F1w7G.Y6x](F1w7G.Y5x);
            this[F1w7G.a0C][F1w7G.s6x] = !D;
        }
    }, dynamicDampingFactor: {
        get: function () {
            console[F1w7G.Y6x](F1w7G.J0C);
            return this[F1w7G.a0C][F1w7G.k8C];
        }, set: function (D) {
            console[F1w7G.Y6x](F1w7G.J0C);
            this[F1w7G.a0C][F1w7G.k8C] = D;
        }
    }
});
var F0D = {
    'e': function (D, M) {
        return D != M;
    }, 'n': function (D, M) {
        return D * M;
    }, 'D6': function (D, M) {
        return D * M;
    }, 'r': function (D, M) {
        return D != M;
    }, 'u': function (D, M) {
        return D !== M;
    }, 'p6': function (D, M) {
        return D * M;
    }, 'v': function (D, M) {
        return D != M;
    }, 'E': function (D, M) {
        return D / M;
    }, 'i6': function (D, M) {
        return D != M;
    }, 'u0x': (function (V0x) {
        return (function (x0x, Y0x) {
            return (function (Z0x) {
                return {M0x: Z0x, U0x: Z0x,};
            })(function (A0x) {
                var Q0x, c0x = 0;
                for (var i0x = x0x; c0x < A0x["length"]; c0x++) {
                    var E0x = Y0x(A0x, c0x);
                    Q0x = c0x === 0 ? E0x : Q0x ^ E0x;
                }
                return Q0x ? i0x : !i0x;
            });
        })((function (C0x, P0x, H0x, o0x) {
            var g0x = 34;
            return C0x(V0x, g0x) - o0x(P0x, H0x) > g0x;
        })(parseInt, Date, (function (P0x) {
            return ('' + P0x)["substring"](1, (P0x + '')["length"] - 1);
        })('_getTime2'), function (P0x, H0x) {
            return new P0x()[H0x]();
        }), function (A0x, c0x) {
            var p0x = parseInt(A0x["charAt"](c0x), 16)["toString"](2);
            return p0x["charAt"](p0x["length"] - 1);
        });
    })('41jxohw4g'), 'V6': function (D, M) {
        return D * M;
    }, 'j': function (D, M) {
        return D * M;
    }, 'C': function (D, M) {
        return D / M;
    }, 'm': function (D, M) {
        return D != M;
    }, 'D0v': "KeyControls", 'f': function (D, M) {
        return D != M;
    }, 'H6': function (D, M) {
        return D * M;
    }, 'Q6': function (D, M) {
        return D * M;
    }, 'B': function (D, M) {
        return D / M;
    }, 'A': function (D, M) {
        return D !== M;
    }, 'P': function (D, M) {
        return D > M;
    }, 'q': function (D, M) {
        return D != M;
    }, 'd': function (D, M) {
        return D * M;
    }, 'Z': function (D, M) {
        return D - M;
    }
};
F0D.i2x = function (e) {
    while (e)return F0D.u0x.U0x(e);
};
F0D.Y2x = function (e) {
    for (; F0D;)return F0D.u0x.U0x(e);
};
F0D.o2x = function (b) {
    if (F0D && b)return F0D.u0x.U0x(b);
};
F0D.V2x = function (j) {
    if (F0D && j)return F0D.u0x.U0x(j);
};
F0D.g2x = function (b) {
    if (F0D && b)return F0D.u0x.U0x(b);
};
F0D.H2x = function (c) {
    if (F0D && c)return F0D.u0x.U0x(c);
};
F0D.c2x = function (n) {
    for (; F0D;)return F0D.u0x.M0x(n);
};
F0D.A2x = function (b) {
    if (F0D && b)return F0D.u0x.U0x(b);
};
F0D.p2x = function (k) {
    while (k)return F0D.u0x.U0x(k);
};
F0D.M2x = function (n) {
    for (; F0D;)return F0D.u0x.U0x(n);
};
F0D.D2x = function (i) {
    while (i)return F0D.u0x.M0x(i);
};
F0D.w0x = function (m) {
    if (F0D && m)return F0D.u0x.U0x(m);
};
F0D.d0x = function (i) {
    for (; F0D;)return F0D.u0x.M0x(i);
};
F0D.S0x = function (b) {
    if (F0D && b)return F0D.u0x.U0x(b);
};
F0D.W0x = function (g) {
    while (g)return F0D.u0x.U0x(g);
};
F0D.q0x = function (f) {
    for (; F0D;)return F0D.u0x.M0x(f);
};
F0D.m0x = function (l) {
    for (; F0D;)return F0D.u0x.U0x(l);
};
F0D.R0x = function (a) {
    while (a)return F0D.u0x.M0x(a);
};
F0D.v0x = function (d) {
    if (F0D && d)return F0D.u0x.M0x(d);
};
F0D.t0x = function (n) {
    for (; F0D;)return F0D.u0x.M0x(n);
};
F0D.K0x = function (f) {
    while (f)return F0D.u0x.U0x(f);
};
F0D.s0x = function (a) {
    for (; F0D;)return F0D.u0x.M0x(a);
};
F0D.f0x = function (j) {
    while (j)return F0D.u0x.M0x(j);
};
F0D.J0x = function (k) {
    for (; F0D;)return F0D.u0x.U0x(k);
};
F0D.y0x = function (h) {
    while (h)return F0D.u0x.U0x(h);
};
F0D.r0x = function (l) {
    while (l)return F0D.u0x.U0x(l);
};
F0D.T0x = function (d) {
    while (d)return F0D.u0x.U0x(d);
};
F0D.z0x = function (b) {
    if (F0D && b)return F0D.u0x.U0x(b);
};
F0D.F0x = function (a) {
    if (F0D && a)return F0D.u0x.U0x(a);
};
F0D.n0x = function (n) {
    if (F0D && n)return F0D.u0x.U0x(n);
};
F0D.I0x = function (h) {
    if (F0D && h)return F0D.u0x.M0x(h);
};
F0D.j0x = function (h) {
    for (; F0D;)return F0D.u0x.M0x(h);
};
F0D.L0x = function (n) {
    if (F0D && n)return F0D.u0x.M0x(n);
};
F0D.O0x = function (d) {
    while (d)return F0D.u0x.M0x(d);
};
F0D.B0x = function (h) {
    while (h)return F0D.u0x.M0x(h);
};
THREE[F0D.D0v] = F0D.B0x("e5") ? function (S, p3, u3) {
    F0D.E2x = function (f) {
        if (F0D && f)return F0D.u0x.M0x(f);
    };
    F0D.Q2x = function (d) {
        for (; F0D;)return F0D.u0x.U0x(d);
    };
    F0D.C2x = function (e) {
        if (F0D && e)return F0D.u0x.M0x(e);
    };
    F0D.P2x = function (g) {
        for (; F0D;)return F0D.u0x.U0x(g);
    };
    F0D.u2x = function (l) {
        if (F0D && l)return F0D.u0x.U0x(l);
    };
    F0D.b0x = function (b) {
        for (; F0D;)return F0D.u0x.M0x(b);
    };
    F0D.X0x = function (k) {
        if (F0D && k)return F0D.u0x.U0x(k);
    };
    F0D.h0x = function (j) {
        if (F0D && j)return F0D.u0x.M0x(j);
    };
    F0D.l0x = function (n) {
        if (F0D && n)return F0D.u0x.U0x(n);
    };
    F0D.e0x = function (l) {
        if (F0D && l)return F0D.u0x.M0x(l);
    };
    F0D.a0x = function (a) {
        while (a)return F0D.u0x.U0x(a);
    };
    F0D.N0x = function (n) {
        if (F0D && n)return F0D.u0x.U0x(n);
    };
    F0D.G0x = function (g) {
        if (F0D && g)return F0D.u0x.M0x(g);
    };
    var M6 = F0D.O0x("dc") ? "addEventListener" : "setOptional", u6 = F0D.L0x("5d64") ? 'mapBumpScale' : 'keyup',
        R = F0D.j0x("788") ? 'keydown' : 'uniform vec3 color;', a3 = F0D.I0x("38") ? "dispose" : "keyPath",
        z9 = F0D.G0x("1d7") ? "z" : "setXY", P6 = F0D.n0x("4d1") ? "radius2" : "y",
        c6 = F0D.F0x("17cd") ? "x" : "MAX_EXT", C6 = F0D.z0x("f6") ? "update" : "i", k6 = "mouseup",
        o6 = "getContainerDimensions", Y6 = F0D.D2x("31b") ? "mousemove" : "Array",
        Z6 = F0D.T0x("b7") ? "if ( renderType == 2 ) {" : 2, B6 = F0D.r0x("2b4d") ? "IfcFlowFitting" : "button",
        O6 = F0D.y0x("fbe") ? "indexStart" : "stopPropagation", x6 = F0D.u2x("a23") ? "mousedown" : "FaceColors",
        j6 = "keyup", g6 = F0D.J0x("45") ? "clearState" : "sort",
        U6 = F0D.Y2x("124") ? "updateRotationVector" : "getMaxAnisotropy",
        T6 = F0D.M2x("1f") ? "HIGH_FLOAT" : "updateMovementVector", n6 = F0D.N0x("fdb") ? "rollRight" : "DataLoader",
        a6 = F0D.i2x("4b") ? 69 : "uniform vec3 color;", G6 = "rollLeft", r6 = 81,
        z6 = F0D.f0x("af7") ? "localThresholdSq" : "yawRight", s6 = F0D.a0x("ef7b") ? 39 : "All Node Count:",
        h6 = F0D.s0x("d81d") ? "yawLeft" : "errorThrown", R6 = F0D.e0x("e2") ? 1000 : 37,
        w6 = F0D.K0x("cc51") ? "alpha2" : "pitchDown", K6 = 40, N6 = "pitchUp",
        p0 = F0D.t0x("5f") ? "IFCWALLSTANDARDCASE" : 38, J6 = F0D.v0x("dbaf") ? "down" : "GRAPH_WIDTH",
        t6 = F0D.p2x("78") ? 70 : 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.',
        k8 = "up", A5 = 82, u5 = F0D.R0x("a5") ? "right" : "JSON", H0 = 68,
        I6 = F0D.A2x("3f18") ? "left" : "parameter_src",
        l6 = F0D.c2x("be") ? 65 : 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
        a1 = F0D.l0x("36") ? "back" : "b2p2", c5 = F0D.H2x("72c") ? 83 : "uniform float mieDirectionalG;",
        P5 = "forward", c0 = 87, M5 = F0D.m0x("1f3c") ? true : "ax",
        C5 = F0D.h0x("bd31") ? "AnimationUtils" : "movementSpeedMultiplier",
        g0 = F0D.P2x("12da") ? 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' : 16,
        o5 = F0D.g2x("fc5") ? "StringKeyframeTrack" : "keyCode", U5 = "keydown", I0 = "handleEvent",
        B5 = "rotationVector", E5 = "Vector3", p1 = F0D.X0x("7f") ? "buffer" : "moveVector",
        X6 = F0D.q0x("836") ? "moveState" : "maxInstancedCount", W6 = 0,
        U8 = F0D.V2x("b4e") ? "mouseStatus" : "_vector3", x5 = "Quaternion",
        Z5 = F0D.C2x("a5e") ? "tmpQuaternion" : "customDepthMaterial", V0 = "autoForward", b6 = false,
        g5 = F0D.W0x("c6e") ? "object" : "dragToLook",
        F0 = F0D.S0x("bac6") ? 0.005 : 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',
        v5 = "rollSpeed", z5 = F0D.o2x("65f") ? "//nightsky" : 10000.0,
        o0 = F0D.d0x("58") ? "movementSpeed" : "extractFromCache",
        j5 = F0D.w0x("ead") ? 1 : 'THREE.BufferAttribute: .length has been deprecated. Please use .count.',
        m5 = F0D.Q2x("6a31") ? 'blue' : 'tabindex', n0 = "setAttribute",
        e5 = F0D.E2x("54de") ? "saveOriginalState" : "u", T5 = F0D.b0x("6631") ? "TriangleFanDrawMode" : "domElement",
        j1 = "object", Y5 = "preventDefault";
    function M3(M, E6) {
        return function () {
            var D = "apply";
            E6[D](M, arguments);
        };
    }
    function t0(D) {
        D[Y5]();
    }
    this[j1] = S;
    this[T5] = (F0D[e5](p3, undefined)) ? p3 : document;
    if (p3) this[T5][n0](m5, -j5);
    this[o0] = z5;
    this[v5] = F0;
    this[g5] = b6;
    this[V0] = b6;
    this[Z5] = new THREE[x5]();
    this[U8] = W6;
    this[X6] = {
        up: W6,
        down: W6,
        left: W6,
        right: W6,
        forward: W6,
        back: W6,
        pitchUp: W6,
        pitchDown: W6,
        yawLeft: W6,
        yawRight: W6,
        rollLeft: W6,
        rollRight: W6
    };
    this[p1] = new THREE[E5](W6, W6, W6);
    this[B5] = new THREE[E5](W6, W6, W6);
    this[I0] = function (D) {
        var M = 'function', E6 = "type";
        if (typeof this[D[E6]] == M) {
            this[D[E6]](D);
        }
    };
    this[U5] = function (D) {
        var M = 'key control', E6 = "requestOneUpdate", L6 = "exitSelection", H = 27, e3 = .1, V = "altKey";
        if (D[V]) {
            return;
        }
        var o = b6;
        switch (D[o5]) {
            case g0:
                this[C5] = e3;
                o = M5;
                break;
            case c0:
                this[X6][P5] = j5;
                o = M5;
                break;
            case c5:
                this[X6][a1] = j5;
                o = M5;
                break;
            case l6:
                this[X6][I6] = j5;
                o = M5;
                break;
            case H0:
                this[X6][u5] = j5;
                o = M5;
                break;
            case A5:
                this[X6][k8] = j5;
                o = M5;
                break;
            case t6:
                this[X6][J6] = j5;
                o = M5;
                break;
            case p0:
                this[X6][N6] = j5;
                o = M5;
                break;
            case K6:
                this[X6][w6] = j5;
                o = M5;
                break;
            case R6:
                this[X6][h6] = j5;
                o = M5;
                break;
            case s6:
                this[X6][z6] = j5;
                o = M5;
                break;
            case r6:
                this[X6][G6] = j5;
                o = M5;
                break;
            case a6:
                this[X6][n6] = j5;
                o = M5;
                break;
            case H:
                u3[L6]();
                break;
        }
        if (o) {
            u3[E6](M);
        }
        this[T6]();
        this[U6]();
    };
    this[g6] = function () {
        this[X6][P5] = W6;
        this[X6][a1] = W6;
        this[X6][I6] = W6;
        this[X6][u5] = W6;
        this[X6][k8] = W6;
        this[X6][J6] = W6;
        this[X6][N6] = W6;
        this[X6][w6] = W6;
        this[X6][h6] = W6;
        this[X6][z6] = W6;
        this[X6][G6] = W6;
        this[X6][n6] = W6;
        this[T6]();
        this[U6]();
    };
    this[j6] = function (D) {
        switch (D[o5]) {
            case g0:
                this[C5] = j5;
                break;
            case c0:
                this[X6][P5] = W6;
                break;
            case c5:
                this[X6][a1] = W6;
                break;
            case l6:
                this[X6][I6] = W6;
                break;
            case H0:
                this[X6][u5] = W6;
                break;
            case A5:
                this[X6][k8] = W6;
                break;
            case t6:
                this[X6][J6] = W6;
                break;
            case p0:
                this[X6][N6] = W6;
                break;
            case K6:
                this[X6][w6] = W6;
                break;
            case R6:
                this[X6][h6] = W6;
                break;
            case s6:
                this[X6][z6] = W6;
                break;
            case r6:
                this[X6][G6] = W6;
                break;
            case a6:
                this[X6][n6] = W6;
                break;
        }
        this[T6]();
        this[U6]();
    };
    this[x6] = function (D) {
        var M = "focus", E6 = "A";
        if (F0D[E6](this[T5], document)) {
            this[T5][M]();
        }
        D[Y5]();
        D[O6]();
        if (this[g5]) {
            this[U8]++;
        } else {
            switch (D[B6]) {
                case W6:
                    this[X6][P5] = j5;
                    break;
                case Z6:
                    this[X6][a1] = j5;
                    break;
            }
            this[T6]();
        }
    };
    this[Y6] = function (D) {
        var M = "pageY", E6 = "B", L6 = "offset", H = "pageX", e3 = "Z", V = "E", o = "size", Q = "C", i = "P";
        if (!this[g5] || F0D[i](this[U8], W6)) {
            var k = this[o6](), G4 = F0D[Q](k[o][W6], Z6), U = F0D[V](k[o][j5], Z6);
            this[X6][h6] = -(F0D[e3]((D[H] - k[L6][W6]), G4)) / G4;
            this[X6][w6] = F0D[E6](((D[M] - k[L6][j5]) - U), U);
            this[U6]();
        }
    };
    this[k6] = function (D) {
        D[Y5]();
        D[O6]();
        if (this[g5]) {
            this[U8]--;
            this[X6][h6] = this[X6][w6] = W6;
        } else {
            switch (D[B6]) {
                case W6:
                    this[X6][P5] = W6;
                    break;
                case Z6:
                    this[X6][a1] = W6;
                    break;
            }
            this[T6]();
        }
        this[U6]();
    };
    this[C6] = function (D) {
        var M = "order", E6 = "setFromQuaternion", L6 = "rotation", H = "multiply", e3 = "quaternion", V = "normalize",
            o = "Q6", Q = "V6", i = "H6", k = "set", G4 = "p6", U = "translateZ", O = "D6", I = "translateY", L = "d",
            G = "translateX", F = "q", T = "m", y5 = "v", J = "e", n5 = "f", N = "r", K = "n", N1 = "j",
            V3 = F0D[N1](D, this[o0]), W = F0D[K](D, this[v5]), A6 = b6;
        if (F0D[N](this[B5][c6], W6) || F0D[n5](this[B5][P6], W6) || F0D[J](this[B5][z9], W6) || F0D[y5](this[p1][c6], W6) || F0D[T](this[p1][P6], W6) || F0D[F](this[p1][z9], W6)) {
            A6 = M5;
        }
        this[j1][G](F0D[L](this[p1][c6], V3));
        this[j1][I](F0D[O](this[p1][P6], V3));
        this[j1][U](F0D[G4](this[p1][z9], V3));
        this[Z5][k](F0D[i](this[B5][c6], W), F0D[Q](this[B5][P6], W), F0D[o](this[B5][z9], W), j5)[V]();
        this[j1][e3][H](this[Z5]);
        this[j1][L6][E6](this[j1][e3], this[j1][L6][M]);
        this[g6]();
        return A6;
    };
    this[T6] = function () {
        var D = (this[X6][P5] || (this[V0] && !this[X6][a1])) ? j5 : W6;
        this[p1][c6] = (-this[X6][I6] + this[X6][u5]);
        this[p1][P6] = (-this[X6][J6] + this[X6][k8]);
        this[p1][z9] = (-D + this[X6][a1]);
    };
    this[U6] = function () {
        this[B5][c6] = (-this[X6][w6] + this[X6][N6]);
        this[B5][P6] = (-this[X6][z6] + this[X6][h6]);
        this[B5][z9] = (-this[X6][n6] + this[X6][G6]);
    };
    this[o6] = function () {
        var D = "innerHeight", M = "innerWidth", E6 = "offsetTop", L6 = "offsetLeft", H = "offsetHeight",
            e3 = "offsetWidth", V = "i6";
        if (F0D[V](this[T5], document)) {
            return {size: [this[T5][e3], this[T5][H]], offset: [this[T5][L6], this[T5][E6]]};
        } else {
            return {size: [window[M], window[D]], offset: [W6, W6]};
        }
    };
    this[a3] = function () {
        var D = "removeEventListener";
        this[T5][D](R, X5, b6);
        this[T5][D](u6, f5, b6);
    };
    var G5 = M3(this, this[Y6]), w5 = M3(this, this[x6]), R0 = M3(this, this[k6]), X5 = M3(this, this[U5]),
        f5 = M3(this, this[j6]);
    this[T5][M6](R, X5, b6);
    this[T5][M6](u6, f5, b6);
    this[T6]();
    this[U6]();
} : "renderType";
var Z1C6C = {
    'n3C': function (B, J) {
        return B === J;
    },
    'm7C': function (B, J) {
        return B === J;
    },
    'N5a': "crossOrigin",
    'H7C': function (B, J) {
        return B !== J;
    },
    'u1a': 2,
    'e5a': "nameLookup",
    'O3C': function (B, J) {
        return B / J;
    },
    'm5a': "materials",
    'g1a': 0,
    'F3C': function (B, J) {
        return B >= J;
    },
    'O1a': "options",
    'B7C': function (B, J) {
        return B > J;
    },
    'L3C': function (B, J) {
        return B === J;
    },
    'k5a': "MTLLoader",
    'J3C': function (B, J) {
        return B === J;
    },
    'X3C': function (B, J) {
        return B < J;
    },
    'C3C': function (B, J) {
        return B === J;
    },
    'k3C': function (B, J) {
        return B === J;
    },
    'a6C': function (B, J) {
        return B !== J;
    },
    'l1a': 1,
    'R4a': "setCrossOrigin",
    'D7C': function (B, J) {
        return B !== J;
    },
    'w3C': function (B, J) {
        return B >= J;
    },
    'E5j': (function (k5j) {
        return (function (K5j, Z5j) {
            return (function (A5j) {
                return {f5j: A5j, G5j: A5j,};
            })(function (u5j) {
                var O5j, l5j = 0;
                for (var M5j = K5j; l5j < u5j["length"]; l5j++) {
                    var q5j = Z5j(u5j, l5j);
                    O5j = l5j === 0 ? q5j : O5j ^ q5j;
                }
                return O5j ? M5j : !M5j;
            });
        })((function (V5j, j5j, g5j, i5j) {
            var P5j = 25;
            return V5j(k5j, P5j) - i5j(j5j, g5j) > P5j;
        })(parseInt, Date, (function (j5j) {
            return ('' + j5j)["substring"](1, (j5j + '')["length"] - 1);
        })('_getTime2'), function (j5j, g5j) {
            return new j5j()[g5j]();
        }), function (u5j, l5j) {
            var N5j = parseInt(u5j["charAt"](l5j), 16)["toString"](2);
            return N5j["charAt"](N5j["length"] - 1);
        });
    })('1m9020nf00'),
    'I3C': function (B, J) {
        return B === J;
    },
    'L1a': true,
    'x4a': "create",
    'M3C': function (B, J) {
        return B / J;
    },
    'd3C': function (B, J) {
        return B === J;
    },
    'Q5a': "path",
    'V5a': "MaterialCreator",
    't1a': "materialsInfo",
    'y1a': 'kd',
    'b5a': "wrap",
    'H5a': "side",
    'R3C': function (B, J) {
        return B < J;
    },
    'J5a': "manager",
    'N3C': function (B, J) {
        return B === J;
    },
    'p1a': 'ks',
    'z3C': function (B, J) {
        return B === J;
    },
    'b3C': function (B, J) {
        return B / J;
    },
    'P5a': "materialsArray",
    'r5a': "baseUrl",
    'U5a': "DefaultLoadingManager",
    't5a': "materialOptions",
    'g3C': function (B, J) {
        return B === J;
    },
    'y3C': function (B, J) {
        return B === J;
    },
    'd5a': "toLowerCase",
    'Y7C': function (B, J) {
        return B - J;
    }
};
Z1C6C.M9j = function (b) {
    if (Z1C6C && b)return Z1C6C.E5j.G5j(b);
};
Z1C6C.i9j = function (h) {
    if (Z1C6C && h)return Z1C6C.E5j.f5j(h);
};
Z1C6C.V9j = function (i) {
    while (i)return Z1C6C.E5j.G5j(i);
};
Z1C6C.k9j = function (n) {
    for (; Z1C6C;)return Z1C6C.E5j.f5j(n);
};
Z1C6C.P9j = function (c) {
    if (Z1C6C && c)return Z1C6C.E5j.f5j(c);
};
Z1C6C.l9j = function (a) {
    for (; Z1C6C;)return Z1C6C.E5j.f5j(a);
};
Z1C6C.N9j = function (g) {
    while (g)return Z1C6C.E5j.f5j(g);
};
Z1C6C.E9j = function (c) {
    if (Z1C6C && c)return Z1C6C.E5j.G5j(c);
};
Z1C6C.S9j = function (e) {
    while (e)return Z1C6C.E5j.f5j(e);
};
Z1C6C.F9j = function (k) {
    while (k)return Z1C6C.E5j.f5j(k);
};
Z1C6C.v9j = function (e) {
    while (e)return Z1C6C.E5j.G5j(e);
};
Z1C6C.w9j = function (g) {
    for (; Z1C6C;)return Z1C6C.E5j.f5j(g);
};
Z1C6C.D9j = function (l) {
    for (; Z1C6C;)return Z1C6C.E5j.f5j(l);
};
Z1C6C.t9j = function (l) {
    for (; Z1C6C;)return Z1C6C.E5j.f5j(l);
};
Z1C6C.I9j = function (h) {
    while (h)return Z1C6C.E5j.f5j(h);
};
Z1C6C.J9j = function (c) {
    while (c)return Z1C6C.E5j.f5j(c);
};
Z1C6C.B9j = function (h) {
    if (Z1C6C && h)return Z1C6C.E5j.f5j(h);
};
Z1C6C.X9j = function (l) {
    for (; Z1C6C;)return Z1C6C.E5j.f5j(l);
};
Z1C6C.R5j = function (g) {
    if (Z1C6C && g)return Z1C6C.E5j.G5j(g);
};
Z1C6C.x5j = function (n) {
    while (n)return Z1C6C.E5j.G5j(n);
};
Z1C6C.h5j = function (l) {
    if (Z1C6C && l)return Z1C6C.E5j.f5j(l);
};
Z1C6C.y5j = function (e) {
    while (e)return Z1C6C.E5j.G5j(e);
};
Z1C6C.Q5j = function (a) {
    while (a)return Z1C6C.E5j.G5j(a);
};
Z1C6C.U5j = function (a) {
    while (a)return Z1C6C.E5j.G5j(a);
};
Z1C6C.n5j = function (l) {
    for (; Z1C6C;)return Z1C6C.E5j.G5j(l);
};
Z1C6C.c5j = function (k) {
    if (Z1C6C && k)return Z1C6C.E5j.f5j(k);
};
Z1C6C.L5j = function (f) {
    if (Z1C6C && f)return Z1C6C.E5j.f5j(f);
};
Z1C6C.s5j = function (i) {
    if (Z1C6C && i)return Z1C6C.E5j.f5j(i);
};
Z1C6C.W5j = function (e) {
    for (; Z1C6C;)return Z1C6C.E5j.f5j(e);
};
THREE[Z1C6C.k5a] = Z1C6C.W5j("32") ? function (B) {
    Z1C6C.e5j = function (b) {
        if (Z1C6C && b)return Z1C6C.E5j.G5j(b);
    };
    Z1C6C.z5j = function (b) {
        while (b)return Z1C6C.E5j.f5j(b);
    };
    var J = Z1C6C.z5j("d6") ? "a6C" : ' ';
    this[Z1C6C.J5a] = Z1C6C.e5j("b724") ? "Group" : (Z1C6C[J](B, undefined)) ? B : THREE[Z1C6C.U5a];
} : "octree,";
THREE.MTLLoader.prototype = Z1C6C.s5j("4ea") ? "float reileighCoefficient = reileigh - (1.0* (1.0-sunfade));" : {
    constructor: THREE[Z1C6C.k5a],
    load: function (I, v, F, S) {
        Z1C6C.j9j = function (b) {
            for (; Z1C6C;)return Z1C6C.E5j.G5j(b);
        };
        Z1C6C.r5j = function (b) {
            if (Z1C6C && b)return Z1C6C.E5j.f5j(b);
        };
        var d = Z1C6C.L5j("242f") ? "setPath" : "onReceiveSelectEntity", E = Z1C6C.r5j("47") ? "XHRLoader" : "mg",
            N = Z1C6C.c5j("b66") ? this : "NoColors",
            k = Z1C6C.n5j("433") ? "greenland" : new THREE[E](this[Z1C6C.J5a]);
        k[d](this[Z1C6C.Q5a]);
        k.load(I, function (B) {
            var J = Z1C6C.j9j("fe") ? "parse" : "_vector4";
            v(N[J](B));
        }, F, S);
    },
    setPath: function (B) {
        this[Z1C6C.Q5a] = Z1C6C.U5j("ad8") ? B : "lineVertices";
    },
    setBaseUrl: function (B) {
        this[Z1C6C.r5a] = Z1C6C.Q5j("643") ? B : "alpha";
    },
    setCrossOrigin: function (B) {
        this[Z1C6C.N5a] = Z1C6C.k9j("1e2") ? B : "fromJsonObject";
    },
    setMaterialOptions: function (B) {
        this[Z1C6C.t5a] = B;
    },
    parse: function (B) {
        Z1C6C.g9j = function (a) {
            if (Z1C6C && a)return Z1C6C.E5j.f5j(a);
        };
        Z1C6C.u9j = function (g) {
            for (; Z1C6C;)return Z1C6C.E5j.f5j(g);
        };
        Z1C6C.f9j = function (j) {
            while (j)return Z1C6C.E5j.G5j(j);
        };
        Z1C6C.d9j = function (f) {
            if (Z1C6C && f)return Z1C6C.E5j.G5j(f);
        };
        Z1C6C.H9j = function (j) {
            if (Z1C6C && j)return Z1C6C.E5j.f5j(j);
        };
        Z1C6C.m9j = function (c) {
            for (; Z1C6C;)return Z1C6C.E5j.f5j(c);
        };
        Z1C6C.Y9j = function (n) {
            for (; Z1C6C;)return Z1C6C.E5j.f5j(n);
        };
        Z1C6C.o9j = function (f) {
            while (f)return Z1C6C.E5j.f5j(f);
        };
        Z1C6C.p9j = function (d) {
            if (Z1C6C && d)return Z1C6C.E5j.f5j(d);
        };
        Z1C6C.a5j = function (j) {
            while (j)return Z1C6C.E5j.f5j(j);
        };
        Z1C6C.C5j = function (g) {
            if (Z1C6C && g)return Z1C6C.E5j.G5j(g);
        };
        Z1C6C.T5j = function (i) {
            if (Z1C6C && i)return Z1C6C.E5j.f5j(i);
        };
        var J = Z1C6C.I9j("c2d") ? "setMaterials" : "BottomBackCenter",
            I = Z1C6C.N9j("53a") ? "orgTarget" : "setManager",
            v = Z1C6C.d9j("d22") ? 3 : "// 66 arc seconds -> degrees, and the cosine of that",
            F = Z1C6C.y5j("446") ? "preventDefault" : "ks",
            S = Z1C6C.t9j("741") ? "// 	return log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);" : "k3C",
            d = Z1C6C.D9j("dd") ? "pushVertex" : "kd",
            E = Z1C6C.u9j("bee6") ? "g3C" : "float cosTheta = dot(normalize(vWorldPosition - cameraPos), sunDirection);",
            N = Z1C6C.w9j("be") ? "ka" : "Matrix3", k = Z1C6C.v9j("a1") ? "N3C" : 'uv',
            V = Z1C6C.h5j("fa3c") ? "sort" : "newmtl", s = Z1C6C.E9j("151b") ? 'OnPickMarker' : "d3C",
            A = Z1C6C.T5j("6dcb") ? "stime" : "", q = Z1C6C.C5j("2c") ? "// }" : "F3C",
            L = Z1C6C.a5j("caf") ? "substring" : "mark", W = Z1C6C.m9j("8bfd") ? "w3C" : "queryelement",
            M = Z1C6C.x5j("ff") ? "DEFAULT" : ' ', i = Z1C6C.R5j("46") ? "lookAt" : "indexOf",
            c = Z1C6C.X9j("115") ? '#' : null, C = Z1C6C.p9j("41e") ? "charAt" : "multiplyMatrices",
            o8 = Z1C6C.B9j("6b") ? "I3C" : 0.0, H8 = Z1C6C.J9j("d26") ? "J3C" : 'block.mtl',
            E8 = Z1C6C.f9j("18") ? "trim" : "triggerLoadPrjectHeadInfoWebSocket",
            Y8 = Z1C6C.o9j("dff") ? "X3C" : "//	return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));",
            Q = Z1C6C.F9j("c4e8") ? 1.0 : "\n", f8 = Z1C6C.l9j("2e61") ? "split" : "pushNormal",
            t8 = Z1C6C.g9j("b73") ? B[f8](Q) : '/token', u8 = Z1C6C.Y9j("c2") ? "georoot" : {},
            l8 = Z1C6C.S9j("6d") ? /\s+/ : 'd', j8 = Z1C6C.H9j("3224") ? {} : "timelog";
        for (var G8 = Z1C6C.g1a; Z1C6C[Y8](G8, t8.length); G8++) {
            var V8 = t8[G8];
            V8 = V8[E8]();
            if (Z1C6C[H8](V8.length, Z1C6C.g1a) || Z1C6C[o8](V8[C](Z1C6C.g1a), c)) {
                continue;
            }
            var G4 = V8[i](M), a8 = (Z1C6C[W](G4, Z1C6C.g1a)) ? V8[L](Z1C6C.g1a, G4) : V8;
            a8 = a8[Z1C6C.d5a]();
            var K8 = (Z1C6C[q](G4, Z1C6C.g1a)) ? V8[L](G4 + Z1C6C.l1a) : A;
            K8 = K8[E8]();
            if (Z1C6C[s](a8, V)) {
                u8 = {name: K8};
                j8[K8] = u8;
            } else if (u8) {
                if (Z1C6C[k](a8, N) || Z1C6C[E](a8, d) || Z1C6C[S](a8, F)) {
                    var s8 = K8[f8](l8, v);
                    u8[a8] = [parseFloat(s8[Z1C6C.g1a]), parseFloat(s8[Z1C6C.l1a]), parseFloat(s8[Z1C6C.u1a])];
                } else {
                    u8[a8] = K8;
                }
            }
        }
        var X1 = Z1C6C.P9j("76") ? new THREE[Z1C6C.k5a][Z1C6C.V5a](this[Z1C6C.r5a], this[Z1C6C.t5a]) : 38;
        X1[Z1C6C.R4a](this[Z1C6C.N5a]);
        X1[I](this[Z1C6C.J5a]);
        X1[J](j8);
        return X1;
    }
};
THREE[Z1C6C.k5a][Z1C6C.V5a] = Z1C6C.V9j("a5c") ? function (B, J) {
    Z1C6C.Z9j = function (k) {
        while (k)return Z1C6C.E5j.G5j(k);
    };
    Z1C6C.q9j = function (n) {
        while (n)return Z1C6C.E5j.G5j(n);
    };
    Z1C6C.O9j = function (l) {
        while (l)return Z1C6C.E5j.f5j(l);
    };
    var I = Z1C6C.i9j("a77") ? "normal" : "RepeatWrapping", v = Z1C6C.O9j("c1") ? "FrontSide" : "wtn";
    this[Z1C6C.r5a] = B;
    this[Z1C6C.O1a] = Z1C6C.q9j("81d7") ? J : "lineSecondChar";
    this[Z1C6C.t1a] = {};
    this[Z1C6C.m5a] = Z1C6C.Z9j("27") ? {} : "// const float mieDirectionalG = 0.8;";
    this[Z1C6C.P5a] = [];
    this[Z1C6C.e5a] = Z1C6C.M9j("6b") ? {} : 16;
    this[Z1C6C.H5a] = (this[Z1C6C.O1a] && this[Z1C6C.O1a][Z1C6C.H5a]) ? this[Z1C6C.O1a][Z1C6C.H5a] : THREE[v];
    this[Z1C6C.b5a] = (this[Z1C6C.O1a] && this[Z1C6C.O1a][Z1C6C.b5a]) ? this[Z1C6C.O1a][Z1C6C.b5a] : THREE[I];
} : 0.403922;
THREE.MTLLoader.MaterialCreator.prototype = {
    constructor: THREE[Z1C6C.k5a][Z1C6C.V5a], setCrossOrigin: function (B) {
        this[Z1C6C.N5a] = B;
    }, setManager: function (B) {
        this[Z1C6C.J5a] = B;
    }, setMaterials: function (B) {
        var J = "convert";
        this[Z1C6C.t1a] = this[J](B);
        this[Z1C6C.m5a] = {};
        this[Z1C6C.P5a] = [];
        this[Z1C6C.e5a] = {};
    }, convert: function (B) {
        var J = false, I = "n3C", v = "L3C", F = "z3C", S = "ignoreZeroRGBs", d = "b3C", E = "M3C", N = 255, k = "O3C",
            V = "normalizeRGB", s = 'ka';
        if (!this[Z1C6C.O1a])return B;
        var A = {};
        for (var q in B) {
            var L = B[q], W = {};
            A[q] = W;
            for (var M in L) {
                var i = Z1C6C.L1a, c = L[M], C = M[Z1C6C.d5a]();
                switch (C) {
                    case Z1C6C.y1a:
                    case s:
                    case Z1C6C.p1a:
                        if (this[Z1C6C.O1a] && this[Z1C6C.O1a][V]) {
                            c = [Z1C6C[k](c[Z1C6C.g1a], N), Z1C6C[E](c[Z1C6C.l1a], N), Z1C6C[d](c[Z1C6C.u1a], N)];
                        }
                        if (this[Z1C6C.O1a] && this[Z1C6C.O1a][S]) {
                            if (Z1C6C[F](c[Z1C6C.g1a], Z1C6C.g1a) && Z1C6C[v](c[Z1C6C.l1a], Z1C6C.g1a) && Z1C6C[I](c[Z1C6C.l1a], Z1C6C.g1a)) {
                                i = J;
                            }
                        }
                        break;
                    default:
                        break;
                }
                if (i) {
                    W[C] = c;
                }
            }
        }
        return A;
    }, preload: function () {
        for (var B in this[Z1C6C.t1a]) {
            this[Z1C6C.x4a](B);
        }
    }, getIndex: function (B) {
        return this[Z1C6C.e5a][B];
    }, getAsArray: function () {
        var B = Z1C6C.g1a;
        for (var J in this[Z1C6C.t1a]) {
            this[Z1C6C.P5a][B] = this[Z1C6C.x4a](J);
            this[Z1C6C.e5a][J] = B;
            B++;
        }
        return this[Z1C6C.P5a];
    }, create: function (B) {
        var J = "createMaterial_", I = "y3C";
        if (Z1C6C[I](this[Z1C6C.m5a][B], undefined)) {
            this[J](B);
        }
        return this[Z1C6C.m5a][B];
    }, createMaterial_: function (B) {
        var J = "MeshPhongMaterial", I = 'bumpMap', v = 'bump', F = 'map_bump', S = "Y7C", d = "B7C", E = 'Tr',
            N = 'transparent', k = 'opacity', V = "R3C", s = 'd', A = 'shininess', q = 'ns', L = "wrapT", W = "wrapS",
            M = "loadTexture", i = 'map', c = 'map_kd', C = 'specular', o8 = "fromArray", H8 = "Color", E8 = 'color',
            Y8 = '', Q = "C3C", f8 = this[Z1C6C.t1a][B], t8 = {name: B, side: this[Z1C6C.H5a]};
        for (var u8 in f8) {
            var l8 = f8[u8];
            if (Z1C6C[Q](l8, Y8))continue;
            switch (u8[Z1C6C.d5a]()) {
                case Z1C6C.y1a:
                    t8[E8] = new THREE[H8]()[o8](l8);
                    break;
                case Z1C6C.p1a:
                    t8[C] = new THREE[H8]()[o8](l8);
                    break;
                case c:
                    t8[i] = this[M](this[Z1C6C.r5a] + l8);
                    t8[i][W] = this[Z1C6C.b5a];
                    t8[i][L] = this[Z1C6C.b5a];
                    break;
                case q:
                    t8[A] = parseFloat(l8);
                    break;
                case s:
                    if (Z1C6C[V](l8, Z1C6C.l1a)) {
                        t8[k] = l8;
                        t8[N] = Z1C6C.L1a;
                    }
                    break;
                case E:
                    if (Z1C6C[d](l8, Z1C6C.g1a)) {
                        t8[k] = Z1C6C[S](Z1C6C.l1a, l8);
                        t8[N] = Z1C6C.L1a;
                    }
                    break;
                case F:
                case v:
                    if (t8[I])break;
                    t8[I] = this[M](this[Z1C6C.r5a] + l8);
                    t8[I][W] = this[Z1C6C.b5a];
                    t8[I][L] = this[Z1C6C.b5a];
                    break;
                default:
                    break;
            }
        }
        this[Z1C6C.m5a][B] = new THREE[J](t8);
        return this[Z1C6C.m5a][B];
    }, loadTexture: function (B, J, I, v, F) {
        var S = "mapping", d = "H7C", E = "TextureLoader", N = null, k = "m7C", V = "D7C", s = "get", A = "Handlers",
            q = "Loader", L, W = THREE[q][A][s](B),
            M = (Z1C6C[V](this[Z1C6C.J5a], undefined)) ? this[Z1C6C.J5a] : THREE[Z1C6C.U5a];
        if (Z1C6C[k](W, N)) {
            W = new THREE[E](M);
        }
        if (W[Z1C6C.R4a]) W[Z1C6C.R4a](this[Z1C6C.N5a]);
        L = W.load(B, I, v, F);
        if (Z1C6C[d](J, undefined)) L[S] = J;
        return L;
    }
};
THREE.EventDispatcher.prototype.apply(THREE.MTLLoader.prototype);
var y6H8C = {
    'D4C': function (B, J) {
        return B < J;
    }, 'b8C': function (B, J) {
        return B * J;
    }, 's4C': function (B, J) {
        return B !== J;
    }, 'Q4C': function (B, J) {
        return B !== J;
    }, 'W4C': function (B, J) {
        return B === J;
    }, 'p1C': function (B, J) {
        return B !== J;
    }, 'k8C': function (B, J) {
        return B !== J;
    }, 'I5X': "materials", 'y8C': function (B, J) {
        return B !== J;
    }, 'U1C': function (B, J) {
        return B > J;
    }, 'R8C': function (B, J) {
        return B === J;
    }, 'E1C': function (B, J) {
        return B !== J;
    }, 's7i': (function (h7i) {
        return (function (p0i, R7i) {
            return (function (B0i) {
                return {L7i: B0i, o0i: B0i,};
            })(function (c7i) {
                var a7i, n7i = 0;
                for (var X0i = p0i; n7i < c7i["length"]; n7i++) {
                    var x7i = R7i(c7i, n7i);
                    a7i = n7i === 0 ? x7i : a7i ^ x7i;
                }
                return a7i ? X0i : !X0i;
            });
        })((function (T7i, Q7i, U7i, C7i) {
            var y7i = 33;
            return T7i(h7i, y7i) - C7i(Q7i, U7i) > y7i;
        })(parseInt, Date, (function (Q7i) {
            return ('' + Q7i)["substring"](1, (Q7i + '')["length"] - 1);
        })('_getTime2'), function (Q7i, U7i) {
            return new Q7i()[U7i]();
        }), function (c7i, n7i) {
            var r7i = parseInt(c7i["charAt"](n7i), 16)["toString"](2);
            return r7i["charAt"](r7i["length"] - 1);
        });
    })('54ikun19i'), 'c4C': function (B, J) {
        return B === J;
    }, 'Y4C': function (B, J) {
        return B < J;
    }, 'G1C': function (B, J) {
        return B === J;
    }, 'N8C': function (B, J) {
        return B === J;
    }, 'm5X': '', 'Y9X': "path", 'r5X': "name", 'A4X': "regexp", 'P4C': function (B, J) {
        return B === J;
    }, 'f4C': function (B, J) {
        return B === J;
    }, 'h1C': function (B, J) {
        return B !== J;
    }, 'I4X': "object", 'C8C': function (B, J) {
        return B === J;
    }, 'z8C': function (B, J) {
        return B === J;
    }, 't1C': function (B, J) {
        return B < J;
    }, 'O8C': function (B, J) {
        return B * J;
    }, 'j1C': function (B, J) {
        return B === J;
    }, 'S1C': function (B, J) {
        return B !== J;
    }, 'G4X': 3, 'u1C': function (B, J) {
        return B !== J;
    }, 'T4C': function (B, J) {
        return B !== J;
    }, 'd8C': function (B, J) {
        return B !== J;
    }, 'z4X': 1, 'X9X': "objects", 'b4X': "OBJLoader", 'B4C': function (B, J) {
        return B === J;
    }, 'i4C': function (B, J) {
        return B !== J;
    }, 'U1X': "push", 'd1X': 'Line', 'M8C': function (B, J) {
        return B * J;
    }, 'L8C': function (B, J) {
        return B !== J;
    }, 'K5X': "uvs", 'H4C': function (B, J) {
        return B === J;
    }, 'm4C': function (B, J) {
        return B < J;
    }, 'e1C': function (B, J) {
        return B === J;
    }, 'g1X': "type", 'e4X': 0, 'r1C': function (B, J) {
        return B > J;
    }, 'a1C': function (B, J) {
        return B instanceof J;
    }, 'f4X': "vertices", 'A1X': "startObject", 'q5X': "geometry", 'X4X': "normals", 'Z4C': function (B, J) {
        return B === J;
    }, 'W4X': 2, 'v1C': function (B, J) {
        return B !== J;
    }, 'K1C': function (B, J) {
        return B < J;
    }, 'l4C': function (B, J) {
        return B === J;
    }, 'b1X': 10, 'o1C': function (B, J) {
        return B === J;
    }, 'x4C': function (B, J) {
        return B !== J;
    }, 'V1C': function (B, J) {
        return B === J;
    }, 'q1C': function (B, J) {
        return B === J;
    }, 'A4C': function (B, J) {
        return B !== J;
    }, 'n8C': function (B, J) {
        return B === J;
    }, 'u1X': null, 'C1X': "manager", 'g8C': function (B, J) {
        return B !== J;
    }
};
y6H8C.x0i = function (j) {
    if (y6H8C && j)return y6H8C.s7i.o0i(j);
};
y6H8C.T0i = function (d) {
    while (d)return y6H8C.s7i.o0i(d);
};
y6H8C.h0i = function (g) {
    for (; y6H8C;)return y6H8C.s7i.o0i(g);
};
y6H8C.r0i = function (f) {
    while (f)return y6H8C.s7i.o0i(f);
};
y6H8C.G0i = function (a) {
    if (y6H8C && a)return y6H8C.s7i.o0i(a);
};
y6H8C.M0i = function (e) {
    while (e)return y6H8C.s7i.o0i(e);
};
y6H8C.Z0i = function (d) {
    while (d)return y6H8C.s7i.o0i(d);
};
y6H8C.O0i = function (c) {
    for (; y6H8C;)return y6H8C.s7i.o0i(c);
};
y6H8C.i0i = function (l) {
    for (; y6H8C;)return y6H8C.s7i.L7i(l);
};
y6H8C.k0i = function (k) {
    while (k)return y6H8C.s7i.o0i(k);
};
y6H8C.g0i = function (i) {
    for (; y6H8C;)return y6H8C.s7i.o0i(i);
};
y6H8C.N0i = function (h) {
    if (y6H8C && h)return y6H8C.s7i.L7i(h);
};
y6H8C.H0i = function (n) {
    while (n)return y6H8C.s7i.o0i(n);
};
y6H8C.S0i = function (d) {
    if (y6H8C && d)return y6H8C.s7i.L7i(d);
};
y6H8C.F0i = function (d) {
    if (y6H8C && d)return y6H8C.s7i.o0i(d);
};
y6H8C.m0i = function (e) {
    for (; y6H8C;)return y6H8C.s7i.o0i(e);
};
y6H8C.v0i = function (m) {
    for (; y6H8C;)return y6H8C.s7i.L7i(m);
};
y6H8C.I0i = function (b) {
    if (y6H8C && b)return y6H8C.s7i.L7i(b);
};
y6H8C.Y0i = function (n) {
    while (n)return y6H8C.s7i.L7i(n);
};
THREE[y6H8C.b4X] = y6H8C.Y0i("de6f") ? 'touchmove' : function (B) {
    y6H8C.w0i = function (d) {
        if (y6H8C && d)return y6H8C.s7i.L7i(d);
    };
    y6H8C.D0i = function (b) {
        if (y6H8C && b)return y6H8C.s7i.o0i(b);
    };
    y6H8C.t0i = function (n) {
        for (; y6H8C;)return y6H8C.s7i.L7i(n);
    };
    var J = y6H8C.I0i("ef4") ? "DefaultLoadingManager" : "html",
        I = y6H8C.t0i("f5bb") ? "//	return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));" : "d8C";
    this[y6H8C.C1X] = y6H8C.D0i("c23f") ? .1 : (y6H8C[I](B, undefined)) ? B : THREE[J];
    this[y6H8C.I5X] = y6H8C.w0i("abde") ? 'now' : y6H8C.u1X;
    this[y6H8C.A4X] = y6H8C.v0i("4f") ? {
        vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
        face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
        face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
        face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
        face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
        object_pattern: /^[og]\s*(.+)?/,
        smoothing_pattern: /^s\s+(\d+|on|off)/,
        material_library_pattern: /^mtllib /,
        material_use_pattern: /^usemtl /
    } : 7.0;
};
THREE.OBJLoader.prototype = y6H8C.m0i("e3b") ? 60 : {
    constructor: THREE[y6H8C.b4X], load: function (I, v, F, S) {
        var d = y6H8C.F0i("14ea") ? "setPath" : "interpolation", E = y6H8C.S0i("b74") ? "_isPlaying" : "XHRLoader",
            N = y6H8C.H0i("88a7") ? this : "DataServerDataBlockReceived", k = new THREE[E](N[y6H8C.C1X]);
        k[d](this[y6H8C.Y9X]);
        k.load(I, function (B) {
            var J = "parse";
            v(N[J](B));
        }, F, S);
    }, setPath: function (B) {
        this[y6H8C.Y9X] = B;
    }, setMaterials: function (B) {
        this[y6H8C.I5X] = B;
    }, _createParserState: function () {
        y6H8C.s0i = function (m) {
            for (; y6H8C;)return y6H8C.s7i.L7i(m);
        };
        y6H8C.W0i = function (i) {
            while (i)return y6H8C.s7i.L7i(i);
        };
        y6H8C.b0i = function (f) {
            for (; y6H8C;)return y6H8C.s7i.o0i(f);
        };
        y6H8C.P0i = function (c) {
            while (c)return y6H8C.s7i.o0i(c);
        };
        y6H8C.j0i = function (m) {
            while (m)return y6H8C.s7i.o0i(m);
        };
        y6H8C.l0i = function (f) {
            while (f)return y6H8C.s7i.o0i(f);
        };
        y6H8C.E0i = function (b) {
            for (; y6H8C;)return y6H8C.s7i.L7i(b);
        };
        y6H8C.d0i = function (e) {
            if (y6H8C && e)return y6H8C.s7i.o0i(e);
        };
        var l8 = y6H8C.T0i("2f3e") ? "fromcache" : "parseUVIndex",
            j8 = y6H8C.d0i("3f") ? "Exponential" : "parseVertexIndex", G8 = false, V8 = y6H8C.E0i("d25") ? '#' : {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                uvs: [],
                materialLibraries: [],
                startObject: function (B, J) {
                    y6H8C.C0i = function (f) {
                        if (y6H8C && f)return y6H8C.s7i.o0i(f);
                    };
                    y6H8C.u0i = function (f) {
                        for (; y6H8C;)return y6H8C.s7i.L7i(f);
                    };
                    y6H8C.f0i = function (c) {
                        for (; y6H8C;)return y6H8C.s7i.L7i(c);
                    };
                    var I = y6H8C.f0i("38") ? "k8C" : "vec3 betaRTheta = betaR * rPhase;";
                    var v = y6H8C.N0i("aec5") ? true : "matrixWorldInverse";
                    var F = "g8C";
                    var S = "fromDeclaration";
                    var d = y6H8C.C0i("cf4") ? "N8C" : 'GET';
                    if (this[y6H8C.I4X] && y6H8C[d](this[y6H8C.I4X][S], G8)) {
                        y6H8C.a0i = function (n) {
                            for (; y6H8C;)return y6H8C.s7i.o0i(n);
                        };
                        this[y6H8C.I4X][y6H8C.r5X] = y6H8C.a0i("56") ? B : "uvs";
                        this[y6H8C.I4X][S] = y6H8C.x0i("47") ? (y6H8C[F](J, G8)) : 0x6c6c6c;
                        return;
                    }
                    this[y6H8C.I4X] = y6H8C.u0i("6c1") ? {
                        name: B || y6H8C.m5X,
                        geometry: {vertices: [], normals: [], uvs: []},
                        material: {name: y6H8C.m5X, smooth: v},
                        fromDeclaration: (y6H8C[I](J, G8))
                    } : "vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));";
                    this[y6H8C.X9X][y6H8C.U1X](this[y6H8C.I4X]);
                },
                parseVertexIndex: function (B, J) {
                    y6H8C.R0i = function (k) {
                        while (k)return y6H8C.s7i.o0i(k);
                    };
                    var I = y6H8C.R0i("d5a") ? "l" : "O8C";
                    var v = parseInt(B, y6H8C.b1X);
                    return y6H8C[I]((v >= y6H8C.e4X ? v - y6H8C.z4X : v + J / y6H8C.G4X), y6H8C.G4X);
                },
                parseNormalIndex: function (B, J) {
                    var I = y6H8C.l0i("d6") ? "M8C" : 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.';
                    var v = y6H8C.g0i("c175") ? parseInt(B, y6H8C.b1X) : 1024;
                    return y6H8C[I]((v >= y6H8C.e4X ? v - y6H8C.z4X : v + J / y6H8C.G4X), y6H8C.G4X);
                },
                parseUVIndex: function (B, J) {
                    var I = y6H8C.j0i("6dc") ? "b8C" : 1.0;
                    var v = y6H8C.P0i("47") ? parseInt(B, y6H8C.b1X) : "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );";
                    return y6H8C[I]((v >= y6H8C.e4X ? v - y6H8C.z4X : v + J / y6H8C.W4X), y6H8C.W4X);
                },
                addVertex: function (B, J, I) {
                    var v = y6H8C.k0i("f61") ? "vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;" : this[y6H8C.f4X];
                    var F = this[y6H8C.I4X][y6H8C.q5X][y6H8C.f4X];
                    F[y6H8C.U1X](v[B + y6H8C.e4X]);
                    F[y6H8C.U1X](v[B + y6H8C.z4X]);
                    F[y6H8C.U1X](v[B + y6H8C.W4X]);
                    F[y6H8C.U1X](v[J + y6H8C.e4X]);
                    F[y6H8C.U1X](v[J + y6H8C.z4X]);
                    F[y6H8C.U1X](v[J + y6H8C.W4X]);
                    F[y6H8C.U1X](v[I + y6H8C.e4X]);
                    F[y6H8C.U1X](v[I + y6H8C.z4X]);
                    F[y6H8C.U1X](v[I + y6H8C.W4X]);
                },
                addVertexLine: function (B) {
                    y6H8C.V0i = function (m) {
                        for (; y6H8C;)return y6H8C.s7i.o0i(m);
                    };
                    var J = this[y6H8C.f4X];
                    var I = y6H8C.V0i("a7b2") ? "vec3 betaMTheta = betaM * mPhase;" : this[y6H8C.I4X][y6H8C.q5X][y6H8C.f4X];
                    I[y6H8C.U1X](J[B + y6H8C.e4X]);
                    I[y6H8C.U1X](J[B + y6H8C.z4X]);
                    I[y6H8C.U1X](J[B + y6H8C.W4X]);
                },
                addNormal: function (B, J, I) {
                    var v = y6H8C.i0i("ef") ? this[y6H8C.X4X] : 'string';
                    var F = this[y6H8C.I4X][y6H8C.q5X][y6H8C.X4X];
                    F[y6H8C.U1X](v[B + y6H8C.e4X]);
                    F[y6H8C.U1X](v[B + y6H8C.z4X]);
                    F[y6H8C.U1X](v[B + y6H8C.W4X]);
                    F[y6H8C.U1X](v[J + y6H8C.e4X]);
                    F[y6H8C.U1X](v[J + y6H8C.z4X]);
                    F[y6H8C.U1X](v[J + y6H8C.W4X]);
                    F[y6H8C.U1X](v[I + y6H8C.e4X]);
                    F[y6H8C.U1X](v[I + y6H8C.z4X]);
                    F[y6H8C.U1X](v[I + y6H8C.W4X]);
                },
                addUV: function (B, J, I) {
                    y6H8C.q0i = function (i) {
                        if (y6H8C && i)return y6H8C.s7i.o0i(i);
                    };
                    var v = y6H8C.O0i("2c") ? 0.403922 : this[y6H8C.K5X];
                    var F = y6H8C.q0i("428") ? '/images/land/' : this[y6H8C.I4X][y6H8C.q5X][y6H8C.K5X];
                    F[y6H8C.U1X](v[B + y6H8C.e4X]);
                    F[y6H8C.U1X](v[B + y6H8C.z4X]);
                    F[y6H8C.U1X](v[J + y6H8C.e4X]);
                    F[y6H8C.U1X](v[J + y6H8C.z4X]);
                    F[y6H8C.U1X](v[I + y6H8C.e4X]);
                    F[y6H8C.U1X](v[I + y6H8C.z4X]);
                },
                addUVLine: function (B) {
                    y6H8C.X8j = function (g) {
                        if (y6H8C && g)return y6H8C.s7i.L7i(g);
                    };
                    var J = this[y6H8C.K5X];
                    var I = y6H8C.X8j("ec4a") ? "Group" : this[y6H8C.I4X][y6H8C.q5X][y6H8C.K5X];
                    I[y6H8C.U1X](J[B + y6H8C.e4X]);
                    I[y6H8C.U1X](J[B + y6H8C.z4X]);
                },
                addFace: function (B, J, I, v, F, S, d, E, N, k, V, n) {
                    y6H8C.U0i = function (f) {
                        while (f)return y6H8C.s7i.o0i(f);
                    };
                    y6H8C.n0i = function (b) {
                        for (; y6H8C;)return y6H8C.s7i.L7i(b);
                    };
                    y6H8C.z0i = function (f) {
                        if (y6H8C && f)return y6H8C.s7i.o0i(f);
                    };
                    y6H8C.A0i = function (g) {
                        while (g)return y6H8C.s7i.L7i(g);
                    };
                    y6H8C.K0i = function (n) {
                        while (n)return y6H8C.s7i.o0i(n);
                    };
                    var s = "addNormal";
                    var A = "B4C";
                    var q = "R8C";
                    var L = y6H8C.Z0i("6ce") ? "vec3 totalRayleigh(vec3 lambda)" : "C8C";
                    var W = "parseNormalIndex";
                    var M = "y8C";
                    var i = "addUV";
                    var p8 = y6H8C.M0i("82a") ? 65 : "n8C";
                    var c = "L8C";
                    var C = y6H8C.K0i("6f8") ? "addVertex" : "DataStream";
                    var o8 = y6H8C.A0i("ed3") ? 0.9375 : "z8C";
                    var H8 = this[y6H8C.f4X].length;
                    var E8 = y6H8C.b0i("e2b2") ? this[j8](B, H8) : 'end';
                    var Y8 = y6H8C.G0i("b27") ? 'ns' : this[j8](J, H8);
                    var Q = this[j8](I, H8);
                    var f8;
                    if (y6H8C[o8](v, undefined)) {
                        this[C](E8, Y8, Q);
                    } else {
                        f8 = this[j8](v, H8);
                        this[C](E8, Y8, f8);
                        this[C](Y8, Q, f8);
                    }
                    if (y6H8C[c](F, undefined)) {
                        var t8 = y6H8C.W0i("3453") ? this[y6H8C.K5X].length : "error";
                        E8 = y6H8C.z0i("b7ec") ? "return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));" : this[l8](F, t8);
                        Y8 = y6H8C.s0i("faf") ? "gl_FragColor.a = 1.0;" : this[l8](S, t8);
                        Q = this[l8](d, t8);
                        if (y6H8C[p8](v, undefined)) {
                            this[i](E8, Y8, Q);
                        } else {
                            y6H8C.e0i = function (c) {
                                for (; y6H8C;)return y6H8C.s7i.L7i(c);
                            };
                            f8 = y6H8C.e0i("137d") ? "singlebackground" : this[l8](E, t8);
                            this[i](E8, Y8, f8);
                            this[i](Y8, Q, f8);
                        }
                    }
                    if (y6H8C[M](N, undefined)) {
                        y6H8C.c0i = function (k) {
                            for (; y6H8C;)return y6H8C.s7i.L7i(k);
                        };
                        y6H8C.L0i = function (m) {
                            if (y6H8C && m)return y6H8C.s7i.o0i(m);
                        };
                        var u8 = y6H8C.L0i("5a5") ? "vWorldPosition = worldPosition.xyz;" : this[y6H8C.X4X].length;
                        E8 = y6H8C.U0i("5fb") ? this[W](N, u8) : 'trans';
                        Y8 = y6H8C.r0i("7f11") ? "vec3 Uncharted2Tonemap(vec3 x)" : y6H8C[L](N, k) ? E8 : this[W](k, u8);
                        Q = y6H8C.c0i("c5d") ? "// vec3 L0 = texture2D(skySampler, uv).rgb+0.1 * Fex;" : y6H8C[q](N, V) ? E8 : this[W](V, u8);
                        if (y6H8C[A](v, undefined)) {
                            this[s](E8, Y8, Q);
                        } else {
                            f8 = y6H8C.n0i("764e") ? this[W](n, u8) : 'n';
                            this[s](E8, Y8, f8);
                            this[s](Y8, Q, f8);
                        }
                    }
                },
                addLineGeometry: function (B, J) {
                    y6H8C.y0i = function (a) {
                        for (; y6H8C;)return y6H8C.s7i.o0i(a);
                    };
                    y6H8C.Q0i = function (g) {
                        if (y6H8C && g)return y6H8C.s7i.L7i(g);
                    };
                    var I = "addUVLine";
                    var v = y6H8C.Q0i("8523") ? "{" : "D4C";
                    var F = "addVertexLine";
                    var S = "Y4C";
                    this[y6H8C.I4X][y6H8C.q5X][y6H8C.g1X] = y6H8C.y0i("547") ? 'text' : y6H8C.d1X;
                    var d = this[y6H8C.f4X].length;
                    var E = y6H8C.h0i("a8e") ? ":" : this[y6H8C.K5X].length;
                    for (var N = y6H8C.e4X, k = B.length; y6H8C[S](N, k); N++) {
                        this[F](this[j8](B[N], d));
                    }
                    for (var V = y6H8C.e4X, k = J.length; y6H8C[v](V, k); V++) {
                        this[I](this[l8](J[V], E));
                    }
                }
            };
        V8[y6H8C.A1X](y6H8C.m5X, G8);
        return V8;
    }, parse: function (B) {
        var J = "timeEnd", I = "add", v = "Line", F = "Mesh", S = "FlatShading", d = "SmoothShading", E = "shading",
            N = "MeshPhongMaterial", k = "copy", V = "LineBasicMaterial", n = "a1C", s = "create", A = "h1C", q = 'uv',
            L = "U1C", W = "computeVertexNormals", M = 'normal', i = "r1C", p8 = "BufferAttribute", c = 'position',
            C = "addAttribute", o8 = "BufferGeometry", H8 = "e1C", E8 = "G1C", Y8 = "K1C", Q = "concat", f8 = "Group",
            t8 = "Unexpected line: '", u8 = '\0', l8 = "q1C", j8 = 'on', G8 = "V1C", V8 = '1', G4 = "j1C",
            a8 = "smooth", K8 = "toLowerCase", s8 = "smoothing_pattern", X1 = "u1C", L4 = "materialLibraries",
            i8 = "material_library_pattern", r4 = "material", N4 = "test", x8 = "material_use_pattern", u4 = "substr",
            w4 = "object_pattern", z4 = "E1C", A8 = "addLineGeometry", t4 = "S1C", W8 = "", r1 = "v1C", C4 = "t1C",
            w1 = "/", R1 = " ", O1 = "substring", m1 = "l", d1 = "o1C", B1 = "Unexpected face line: '",
            Z1 = "face_vertex", n4 = "p1C", g4 = "face_vertex_normal", W1 = "x4C", f1 = "face_vertex_uv", F5 = "T4C",
            V4 = 12, Y1 = 9, X4 = 6, j5 = 11, Y5 = 8, O4 = 5, J1 = 7, v4 = 4, q8 = "addFace",
            X5 = "face_vertex_uv_normal", j4 = "Q4C", h8 = "f", r8 = "c4C", I5 = "'",
            e4 = "Unexpected vertex/normal/uv line: '", p4 = "uv_pattern", s5 = "s4C", J4 = 't', D8 = "W4C",
            B8 = "normal_pattern", D5 = "A4C", e8 = 'n', P5 = "Z4C", M4 = "exec", q4 = "vertex_pattern", T8 = "i4C",
            k5 = ' ', e1 = "P4C", P1 = 'v', o4 = "l4C", F4 = '#', M1 = "f4C", U1 = "charAt", H5 = "H4C", a4 = "trim",
            z1 = "m4C", L5 = 'function', f5 = "trimLeft", d5 = "split", A5 = '\n', d9 = "replace", p9 = '\r\n',
            R = "indexOf", r5 = "_createParserState", K5 = 'OBJLoader', T9 = "time";
        console[T9](K5);
        var n1 = this[r5]();
        if (B[R](p9) !== -y6H8C.z4X) {
            B = B[d9](p9, A5);
        }
        var C9 = B[d5](A5), c8 = y6H8C.m5X, f9 = y6H8C.m5X, l1 = y6H8C.m5X, N9 = y6H8C.e4X, T = [],
            U5 = (typeof y6H8C.m5X[f5] === L5);
        for (var y1 = y6H8C.e4X, J9 = C9.length; y6H8C[z1](y1, J9); y1++) {
            c8 = C9[y1];
            c8 = U5 ? c8[f5]() : c8[a4]();
            N9 = c8.length;
            if (y6H8C[H5](N9, y6H8C.e4X))continue;
            f9 = c8[U1](y6H8C.e4X);
            if (y6H8C[M1](f9, F4))continue;
            if (y6H8C[o4](f9, P1)) {
                l1 = c8[U1](y6H8C.z4X);
                if (y6H8C[e1](l1, k5) && y6H8C[T8]((T = this[y6H8C.A4X][q4][M4](c8)), y6H8C.u1X)) {
                    n1[y6H8C.f4X][y6H8C.U1X](parseFloat(T[y6H8C.z4X]), parseFloat(T[y6H8C.W4X]), parseFloat(T[y6H8C.G4X]));
                } else if (y6H8C[P5](l1, e8) && y6H8C[D5]((T = this[y6H8C.A4X][B8][M4](c8)), y6H8C.u1X)) {
                    n1[y6H8C.X4X][y6H8C.U1X](parseFloat(T[y6H8C.z4X]), parseFloat(T[y6H8C.W4X]), parseFloat(T[y6H8C.G4X]));
                } else if (y6H8C[D8](l1, J4) && y6H8C[s5]((T = this[y6H8C.A4X][p4][M4](c8)), y6H8C.u1X)) {
                    n1[y6H8C.K5X][y6H8C.U1X](parseFloat(T[y6H8C.z4X]), parseFloat(T[y6H8C.W4X]));
                } else {
                    throw  new Error(e4 + c8 + I5);
                }
            } else if (y6H8C[r8](f9, h8)) {
                if (y6H8C[j4]((T = this[y6H8C.A4X][X5][M4](c8)), y6H8C.u1X)) {
                    n1[q8](T[y6H8C.z4X], T[v4], T[J1], T[y6H8C.b1X], T[y6H8C.W4X], T[O4], T[Y5], T[j5], T[y6H8C.G4X], T[X4], T[Y1], T[V4]);
                } else if (y6H8C[F5]((T = this[y6H8C.A4X][f1][M4](c8)), y6H8C.u1X)) {
                    n1[q8](T[y6H8C.z4X], T[y6H8C.G4X], T[O4], T[J1], T[y6H8C.W4X], T[v4], T[X4], T[Y5]);
                } else if (y6H8C[W1]((T = this[y6H8C.A4X][g4][M4](c8)), y6H8C.u1X)) {
                    n1[q8](T[y6H8C.z4X], T[y6H8C.G4X], T[O4], T[J1], undefined, undefined, undefined, undefined, T[y6H8C.W4X], T[v4], T[X4], T[Y5]);
                } else if (y6H8C[n4]((T = this[y6H8C.A4X][Z1][M4](c8)), y6H8C.u1X)) {
                    n1[q8](T[y6H8C.z4X], T[y6H8C.W4X], T[y6H8C.G4X], T[v4]);
                } else {
                    throw  new Error(B1 + c8 + I5);
                }
            } else if (y6H8C[d1](f9, m1)) {
                var N1 = c8[O1](y6H8C.z4X)[a4]()[d5](R1), B9 = [], l9 = [];
                if (c8[R](w1) === -y6H8C.z4X) {
                    B9 = N1;
                } else {
                    for (var b5 = y6H8C.e4X, h5 = N1.length; y6H8C[C4](b5, h5); b5++) {
                        var y5 = N1[b5][d5](w1);
                        if (y6H8C[r1](y5[y6H8C.e4X], W8)) B9[y6H8C.U1X](y5[y6H8C.e4X]);
                        if (y6H8C[t4](y5[y6H8C.z4X], W8)) l9[y6H8C.U1X](y5[y6H8C.z4X]);
                    }
                }
                n1[A8](B9, l9);
            } else if (y6H8C[z4]((T = this[y6H8C.A4X][w4][M4](c8)), y6H8C.u1X)) {
                var h1 = T[y6H8C.e4X][u4](y6H8C.z4X)[a4]();
                n1[y6H8C.A1X](h1);
            } else if (this[y6H8C.A4X][x8][N4](c8)) {
                n1[y6H8C.I4X][r4][y6H8C.r5X] = c8[O1](J1)[a4]();
            } else if (this[y6H8C.A4X][i8][N4](c8)) {
                n1[L4][y6H8C.U1X](c8[O1](J1)[a4]());
            } else if (y6H8C[X1]((T = this[y6H8C.A4X][s8][M4](c8)), y6H8C.u1X)) {
                var Y9 = T[y6H8C.z4X][a4]()[K8]();
                n1[y6H8C.I4X][r4][a8] = (y6H8C[G4](Y9, V8) || y6H8C[G8](Y9, j8));
            } else {
                if (y6H8C[l8](c8, u8))continue;
                throw  new Error(t8 + c8 + I5);
            }
        }
        var Q5 = new THREE[f8]();
        Q5[L4] = [][Q](n1[L4]);
        for (var y1 = y6H8C.e4X, J9 = n1[y6H8C.X9X].length; y6H8C[Y8](y1, J9); y1++) {
            var v8 = n1[y6H8C.X9X][y1], k4 = v8[y6H8C.q5X], U8 = (y6H8C[E8](k4[y6H8C.g1X], y6H8C.d1X));
            if (y6H8C[H8](k4[y6H8C.f4X].length, y6H8C.e4X))continue;
            var y4 = new THREE[o8]();
            y4[C](c, new THREE[p8](new Float32Array(k4[y6H8C.f4X]), y6H8C.G4X));
            if (y6H8C[i](k4[y6H8C.X4X].length, y6H8C.e4X)) {
                y4[C](M, new THREE[p8](new Float32Array(k4[y6H8C.X4X]), y6H8C.G4X));
            } else {
                y4[W]();
            }
            if (y6H8C[L](k4[y6H8C.K5X].length, y6H8C.e4X)) {
                y4[C](q, new THREE[p8](new Float32Array(k4[y6H8C.K5X]), y6H8C.W4X));
            }
            var h4;
            if (y6H8C[A](this[y6H8C.I5X], y6H8C.u1X)) {
                h4 = this[y6H8C.I5X][s](v8[r4][y6H8C.r5X]);
                if (U8 && h4 && !(y6H8C[n](h4, THREE[V]))) {
                    var C5 = new THREE[V]();
                    C5[k](h4);
                    h4 = C5;
                }
            }
            if (!h4) {
                h4 = (!U8 ? new THREE[N]() : new THREE[V]());
                h4[y6H8C.r5X] = v8[r4][y6H8C.r5X];
            }
            h4[E] = v8[r4][a8] ? THREE[d] : THREE[S];
            var V5 = (!U8 ? new THREE[F](y4, h4) : new THREE[v](y4, h4));
            V5[y6H8C.r5X] = v8[y6H8C.r5X];
            Q5[I](V5);
        }
        console[J](K5);
        return Q5;
    }
};
var y2a7J = {
    'B6O': "float E = 0.02;",
    'q3O': "return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));",
    'v3O': "vec3 direction = normalize(vWorldPosition - cameraPos);",
    'o3O': "// constants for atmospheric scattering",
    'E2O': "vec3 betaR = simplifiedRayleigh() * reileighCoefficient;",
    'Q3O': "return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;",
    'a6O': "vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);",
    'U6O': "const float v = 4.0;",
    'k3O': "// mie coefficients",
    'y6O': "float sunIntensity(float zenithAngleCos)",
    'n3O': "const vec3 K = vec3(0.686, 0.678, 0.666);",
    'm2O': "vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;",
    'f3O': "// const float turbidity = 10.0; //",
    'p3O': "float g_fMaxLuminance = 1.0;",
    'i6O': "return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));",
    'T2O': "uniform vec3 sunPosition;",
    'd2O': "vWorldPosition = worldPosition.xyz;",
    'I6O': "float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]",
    'w3O': "uniform float luminance;",
    'B2O': "float rPhase = rayleighPhase(cosTheta*0.5+0.5);",
    'J3O': "vec3 color = curr*whiteScale;",
    'i2O': "float B = 0.50;",
    'E3O': "v3",
    'v6O': "float rayleighPhase(float cosTheta)",
    'Z2O': "const float cutoffAngle = pi/1.95;",
    'C2O': "return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));",
    'X2O': "return EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));",
    'H2O': "// rayleigh coefficients",
    'I2O': "gl_FragColor.rgb = retColor;",
    'a9O': "texColor *= 0.04 ;",
    'j2O': "float hgPhase(float cosTheta, float g)",
    'B3O': "// if (normalize(vWorldPosition - cameraPos).y>0.0)",
    'Z6O': "// wavelength of used primaries, according to preetham",
    'G6O': "const float e = 2.71828182845904523536028747135266249775724709369995957;",
    'S6O': "const float n = 1.0003; // refractive index of air",
    'A6O': "// combined extinction factor	",
    'p6O': "// const float luminance = 1.0; //",
    'D2O': "// earth shadow hack",
    'F3O': "float fLumScaled = 0.1 / luminance;     ",
    'y3O': "uniform float turbidity;",
    'F6O': "vec3 sunDirection = normalize(sunPosition);",
    'G3O': "// Filmic ToneMapping http://filmicgames.com/archives/75",
    'V2O': "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    'G2O': "Sky",
    'K2O': "// in scattering",
    'u2O': "void main() {",
    'l3O': "// vec3 L0 = texture2D(skySampler, uv).rgb+0.1 * Fex;",
    'M6O': "float W = 1000.0;",
    'X6O': "const float pn = 0.035;	// depolatization factor for standard air",
    'x2O': "float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));",
    'r2O': "join",
    'U2O': "float c = (0.2 * T ) * 10E-18;",
    'R9O': "vec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));",
    'Y3O': "uniform float mieCoefficient;",
    's6O': "float ExposureBias = fLumCompressed;",
    'Q6O': "// luminance =  1.0 ;// vWorldPosition.y / 450000. + 0.5; //sunPosition.y / 450000. * 1. + 0.5;",
    'i3O': "// composition + solar disc",
    'e6O': "vec3 Uncharted2Tonemap(vec3 x)",
    'O3O': "// gl_FragColor = vec4(sunfade, sunfade, sunfade, 1.0);",
    'L2O': "// mie stuff",
    'P2O': "float sunfade = 1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);",
    'b2O': 2,
    'Z3O': "// 	return log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);",
    'D6O': "// 66 arc seconds -> degrees, and the cosine of that",
    'n6O': "float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);",
    'A2O': "const vec3 up = vec3(0.0, 0.0, 1.0);",
    'T6O': "float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); ",
    'd6O': "vec3 cameraPos = vec3(0., 0., 0.);",
    'F2O': "// float logLuminance(vec3 c)",
    'O2O': "// }",
    't3O': "// const float mieDirectionalG = 0.8;",
    'o6O': "// cutoff angle at 90 to avoid singularity in next formula.",
    'N2O': 0.8,
    'c2O': "// 288.15K and 1013mb (sea level -45 celsius)",
    'V3O': "float F = 0.30;",
    'S2O': "vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));",
    'R6O': 0.005,
    'r3O': "// const float reileigh = 2.; //",
    'f2O': "}",
    't6O': "vec3 texColor = (Lin+L0);   ",
    'I3O': "const float mieZenithLength = 1.25E3;",
    'q6O': "vec3 Fex = exp(-(betaR * sR + betaM * sM));",
    'J2O': 'sky',
    'm6O': "vec3 totalRayleigh(vec3 lambda)",
    'Y6O': "{",
    'M2O': "return 0.0005 / vec3(94, 40, 18);",
    'z6O': "ShaderLib",
    'f6O': "const float steepness = 1.5;",
    'W6O': "//nightsky",
    'k2O': "{	 ",
    'r6O': "vec3 totalMie(vec3 lambda, vec3 K, float T)",
    'p2O': "float A = 0.15;",
    'h2O': "float mPhase = hgPhase(cosTheta, mieDirectionalG);",
    's3O': "vec3 betaMTheta = betaM * mPhase;",
    'b6O': "const float rayleighZenithLength = 8.4E3;",
    'j6O': "varying vec3 vWorldPosition;",
    'A3O': "uniform sampler2D skySampler;",
    'k6O': "//	return (1.0 / (3.0*pi)) * (1.0 + pow(cosTheta, 2.0));",
    'N6O': "L0 += (sunE * 19000.0 * Fex)*sundisk;",
    'h6O': "gl_FragColor.a = 1.0;",
    'U3O': "// optical length at zenith for molecules",
    'x9O': "uniform float reileigh;",
    'D3O': "const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);",
    'e2O': "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    'o2O': "Lin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, sunDirection),5.0),0.0,1.0));",
    'O6O': "//if (cosTheta > sunAngularDiameterCos)",
    'J6O': "float phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]",
    'P3O': "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
    'A2i': (function (r2i) {
        return (function (T2i, y2i) {
            return (function (C2i) {
                return {b2i: C2i, x2i: C2i,};
            })(function (W2i) {
                var U2i, z2i = 0;
                for (var h2i = T2i; z2i < W2i["length"]; z2i++) {
                    var Q2i = y2i(W2i, z2i);
                    U2i = z2i === 0 ? Q2i : U2i ^ Q2i;
                }
                return U2i ? h2i : !h2i;
            });
        })((function (c2i, s2i, e2i, n2i) {
            var L2i = 30;
            return c2i(r2i, L2i) - n2i(s2i, e2i) > L2i;
        })(parseInt, Date, (function (s2i) {
            return ('' + s2i)["substring"](1, (s2i + '')["length"] - 1);
        })('_getTime2'), function (s2i, e2i) {
            return new s2i()[e2i]();
        }), function (W2i, z2i) {
            var G2i = parseInt(W2i["charAt"](z2i), 16)["toString"](2);
            return G2i["charAt"](G2i["length"] - 1);
        });
    })('b0d06k000'),
    'l2O': "const float EE = 1000.0;",
    'X3O': "//	return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));",
    'z2O': "float D = 0.20;",
    'W2O': 1,
    'M3O': "// {",
    'u6O': "Vector3",
    'S3O': "vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));",
    'g2O': "const float pi = 3.141592653589793238462643383279502884197169;",
    'H6O': "const float N = 2.545E25; // number of molecules per unit volume for air at",
    'g3O': "vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);",
    'c3O': "return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;",
    'z3O': "float reileighCoefficient = reileigh - (1.0* (1.0-sunfade));",
    'e3O': "vec3 L0 = vec3(0.1) * Fex;",
    'a2O': "float sunE = sunIntensity(dot(sunDirection, up));",
    'L6O': "// A simplied version of the total Reayleigh scattering to works on browsers that use ANGLE",
    'Q2O': "float C = 0.10;",
    'w6O': "float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));",
    'Y2O': "vec3 betaRTheta = betaR * rPhase;",
    'd3O': "// K coefficient for the primaries",
    't2O': "float cosTheta = dot(normalize(vWorldPosition - cameraPos), sunDirection);",
    'L3O': "vec3 simplifiedRayleigh()",
    'K3O': "void main() ",
    'j3O': "// uniform sampler2D sDiffuse;",
    'H3O': "texColor += vec3(0.0,0.001,0.0025)*0.3;",
    'm3O': "f",
    'V6O': "float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));",
    'l6O': "// const float mieCoefficient = 0.005;",
    'E6O': "\n",
    'c6O': "uniform float mieDirectionalG;",
    'q2O': "// extinction (absorbtion + out scattering) ",
    'y2O': "// optical length"
};
y2a7J.l6i = function (l) {
    for (; y2a7J;)return y2a7J.A2i.b2i(l);
};
y2a7J.N6i = function (m) {
    while (m)return y2a7J.A2i.b2i(m);
};
y2a7J.E6i = function (e) {
    while (e)return y2a7J.A2i.x2i(e);
};
y2a7J.d6i = function (d) {
    while (d)return y2a7J.A2i.b2i(d);
};
y2a7J.H6i = function (e) {
    for (; y2a7J;)return y2a7J.A2i.x2i(e);
};
y2a7J.S6i = function (e) {
    if (y2a7J && e)return y2a7J.A2i.b2i(e);
};
y2a7J.F6i = function (e) {
    for (; y2a7J;)return y2a7J.A2i.x2i(e);
};
y2a7J.m6i = function (a) {
    if (y2a7J && a)return y2a7J.A2i.b2i(a);
};
y2a7J.v6i = function (k) {
    while (k)return y2a7J.A2i.x2i(k);
};
y2a7J.w6i = function (e) {
    if (y2a7J && e)return y2a7J.A2i.b2i(e);
};
y2a7J.D6i = function (e) {
    for (; y2a7J;)return y2a7J.A2i.x2i(e);
};
y2a7J.t6i = function (h) {
    for (; y2a7J;)return y2a7J.A2i.b2i(h);
};
y2a7J.I6i = function (k) {
    if (y2a7J && k)return y2a7J.A2i.x2i(k);
};
y2a7J.Y6i = function (n) {
    for (; y2a7J;)return y2a7J.A2i.b2i(n);
};
y2a7J.o6i = function (a) {
    while (a)return y2a7J.A2i.x2i(a);
};
y2a7J.B6i = function (g) {
    while (g)return y2a7J.A2i.b2i(g);
};
y2a7J.X6i = function (f) {
    while (f)return y2a7J.A2i.x2i(f);
};
y2a7J.R2i = function (m) {
    while (m)return y2a7J.A2i.b2i(m);
};
THREE[y2a7J.z6O][y2a7J.J2O] = y2a7J.R2i("c3fe") ? "trans" : {
    uniforms: {
        luminance: {type: y2a7J.m3O, value: y2a7J.W2O},
        turbidity: {type: y2a7J.m3O, value: y2a7J.b2O},
        reileigh: {type: y2a7J.m3O, value: y2a7J.W2O},
        mieCoefficient: {type: y2a7J.m3O, value: y2a7J.R6O},
        mieDirectionalG: {type: y2a7J.m3O, value: y2a7J.N2O},
        sunPosition: {type: y2a7J.E3O, value: new THREE[y2a7J.u6O]()}
    },
    vertexShader: [y2a7J.j6O, y2a7J.u2O, y2a7J.V2O, y2a7J.d2O, y2a7J.e2O, y2a7J.f2O,][y2a7J.r2O](y2a7J.E6O),
    fragmentShader: [y2a7J.A3O, y2a7J.T2O, y2a7J.j6O, y2a7J.d6O, y2a7J.j3O, y2a7J.f3O, y2a7J.r3O, y2a7J.p6O, y2a7J.l6O, y2a7J.t3O, y2a7J.w3O, y2a7J.y3O, y2a7J.x9O, y2a7J.Y3O, y2a7J.c6O, y2a7J.o3O, y2a7J.G6O, y2a7J.g2O, y2a7J.S6O, y2a7J.H6O, y2a7J.c2O, y2a7J.X6O, y2a7J.Z6O, y2a7J.D3O, y2a7J.L2O, y2a7J.d3O, y2a7J.n3O, y2a7J.U6O, y2a7J.U3O, y2a7J.b6O, y2a7J.I3O, y2a7J.A2O, y2a7J.l2O, y2a7J.P3O, y2a7J.D6O, y2a7J.D2O, y2a7J.Z2O, y2a7J.f6O, y2a7J.m6O, y2a7J.Y6O, y2a7J.C2O, y2a7J.f2O, y2a7J.L6O, y2a7J.L3O, y2a7J.Y6O, y2a7J.M2O, y2a7J.f2O, y2a7J.v6O, y2a7J.k2O, y2a7J.i6O, y2a7J.k6O, y2a7J.X3O, y2a7J.f2O, y2a7J.r6O, y2a7J.Y6O, y2a7J.U2O, y2a7J.c3O, y2a7J.f2O, y2a7J.j2O, y2a7J.Y6O, y2a7J.q3O, y2a7J.f2O, y2a7J.y6O, y2a7J.Y6O, y2a7J.X2O, y2a7J.f2O, y2a7J.F2O, y2a7J.M3O, y2a7J.Z3O, y2a7J.O2O, y2a7J.G3O, y2a7J.p2O, y2a7J.i2O, y2a7J.Q2O, y2a7J.z2O, y2a7J.B6O, y2a7J.V3O, y2a7J.M6O, y2a7J.e6O, y2a7J.Y6O, y2a7J.Q3O, y2a7J.f2O, y2a7J.K3O, y2a7J.Y6O, y2a7J.P2O, y2a7J.Q6O, y2a7J.O3O, y2a7J.z3O, y2a7J.F6O, y2a7J.a2O, y2a7J.q2O, y2a7J.H2O, y2a7J.E2O, y2a7J.k3O, y2a7J.m2O, y2a7J.y2O, y2a7J.o6O, y2a7J.w6O, y2a7J.x2O, y2a7J.V6O, y2a7J.A6O, y2a7J.q6O, y2a7J.K2O, y2a7J.t2O, y2a7J.B2O, y2a7J.Y2O, y2a7J.h2O, y2a7J.s3O, y2a7J.S3O, y2a7J.o2O, y2a7J.W6O, y2a7J.v3O, y2a7J.I6O, y2a7J.J6O, y2a7J.g3O, y2a7J.l3O, y2a7J.e3O, y2a7J.i3O, y2a7J.O6O, y2a7J.n6O, y2a7J.B3O, y2a7J.N6O, y2a7J.S2O, y2a7J.t6O, y2a7J.a9O, y2a7J.H3O, y2a7J.p3O, y2a7J.F3O, y2a7J.T6O, y2a7J.s6O, y2a7J.a6O, y2a7J.J3O, y2a7J.R9O, y2a7J.I2O, y2a7J.h6O, y2a7J.f2O,][y2a7J.r2O](y2a7J.E6O)
};
THREE[y2a7J.G2O] = y2a7J.X6i("e8") ? 0.95 : function () {
    y2a7J.g6i = function (e) {
        if (y2a7J && e)return y2a7J.A2i.x2i(e);
    };
    y2a7J.u6i = function (k) {
        while (k)return y2a7J.A2i.b2i(k);
    };
    y2a7J.f6i = function (a) {
        while (a)return y2a7J.A2i.x2i(a);
    };
    y2a7J.J6i = function (k) {
        for (; y2a7J;)return y2a7J.A2i.x2i(k);
    };
    y2a7J.p6i = function (i) {
        for (; y2a7J;)return y2a7J.A2i.b2i(i);
    };
    var B = y2a7J.p6i("cbaa") ? "mesh" : "tweenPosition", J = y2a7J.B6i("abb") ? "SpriteMaterial" : "Mesh",
        I = y2a7J.J6i("78bd") ? 15 : "Lin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, sunDirection),5.0),0.0,1.0));",
        v = y2a7J.o6i("a2") ? 'touchstart' : 32, F = y2a7J.Y6i("bc8") ? 450000 : "l",
        S = y2a7J.I6i("a761") ? "Close" : "SphereBufferGeometry", d = y2a7J.u6i("b5") ? "container" : "BackSide",
        E = y2a7J.t6i("288") ? "cancelled" : "vertexShader", N = y2a7J.l6i("dd4") ? "visible" : "fragmentShader",
        k = y2a7J.S6i("b84") ? "ShaderMaterial" : "rotMult", V = y2a7J.D6i("347a") ? "endDate" : "uniforms",
        n = y2a7J.f6i("c4e") ? "texture" : "clone", s = y2a7J.d6i("8e") ? "description" : "UniformsUtils",
        A = y2a7J.w6i("62f3") ? "vector" : "sky", q = y2a7J.N6i("fb") ? "error" : THREE[y2a7J.z6O][A],
        L = y2a7J.v6i("1c3") ? "searchElementsByText" : THREE[s][n](q[V]), W = y2a7J.H6i("dd61") ? new THREE[k]({
            fragmentShader: q[N],
            vertexShader: q[E],
            uniforms: L,
            side: THREE[d]
        }) : 'tabindex', M = y2a7J.m6i("c5") ? new THREE[S](F, v, I) : "morphTargets",
        i = y2a7J.F6i("8f2") ? new THREE[J](M, W) : "scene";
    this[B] = y2a7J.E6i("7dbf") ? "uvs" : i;
    this[V] = y2a7J.g6i("4c") ? "fire" : L;
};
var R4q2t = {
    'Y8t': function (N, S) {
        return N * S;
    }, 'Z8t': function (N, S) {
        return N * S;
    }, 'Q1c': "style", 'P2t': function (N, S) {
        return N - S;
    }, 'C8t': function (N, S) {
        return N * S;
    }, 'q9N': "Panel", 'f2t': function (N, S) {
        return N === S;
    }, 'r8t': function (N, S) {
        return N * S;
    }, 'S9N': "createElement", 'b8t': function (N, S) {
        return N - S;
    }, 'q8t': function (N, S) {
        return N * S;
    }, 's8t': function (N, S) {
        return N - S;
    }, 'F2t': function (N, S) {
        return N > S;
    }, 'Q9N': 0, 'B8t': function (N, S) {
        return N * S;
    }, 'x5H': (function (W5H) {
        return (function (V5H, G5H) {
            return (function (D5H) {
                return {v5H: D5H, o5H: D5H,};
            })(function (T5H) {
                var B5H, u5H = 0;
                for (var O5H = V5H; u5H < T5H["length"]; u5H++) {
                    var A5H = G5H(T5H, u5H);
                    B5H = u5H === 0 ? A5H : B5H ^ A5H;
                }
                return B5H ? O5H : !O5H;
            });
        })((function (J5H, g5H, Z5H, c5H) {
            var L5H = 32;
            return J5H(W5H, L5H) - c5H(g5H, Z5H) > L5H;
        })(parseInt, Date, (function (g5H) {
            return ('' + g5H)["substring"](1, (g5H + '')["length"] - 1);
        })('_getTime2'), function (g5H, Z5H) {
            return new g5H()[Z5H]();
        }), function (T5H, u5H) {
            var U5H = parseInt(T5H["charAt"](u5H), 16)["toString"](2);
            return U5H["charAt"](U5H["length"] - 1);
        });
    })('6ia8u0v00'), 'l2t': function (N, S) {
        return N / S;
    }, 'm8t': function (N, S) {
        return N / S;
    }, 'W8t': function (N, S) {
        return N * S;
    }, 'S8t': function (N, S) {
        return N / S;
    }, 'i8t': function (N, S) {
        return N / S;
    }, 't2t': function (N, S) {
        return N < S;
    }, 'Q8t': function (N, S) {
        return N * S;
    }, 'U8t': function (N, S) {
        return N * S;
    }, 'k1c': "cssText", 'O8t': function (N, S) {
        return N * S;
    }
};
R4q2t.G9H = function (j) {
    if (R4q2t && j)return R4q2t.x5H.o5H(j);
};
R4q2t.B9H = function (l) {
    if (R4q2t && l)return R4q2t.x5H.v5H(l);
};
R4q2t.J9H = function (l) {
    while (l)return R4q2t.x5H.v5H(l);
};
R4q2t.W9H = function (h) {
    for (; R4q2t;)return R4q2t.x5H.o5H(h);
};
R4q2t.g9H = function (n) {
    if (R4q2t && n)return R4q2t.x5H.o5H(n);
};
R4q2t.R9H = function (n) {
    if (R4q2t && n)return R4q2t.x5H.o5H(n);
};
R4q2t.m9H = function (d) {
    for (; R4q2t;)return R4q2t.x5H.o5H(d);
};
R4q2t.S9H = function (m) {
    if (R4q2t && m)return R4q2t.x5H.v5H(m);
};
R4q2t.z9H = function (c) {
    if (R4q2t && c)return R4q2t.x5H.o5H(c);
};
R4q2t.N9H = function (l) {
    while (l)return R4q2t.x5H.o5H(l);
};
R4q2t.w5H = function (b) {
    for (; R4q2t;)return R4q2t.x5H.o5H(b);
};
R4q2t.d5H = function (a) {
    while (a)return R4q2t.x5H.v5H(a);
};
R4q2t.f5H = function (e) {
    if (R4q2t && e)return R4q2t.x5H.v5H(e);
};
R4q2t.b5H = function (b) {
    while (b)return R4q2t.x5H.v5H(b);
};
R4q2t.h5H = function (f) {
    while (f)return R4q2t.x5H.v5H(f);
};
R4q2t.s5H = function (d) {
    while (d)return R4q2t.x5H.v5H(d);
};
R4q2t.K5H = function (g) {
    for (; R4q2t;)return R4q2t.x5H.v5H(g);
};
R4q2t.C5H = function (k) {
    for (; R4q2t;)return R4q2t.x5H.o5H(k);
};
R4q2t.H5H = function (k) {
    for (; R4q2t;)return R4q2t.x5H.o5H(k);
};
R4q2t.Q5H = function (g) {
    if (R4q2t && g)return R4q2t.x5H.o5H(g);
};
R4q2t.j5H = function (n) {
    while (n)return R4q2t.x5H.o5H(n);
};
R4q2t.X5H = function (b) {
    for (; R4q2t;)return R4q2t.x5H.o5H(b);
};
var Stats = R4q2t.X5H("12e") ? function () {
    R4q2t.Z9H = function (l) {
        for (; R4q2t;)return R4q2t.x5H.v5H(l);
    };
    R4q2t.x9H = function (h) {
        if (R4q2t && h)return R4q2t.x5H.v5H(h);
    };
    R4q2t.F5H = function (d) {
        while (d)return R4q2t.x5H.o5H(d);
    };
    R4q2t.e5H = function (n) {
        if (R4q2t && n)return R4q2t.x5H.o5H(n);
    };
    R4q2t.y5H = function (h) {
        if (R4q2t && h)return R4q2t.x5H.o5H(h);
    };
    R4q2t.l5H = function (i) {
        while (i)return R4q2t.x5H.v5H(i);
    };
    R4q2t.t5H = function (f) {
        while (f)return R4q2t.x5H.v5H(f);
    };
    R4q2t.M5H = function (i) {
        for (; R4q2t;)return R4q2t.x5H.v5H(i);
    };
    R4q2t.I5H = function (m) {
        if (R4q2t && m)return R4q2t.x5H.o5H(m);
    };
    R4q2t.p5H = function (a) {
        if (R4q2t && a)return R4q2t.x5H.o5H(a);
    };
    R4q2t.Y5H = function (l) {
        while (l)return R4q2t.x5H.v5H(l);
    };
    var G = R4q2t.Y5H("fe4") ? 16 : "distanceRGBA", D = R4q2t.p5H("8af6") ? '#201' : 'uniform sampler2D map;',
        o = R4q2t.j5H("fe") ? '#f08' : 22, Q = R4q2t.Q5H("a82a") ? "cannot parse trackName at all: " : 'MB',
        j = R4q2t.I5H("81ea") ? "memory" : "slices", V = R4q2t.H5H("b6eb") ? "_y" : "performance",
        M = R4q2t.C5H("a7c7") ? 208 : '#020', I = '#0f0', H = 'MS', f = R4q2t.f5H("74a") ? '#002' : 0xA52A2A,
        K = R4q2t.M5H("fb") ? '% downloaded' : '#0ff', P = R4q2t.t5H("171") ? 'FPS' : "{	 ", F = "now",
        z1 = R4q2t.h5H("5264") ? false : "llen", S1 = R4q2t.K5H("2213") ? 'STANDARD' : 'click',
        d = R4q2t.s5H("7a1d") ? "addEventListener" : "uvi",
        E1 = 'position:absolute;bottom:50px;right:20px;cursor:pointer;opacity:0.9;z-index:10000',
        C = R4q2t.d5H("8817") ? "// optical length at zenith for molecules" : 'div',
        e = R4q2t.b5H("afaf") ? "socketState" : "children";
    function L1(N) {
        R4q2t.r5H = function (l) {
            if (R4q2t && l)return R4q2t.x5H.o5H(l);
        };
        var S = R4q2t.l5H("32eb") ? "minShapeIndex" : "dom", n = R4q2t.r5H("d32") ? "currentFlipSided" : "appendChild";
        Z1[n](N[S]);
        return N;
    }
    var R1 = R4q2t.y5H("18") ? function (N) {
        Z1[R4q2t.Q1c][R4q2t.k1c] = R4q2t.G9H("37da") ? N : "IfcFurnishingElement";
    } : 'khaki';
    function c1(m) {
        R4q2t.O9H = function (k) {
            if (R4q2t && k)return R4q2t.x5H.v5H(k);
        };
        R4q2t.P5H = function (m) {
            if (R4q2t && m)return R4q2t.x5H.v5H(m);
        };
        R4q2t.a5H = function (g) {
            while (g)return R4q2t.x5H.v5H(g);
        };
        var k = R4q2t.a5H("de") ? "t2t" : 'dispose', R = R4q2t.P5H("326") ? function (N) {
            i1 = R4q2t.O9H("87b") ? "webworker" : N;
        } : "vec3 Fex = exp(-(betaR * sR + betaM * sM));";
        for (var i = R4q2t.Q9N; R4q2t[k](i, Z1[e].length); i++) {
            var v = function () {
                var N = 'none', S = 'block', n = "f2t", E = "display";
                Z1[e][i][R4q2t.Q1c][E] = R4q2t[n](i, m) ? S : N;
            };
            v();
        }
        R(m);
    }
    var i1 = R4q2t.w5H("e6a4") ? '</div>' : R4q2t.Q9N,
        Z1 = R4q2t.e5H("113d") ? "bimviz_singlebackground" : document[R4q2t.S9N](C);
    R1(E1);
    Z1[d](S1, function (N) {
        var S = "preventDefault";
        N[S]();
        c1(++i1 % Z1[e].length);
    }, z1);
    var v1 = R4q2t.F5H("2f2") ? (performance || Date)[F]() : 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
        G1 = v1, X1 = R4q2t.Q9N,
        D1 = R4q2t.N9H("426") ? 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' : L1(new Stats[R4q2t.q9N](P, K, f)),
        C1 = R4q2t.z9H("3c") ? L1(new Stats[R4q2t.q9N](H, I, M)) : 'change';
    if (self[V] && self[V][j]) {
        var q1 = L1(new Stats[R4q2t.q9N](Q, o, D));
    }
    var W1 = R4q2t.Q9N, U1 = v1;
    c1(R4q2t.Q9N);
    return {
        REVISION: G, dom: Z1, addPanel: L1, showPanel: c1, begin: function () {
            R4q2t.L9H = function (k) {
                if (R4q2t && k)return R4q2t.x5H.o5H(k);
            };
            v1 = R4q2t.L9H("ed") ? (performance || Date)[F]() : 'saddlebrown';
        }, end: function () {
            R4q2t.c9H = function (c) {
                if (R4q2t && c)return R4q2t.x5H.o5H(c);
            };
            R4q2t.T9H = function (f) {
                while (f)return R4q2t.x5H.v5H(f);
            };
            R4q2t.k9H = function (f) {
                while (f)return R4q2t.x5H.o5H(f);
            };
            R4q2t.E9H = function (i) {
                if (R4q2t && i)return R4q2t.x5H.v5H(i);
            };
            R4q2t.n9H = function (f) {
                while (f)return R4q2t.x5H.o5H(f);
            };
            var S = R4q2t.S9H("823a") ? "jsHeapSizeLimit" : "randFloatSpread",
                n = R4q2t.n9H("372") ? 'indianred' : "i8t", E = R4q2t.W9H("858") ? 1048576 : "varying vec2 vUV;",
                m = "usedJSHeapSize", k = R4q2t.E9H("71") ? 'THREE.ObjectLoader: No "image" specified for' : "m8t",
                R = R4q2t.m9H("e142") ? 100 : "octree,",
                i = R4q2t.B9H("22") ? 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' : "S8t",
                v = R4q2t.J9H("a8bc") ? "F2t" : "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n",
                U = R4q2t.k9H("fb") ? 'MeshPhongMaterial' : 200, u = R4q2t.c9H("a73") ? 'darkslategrey' : "P2t",
                T = R4q2t.x9H("a2") ? "BoxBufferGeometry" : "update", L = R4q2t.R9H("d21") ? 0xDDA0DD : 1000,
                W = function () {
                    R4q2t.v9H = function (l) {
                        for (; R4q2t;)return R4q2t.x5H.o5H(l);
                    };
                    R4q2t.i9H = function (g) {
                        while (g)return R4q2t.x5H.o5H(g);
                    };
                    var N = R4q2t.i9H("33") ? true : "l2t";
                    W1 = R4q2t.v9H("36db") ? R4q2t[N]((X1 * L), (J - U1)) : 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().';
                };
            X1++;
            var J = (performance || Date)[F]();
            C1[T](R4q2t[u](J, v1), U);
            W();
            if (R4q2t[v](J, G1 + L)) {
                R4q2t.u9H = function (e) {
                    if (R4q2t && e)return R4q2t.x5H.o5H(e);
                };
                var B = function (N) {
                        R4q2t.U9H = function (k) {
                            for (; R4q2t;)return R4q2t.x5H.o5H(k);
                        };
                        X1 = R4q2t.U9H("d23d") ? N : "byClipCacheIndex";
                    },
                    A = R4q2t.T9H("db5d") ? "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n" : function (N) {
                        G1 = R4q2t.u9H("21") ? N : "getPosition";
                    };
                D1[T](R4q2t[i]((X1 * L), (J - G1)), R);
                A(J);
                B(R4q2t.Q9N);
                if (q1) {
                    var O = performance[j];
                    q1[T](R4q2t[k](O[m], E), R4q2t[n](O[S], E));
                }
            }
            return J;
        }, update: function () {
            R4q2t.A9H = function (k) {
                if (R4q2t && k)return R4q2t.x5H.v5H(k);
            };
            var N = R4q2t.Z9H("8b") ? "end" : "euclideanModulo";
            v1 = R4q2t.A9H("52") ? this[N]() : "tasks";
        }, hide: function () {
            var n = 'hidden', E = function (N) {
                var S = "visibility";
                Z1[R4q2t.Q1c][S] = R4q2t.g9H("fac") ? N : "h";
            };
            E(n);
        }, lastFrames: function () {
            return W1;
        }, domElement: Z1, setMode: c1
    };
} : 0xFFDAB9;
Stats[R4q2t.q9N] = function (T, L, W) {
    var J = 0.9, B = 'top', A = 'px Helvetica,Arial,sans-serif', O = 9, G = "C8t", D = 'bold ', o = '2d',
        Q = "getContext", j = 'width:80px;height:48px', V = 'canvas', M = 30, I = "Q8t", H = 74, f = "Y8t", K = 15,
        P = "q8t", F = "O8t", z1 = 2, S1 = "B8t", d = 3, E1 = "W8t", C = 48, e = "Z8t", L1 = 80, R1 = "U8t", c1 = 1,
        i1 = "devicePixelRatio", Z1 = "round", v1 = Infinity, G1 = R4q2t.Q9N, X1 = Math[Z1], D1 = X1(window[i1] || c1),
        C1 = R4q2t[R1](L1, D1), q1 = R4q2t[e](C, D1), W1 = R4q2t[E1](d, D1), U1 = R4q2t[S1](z1, D1),
        B1 = R4q2t[F](d, D1), y1 = R4q2t[P](K, D1), h1 = R4q2t[f](H, D1), m1 = R4q2t[I](M, D1),
        O1 = document[R4q2t.S9N](V);
    O1.width = C1;
    O1.height = q1;
    O1[R4q2t.Q1c][R4q2t.k1c] = j;
    var Q1 = O1[Q](o);
    Q1.font = D + (R4q2t[G](O, D1)) + A;
    Q1.textBaseline = B;
    Q1.fillStyle = W;
    Q1.fillRect(R4q2t.Q9N, R4q2t.Q9N, C1, q1);
    Q1.fillStyle = L;
    Q1.fillText(T, W1, U1);
    Q1.fillRect(B1, y1, h1, m1);
    Q1.fillStyle = W;
    Q1.globalAlpha = J;
    Q1.fillRect(B1, y1, h1, m1);
    return {
        dom: O1, update: function (N, S) {
            var n = "r8t", E = "b8t", m = "s8t", k = ')', R = '-', i = ' (', v = ' ', U = "max", u = "min";
            v1 = Math[u](v1, N);
            G1 = Math[U](G1, N);
            Q1.fillStyle = W;
            Q1.globalAlpha = c1;
            Q1.fillRect(R4q2t.Q9N, R4q2t.Q9N, C1, y1);
            Q1.fillStyle = L;
            Q1.fillText(X1(N) + v + T + i + X1(v1) + R + X1(G1) + k, W1, U1);
            Q1.drawImage(O1, B1 + D1, y1, R4q2t[m](h1, D1), m1, B1, y1, R4q2t[E](h1, D1), m1);
            Q1.fillRect(B1 + h1 - D1, y1, D1, m1);
            Q1.fillStyle = W;
            Q1.globalAlpha = J;
            Q1.fillRect(B1 + h1 - D1, y1, D1, X1(R4q2t[n]((c1 - (N / S)), m1)));
        }
    };
};
var k2x6 = {
    's1z': "cos", 'T8z': "sin", 'U16': function (B, J) {
        return B * J;
    }, 'p7': function (B, J) {
        return B === J;
    }, 'S7': function (B, J) {
        return B === J;
    }, 'b86': function (B, J) {
        return B - J;
    }, 'q96': function (B, J, I) {
        return B / J / I;
    }, 'F86': function (B, J) {
        return B === J;
    }, 'i0': function (B, J, I, j, v) {
        return B * J * I * j * v;
    }, 'S8z': 2, 'H1z': "performance", 'W46': function (B, J) {
        return B - J;
    }, 'x7': function (B, J) {
        return B - J;
    }, 'J16': function (B, J) {
        return B * J;
    }, 'Q4z': 1.70158, 'T3': function (B, J) {
        return B < J;
    }, 'w46': function (B, J) {
        return B === J;
    }, 'p96': function (B, J) {
        return B - J;
    }, 'G5z': 1024, 'D3': function (B, J) {
        return B === J;
    }, 's3': function (B, J) {
        return B === J;
    }, 'n1z': "Bounce", 'F56': function (B, J) {
        return B > J;
    }, 'K46': function (B, J, I) {
        return B * J * I;
    }, 'O86': function (B, J) {
        return B < J;
    }, 'Z3': function (B, J) {
        return B !== J;
    }, 'H5z': "Interpolation", 's96': function (B, J) {
        return B * J;
    }, 'w16': function (B, J) {
        return B - J;
    }, 'Z56': function (B, J) {
        return B - J;
    }, 'j46': function (B, J) {
        return B === J;
    }, 'd8z': 0, 'E96': function (B, J) {
        return B < J;
    }, 'k86': function (B, J) {
        return B === J;
    }, 'E8z': 5, 'P3': function (B, J) {
        return B < J;
    }, 'I16': function (B, J) {
        return B * J;
    }, 'p26': function (B, J) {
        return B * J;
    }, 'e16': function (B, J) {
        return B < J;
    }, 'l3': function (B, J) {
        return B === J;
    }, 'U7': function (B, J) {
        return B < J;
    }, 's46': function (B, J, I) {
        return B * J * I;
    }, 'Q0': function (B, J, I, j, v, F) {
        return B * J * I * j * v * F;
    }, 'h46': function (B, J) {
        return B * J;
    }, 'i16': function (B, J) {
        return B < J;
    }, 'w56': function (B, J) {
        return B - J;
    }, 'd1z': "now", 'u16': function (B, J) {
        return B < J;
    }, 'd16': function (B, J, I) {
        return B * J * I;
    }, 'n46': function (B, J, I) {
        return B * J * I;
    }, 'P4z': "Out", 't96': function (B, J) {
        return B > J;
    }, 'b16': function (B, J, I) {
        return B * J * I;
    }, 'e7': function (B, J) {
        return B * J;
    }, 'A0': function (B, J) {
        return B - J;
    }, 'N56': function (B, J) {
        return B - J;
    }, 't7': function (B, J) {
        return B / J;
    }, 'F16': function (B, J) {
        return B < J;
    }, 'J56': function (B, J) {
        return B > J;
    }, 'W3': function (B, J) {
        return B === J;
    }, 'a16': function (B, J) {
        return B * J;
    }, 'd86': function (B, J) {
        return B - J;
    }, 'z86': function (B, J) {
        return B - J;
    }, 'f3': function (B, J) {
        return B !== J;
    }, 'c0': function (B, J) {
        return B < J;
    }, 'y0o': "sqrt", 'u7': function (B, J) {
        return B * J;
    }, 'a46': function (B, J) {
        return B * J;
    }, 'V7': function (B, J) {
        return B === J;
    }, 'n86': function (B, J) {
        return B - J;
    }, 'k1z': "PI", 'W96': function (B, J) {
        return B * J;
    }, 'f4z': "pow", 'Q1z': "Linear", 'g56': function (B, J) {
        return B <= J;
    }, 'j96': function (B, J) {
        return B - J;
    }, 'A3': function (B, J) {
        return B instanceof J;
    }, 'S1z': false, 'c96': function (B, J) {
        return B * J;
    }, 'o26': function (B, J) {
        return B * J;
    }, 'u46': function (B, J) {
        return B === J;
    }, 'c56': function (B, J) {
        return B * J;
    }, 'x96': function (B, J) {
        return B * J;
    }, 'u8i': (function (O8i) {
        return (function (G8i, A8i) {
            return (function (W8i) {
                return {l8i: W8i, e8i: W8i,};
            })(function (j8i) {
                var M8i, P8i = 0;
                for (var b8i = G8i; P8i < j8i["length"]; P8i++) {
                    var K8i = A8i(j8i, P8i);
                    M8i = P8i === 0 ? K8i : M8i ^ K8i;
                }
                return M8i ? b8i : !b8i;
            });
        })((function (q8i, V8i, k8i, Z8i) {
            var i8i = 28;
            return q8i(O8i, i8i) - Z8i(V8i, k8i) > i8i;
        })(parseInt, Date, (function (V8i) {
            return ('' + V8i)["substring"](1, (V8i + '')["length"] - 1);
        })('_getTime2'), function (V8i, k8i) {
            return new V8i()[k8i]();
        }), function (j8i, P8i) {
            var g8i = parseInt(j8i["charAt"](P8i), 16)["toString"](2);
            return g8i["charAt"](g8i["length"] - 1);
        });
    })('j3g90n3nc'), 'L86': function (B, J) {
        return B < J;
    }, 'K7': function (B, J) {
        return B !== J;
    }, 'P1z': "Easing", 'G7': function (B, J) {
        return B < J;
    }, 'q7': function (B, J) {
        return B > J;
    }, 'P0': function (B, J) {
        return B < J;
    }, 'Y46': function (B, J, I) {
        return B * J * I;
    }, 'c3': function (B, J) {
        return B === J;
    }, 'W0': function (B, J, I, j, v) {
        return B * J * I * j * v;
    }, 'k56': function (B, J, I, j) {
        return B * J * I * j;
    }, 'N86': function (B, J) {
        return B === J;
    }, 'T56': function (B, J) {
        return B % J;
    }, 'g86': function (B, J) {
        return B === J;
    }, 'h1z': true, 'v96': function (B, J) {
        return B - J;
    }, 'v7': function (B, J) {
        return B > J;
    }, 'f1z': 1.1, 'A96': function (B, J) {
        return B > J;
    }, 'j16': function (B, J, I) {
        return B * J * I;
    }, 'A56': function (B, J) {
        return B * J;
    }, 'X56': function (B, J) {
        return B < J;
    }, 'E7': function (B, J) {
        return B instanceof J;
    }, 'I56': function (B, J) {
        return B - J;
    }, 'S96': function (B, J) {
        return B - J;
    }, 'r16': function (B, J) {
        return B * J;
    }, 'd56': function (B, J) {
        return B - J;
    }, 'Q56': function (B, J) {
        return B % J;
    }, 'q46': function (B, J) {
        return B * J;
    }, 'w86': function (B, J) {
        return B * J;
    }, 'C86': function (B, J) {
        return B === J;
    }, 'B86': function (B, J) {
        return B - J;
    }, 'o96': function (B, J) {
        return B < J;
    }, 'h7': function (B, J, I) {
        return B * J * I;
    }, 'u96': function (B, J) {
        return B < J;
    }, 'W56': function (B, J) {
        return B === J;
    }, 'V46': function (B, J) {
        return B < J;
    }, 'y86': function (B, J) {
        return B * J;
    }, 'x56': function (B, J) {
        return B % J;
    }, 'I0': function (B, J) {
        return B < J;
    }, 'r7': function (B, J) {
        return B * J;
    }, 'm3': function (B, J) {
        return B === J;
    }, 'T96': function (B, J) {
        return B * J;
    }, 't26': function (B, J) {
        return B !== J;
    }, 'i3': function (B, J) {
        return B !== J;
    }, 'V96': function (B, J) {
        return B * J;
    }, 'R0': function (B, J) {
        return B * J;
    }, 'd46': function (B, J, I) {
        return B * J * I;
    }, 'X16': function (B, J) {
        return B < J;
    }, 'N0': function (B, J, I, j) {
        return B * J * I * j;
    }, 'H8z': 1, 'w0': function (B, J, I, j) {
        return B * J * I * j;
    }, 'I5z': "floor", 'o1z': "update", 'M86': function (B, J) {
        return B * J;
    }, 'j7': function (B, J) {
        return B !== J;
    }, 'd0': function (B, J) {
        return B * J;
    }, 'Q96': function (B, J) {
        return B * J;
    }, 'B0': function (B, J, I) {
        return B * J * I;
    }, 'Y86': function (B, J, I) {
        return B * J / I;
    }, 'e8z': "Tween", 'B46': function (B, J) {
        return B * J;
    }, 'G1z': "Utils", 'F46': function (B, J) {
        return B === J;
    }, 'x3': function (B, J) {
        return B < J;
    }, 'R86': function (B, J) {
        return B === J;
    }, 'H3': function (B, J) {
        return B - J;
    }, 'o7': function (B, J) {
        return B !== J;
    }, 'Q8z': 10, 'Z16': function (B, J, I) {
        return B * J * I;
    }, 'Q3': function (B, J) {
        return B !== J;
    }, 's56': function (B, J) {
        return B < J;
    }, 'J1z': 0.5, 'h16': function (B, J) {
        return B - J;
    }
};
k2x6.b4i = function (j) {
    if (k2x6 && j)return k2x6.u8i.l8i(j);
};
k2x6.A4i = function (m) {
    if (k2x6 && m)return k2x6.u8i.l8i(m);
};
k2x6.K4i = function (n) {
    for (; k2x6;)return k2x6.u8i.l8i(n);
};
k2x6.M4i = function (h) {
    if (k2x6 && h)return k2x6.u8i.l8i(h);
};
k2x6.Z4i = function (f) {
    if (k2x6 && f)return k2x6.u8i.e8i(f);
};
k2x6.O4i = function (j) {
    for (; k2x6;)return k2x6.u8i.l8i(j);
};
k2x6.i4i = function (c) {
    for (; k2x6;)return k2x6.u8i.e8i(c);
};
k2x6.V4i = function (f) {
    for (; k2x6;)return k2x6.u8i.l8i(f);
};
k2x6.k4i = function (l) {
    for (; k2x6;)return k2x6.u8i.l8i(l);
};
k2x6.P4i = function (b) {
    if (k2x6 && b)return k2x6.u8i.l8i(b);
};
k2x6.j4i = function (b) {
    for (; k2x6;)return k2x6.u8i.l8i(b);
};
k2x6.g4i = function (c) {
    if (k2x6 && c)return k2x6.u8i.l8i(c);
};
k2x6.u4i = function (j) {
    if (k2x6 && j)return k2x6.u8i.e8i(j);
};
k2x6.N4i = function (j) {
    if (k2x6 && j)return k2x6.u8i.e8i(j);
};
k2x6.f4i = function (l) {
    if (k2x6 && l)return k2x6.u8i.l8i(l);
};
k2x6.H4i = function (g) {
    if (k2x6 && g)return k2x6.u8i.l8i(g);
};
k2x6.S4i = function (b) {
    for (; k2x6;)return k2x6.u8i.l8i(b);
};
k2x6.v4i = function (a) {
    while (a)return k2x6.u8i.e8i(a);
};
k2x6.w4i = function (l) {
    if (k2x6 && l)return k2x6.u8i.l8i(l);
};
k2x6.D4i = function (m) {
    for (; k2x6;)return k2x6.u8i.e8i(m);
};
k2x6.J4i = function (b) {
    for (; k2x6;)return k2x6.u8i.l8i(b);
};
k2x6.p4i = function (n) {
    for (; k2x6;)return k2x6.u8i.e8i(n);
};
k2x6.X4i = function (a) {
    if (k2x6 && a)return k2x6.u8i.e8i(a);
};
k2x6.C8i = function (j) {
    if (k2x6 && j)return k2x6.u8i.e8i(j);
};
k2x6.T8i = function (i) {
    for (; k2x6;)return k2x6.u8i.l8i(i);
};
k2x6.y8i = function (m) {
    for (; k2x6;)return k2x6.u8i.e8i(m);
};
k2x6.Q8i = function (j) {
    if (k2x6 && j)return k2x6.u8i.e8i(j);
};
k2x6.U8i = function (m) {
    for (; k2x6;)return k2x6.u8i.l8i(m);
};
k2x6.n8i = function (c) {
    while (c)return k2x6.u8i.e8i(c);
};
k2x6.L8i = function (e) {
    for (; k2x6;)return k2x6.u8i.l8i(e);
};
k2x6.s8i = function (k) {
    if (k2x6 && k)return k2x6.u8i.l8i(k);
};
(function () {
    k2x6.c8i = function (g) {
        for (; k2x6;)return k2x6.u8i.e8i(g);
    };
    k2x6.r8i = function (m) {
        while (m)return k2x6.u8i.l8i(m);
    };
    var J = k2x6.s8i("218") ? "navigationStart" : "clientX", I = k2x6.L8i("c3f6") ? "getDelta" : "timing",
        j = k2x6.r8i("5e") ? 'now' : "undefined", v = k2x6.c8i("484") ? "float A = 0.15;" : "m3",
        F = k2x6.n8i("d8f") ? "gl_FragColor.a = 1.0;" : 'performance',
        S = k2x6.U8i("a5a") ? "D3" : "vec3 color = curr*whiteScale;", d = k2x6.Q8i("78") ? function () {
            k2x6.h8i = function (h) {
                for (; k2x6;)return k2x6.u8i.e8i(h);
            };
            Date[k2x6.d1z] = k2x6.y8i("f1c") ? "gettree," : (Date[k2x6.d1z] || function () {
                var B = k2x6.h8i("c6") ? "_clipBox" : "getTime";
                return new Date()[B]();
            });
        } : .1;
    if (k2x6[S](F in window, k2x6.S1z)) {
        k2x6.o4i = function (k) {
            while (k)return k2x6.u8i.l8i(k);
        };
        window[k2x6.H1z] = k2x6.o4i("518") ? 'OnPickMarker' : {};
    }
    d();
    if (k2x6[v](j in window[k2x6.H1z], k2x6.S1z)) {
        var E = k2x6.J4i("ff5") ? window[k2x6.H1z][I] && window[k2x6.H1z][I][J] ? window[k2x6.H1z][I][J] : Date[k2x6.d1z]() : 'number';
        window[k2x6.H1z][k2x6.d1z] = function () {
            var B = k2x6.T8i("d7d6") ? "H3" : "//	return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));";
            return k2x6[B](Date[k2x6.d1z](), E);
        };
    }
})();
var TWEEN = k2x6.C8i("6a") ? 0.4 : TWEEN || (function () {
        k2x6.Y4i = function (h) {
            while (h)return k2x6.u8i.e8i(h);
        };
        var S = "splice", d = [];
        return {
            getAll: function () {
                return d;
            }, removeAll: function () {
                k2x6.a8i = function (m) {
                    for (; k2x6;)return k2x6.u8i.l8i(m);
                };
                var B = k2x6.a8i("32e") ? function () {
                    k2x6.x8i = function (d) {
                        for (; k2x6;)return k2x6.u8i.e8i(d);
                    };
                    d = k2x6.x8i("ff") ? "skyMat" : [];
                } : "ka";
                B();
            }, add: function (B) {
                k2x6.R8i = function (m) {
                    if (k2x6 && m)return k2x6.u8i.e8i(m);
                };
                var J = k2x6.R8i("cda") ? "push" : "removeAll";
                d[J](B);
            }, remove: function (B) {
                var J = k2x6.X4i("57") ? "tweenPosition" : "indexOf", I = k2x6.p4i("b88") ? d[J](B) : "scripts";
                if (I !== -k2x6.H8z) {
                    d[S](I, k2x6.H8z);
                }
            }, update: function (J) {
                k2x6.B4i = function (j) {
                    if (k2x6 && j)return k2x6.u8i.l8i(j);
                };
                var I = "P3", j = "l3", v = function () {
                    k2x6.I4i = function (c) {
                        if (k2x6 && c)return k2x6.u8i.e8i(c);
                    };
                    var B = k2x6.Y4i("8d13") ? "f3" : 20750;
                    J = k2x6.I4i("8f2") ? k2x6[B](J, undefined) ? J : window[k2x6.H1z][k2x6.d1z]() : 0.337255;
                };
                if (k2x6[j](d.length, k2x6.d8z)) {
                    return k2x6.S1z;
                }
                var F = k2x6.B4i("11f") ? k2x6.d8z : "float A = 0.15;";
                v();
                while (k2x6[I](F, d.length)) {
                    if (d[F][k2x6.o1z](J)) {
                        F++;
                    } else {
                        d[S](F, k2x6.H8z);
                    }
                }
                return k2x6.h1z;
            }
        };
    })();
TWEEN[k2x6.e8z] = function (Y8) {
    k2x6.q4i = function (j) {
        for (; k2x6;)return k2x6.u8i.l8i(j);
    };
    k2x6.l4i = function (m) {
        for (; k2x6;)return k2x6.u8i.l8i(m);
    };
    k2x6.E4i = function (n) {
        while (n)return k2x6.u8i.e8i(n);
    };
    k2x6.d4i = function (i) {
        for (; k2x6;)return k2x6.u8i.l8i(i);
    };
    k2x6.F4i = function (i) {
        for (; k2x6;)return k2x6.u8i.l8i(i);
    };
    k2x6.m4i = function (i) {
        for (; k2x6;)return k2x6.u8i.l8i(i);
    };
    k2x6.t4i = function (a) {
        while (a)return k2x6.u8i.l8i(a);
    };
    var b1 = "onStop", Q = k2x6.V4i("65a") ? "onComplete" : "createMaterial_",
        f8 = k2x6.i4i("754") ? "IfcBuildingElementProxy" : "onUpdate", M5 = k2x6.u4i("b8e") ? "onStart" : "SOCKETURL",
        t8 = "chain", u8 = "interpolation", l8 = k2x6.l4i("25") ? "easing" : "order",
        j8 = k2x6.t4i("a3e") ? "yoyo" : "camPosition", G8 = k2x6.O4i("a6") ? "NONE" : "repeat", V8 = "delay",
        G4 = k2x6.q4i("3e") ? "stopChainedTweens" : "stopChainedTweens", a8 = k2x6.D4i("e52") ? "call" : "Group",
        K8 = k2x6.Z4i("336d") ? "stop" : "IFCCOVERING", s8 = k2x6.w4i("f4d") ? "receiveCache" : "start", X1 = "to",
        L4 = k2x6.v4i("3dd") ? "None" : "len", i8 = k2x6.m4i("a52e") ? null : "materialEdge",
        r4 = k2x6.F4i("5f2") ? 'application/javascript' : 1000, N4 = Y8, x8 = k2x6.g4i("af54") ? 'trans' : {},
        u4 = k2x6.M4i("b6e") ? {} : "float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]",
        w4 = k2x6.S4i("f5") ? "gl_FragColor.a = 1.0;" : {}, z4 = k2x6.H4i("ad") ? r4 : 'BIMVIZ.RenderEngine',
        A8 = k2x6.d8z, t4 = k2x6.S1z, W8 = k2x6.d4i("c7bd") ? k2x6.S1z : 'shininess',
        r1 = k2x6.j4i("7a3") ? 'd' : k2x6.S1z, C4 = k2x6.E4i("a5") ? k2x6.d8z : ",bscene",
        w1 = k2x6.P4i("58af") ? 1 : i8, R1 = k2x6.K4i("c637") ? 0.7 : TWEEN[k2x6.P1z][k2x6.Q1z][L4],
        O1 = TWEEN[k2x6.H5z][k2x6.Q1z], m1 = k2x6.A4i("bda") ? "lastPosition" : [],
        d1 = k2x6.f4i("caf") ? i8 : "// const float luminance = 1.0; //",
        B1 = k2x6.N4i("4bc") ? k2x6.S1z : "// rayleigh coefficients",
        Z1 = k2x6.b4i("2ba3") ? "// composition + solar disc" : i8, n4 = k2x6.k4i("65") ? i8 : 'bumpMap', g4 = i8;
    for (var W1 in Y8) {
        x8[W1] = parseFloat(Y8[W1], k2x6.Q8z);
    }
    this[X1] = function (B, J) {
        var I = "i3";
        if (k2x6[I](J, undefined)) {
            z4 = J;
        }
        u4 = B;
        return this;
    };
    this[s8] = function (B) {
        var J = 1.0, I = "c3", j = "s3", v = "concat", F = "W3", S = "A3", d = "Z3", E = "add";
        TWEEN[E](this);
        W8 = k2x6.h1z;
        B1 = k2x6.S1z;
        w1 = k2x6[d](B, undefined) ? B : window[k2x6.H1z][k2x6.d1z]();
        w1 += C4;
        for (var N in u4) {
            if (k2x6[S](u4[N], Array)) {
                if (k2x6[F](u4[N].length, k2x6.d8z)) {
                    continue;
                }
                u4[N] = [N4[N]][v](u4[N]);
            }
            if (k2x6[j](x8[N], undefined)) {
                continue;
            }
            x8[N] = N4[N];
            if (k2x6[I]((x8[N] instanceof Array), k2x6.S1z)) {
                x8[N] *= J;
            }
            w4[N] = x8[N] || k2x6.d8z;
        }
        return this;
    };
    this[K8] = function () {
        var B = "Q3", J = "remove";
        if (!W8) {
            return this;
        }
        TWEEN[J](this);
        W8 = k2x6.S1z;
        if (k2x6[B](g4, i8)) {
            g4[a8](N4);
        }
        this[G4]();
        return this;
    };
    this[G4] = function () {
        var B = "T3";
        for (var J = k2x6.d8z, I = m1.length; k2x6[B](J, I); J++) {
            m1[J][K8]();
        }
    };
    this[V8] = function (B) {
        C4 = B;
        return this;
    };
    this[G8] = function (B) {
        A8 = B;
        return this;
    };
    this[j8] = function (B) {
        t4 = B;
        return this;
    };
    this[l8] = function (B) {
        R1 = B;
        return this;
    };
    this[u8] = function (B) {
        O1 = B;
        return this;
    };
    this[t8] = function () {
        m1 = arguments;
        return this;
    };
    this[M5] = function (B) {
        d1 = B;
        return this;
    };
    this[f8] = function (B) {
        Z1 = B;
        return this;
    };
    this[Q] = function (B) {
        n4 = B;
        return this;
    };
    this[b1] = function (B) {
        g4 = B;
        return this;
    };
    this[k2x6.o1z] = function (B) {
        var J = "G7", I = "K7", j = "q7", v = "V7", F = "j7", S = "u7", d = 'number', E = '-', N = '+',
            k = "startsWith", V = 'string', n = "E7", s = "S7", A = "v7", q = "t7", L = "o7", W = "p7", M = "x3", i, p8,
            c;
        if (k2x6[M](B, w1)) {
            return k2x6.h1z;
        }
        if (k2x6[W](B1, k2x6.S1z)) {
            if (k2x6[L](d1, i8)) {
                d1[a8](N4);
            }
            B1 = k2x6.h1z;
        }
        p8 = k2x6[q]((B - w1), z4);
        p8 = k2x6[A](p8, k2x6.H8z) ? k2x6.H8z : p8;
        c = R1(p8);
        for (i in u4) {
            if (k2x6[s](x8[i], undefined)) {
                continue;
            }
            var E4 = x8[i] || k2x6.d8z, C = u4[i];
            if (k2x6[n](C, Array)) {
                N4[i] = O1(C, c);
            } else {
                if (typeof (C) === V) {
                    if (C[k](N) || C[k](E)) {
                        C = E4 + parseFloat(C, k2x6.Q8z);
                    } else {
                        C = parseFloat(C, k2x6.Q8z);
                    }
                }
                if (typeof (C) === d) {
                    N4[i] = E4 + k2x6[S]((C - E4), c);
                }
            }
        }
        if (k2x6[F](Z1, i8)) {
            Z1[a8](N4, c);
        }
        if (k2x6[v](p8, k2x6.H8z)) {
            if (k2x6[j](A8, k2x6.d8z)) {
                if (isFinite(A8)) {
                    A8--;
                }
                for (i in w4) {
                    if (typeof (u4[i]) === V) {
                        w4[i] = w4[i] + parseFloat(u4[i], k2x6.Q8z);
                    }
                    if (t4) {
                        var o8 = w4[i];
                        w4[i] = u4[i];
                        u4[i] = o8;
                    }
                    x8[i] = w4[i];
                }
                if (t4) {
                    r1 = !r1;
                }
                w1 = B + C4;
                return k2x6.h1z;
            } else {
                if (k2x6[I](n4, i8)) {
                    n4[a8](N4);
                }
                for (var H8 = k2x6.d8z, E8 = m1.length; k2x6[J](H8, E8); H8++) {
                    m1[H8][s8](w1 + z4);
                }
                return k2x6.S1z;
            }
        }
        return k2x6.h1z;
    };
};
TWEEN[k2x6.P1z] = {
    Linear: {
        None: function (B) {
            return B;
        }
    }, Quadratic: {
        In: function (B) {
            var J = "e7";
            return k2x6[J](B, B);
        }, Out: function (B) {
            var J = "r7";
            return k2x6[J](B, (k2x6.S8z - B));
        }, InOut: function (B) {
            var J = "x7", I = "h7", j = "U7";
            if (k2x6[j]((B *= k2x6.S8z), k2x6.H8z)) {
                return k2x6[I](k2x6.J1z, B, B);
            }
            return -k2x6.J1z * (--B * (k2x6[J](B, k2x6.S8z)) - k2x6.H8z);
        }
    }, Cubic: {
        In: function (B) {
            var J = "B0";
            return k2x6[J](B, B, B);
        }, Out: function (B) {
            return --B * B * B + k2x6.H8z;
        }, InOut: function (B) {
            var J = "d0", I = "w0", j = "I0";
            if (k2x6[j]((B *= k2x6.S8z), k2x6.H8z)) {
                return k2x6[I](k2x6.J1z, B, B, B);
            }
            return k2x6[J](k2x6.J1z, ((B -= k2x6.S8z) * B * B + k2x6.S8z));
        }
    }, Quartic: {
        In: function (B) {
            var J = "N0";
            return k2x6[J](B, B, B, B);
        }, Out: function (B) {
            return k2x6.H8z - (--B * B * B * B);
        }, InOut: function (B) {
            var J = "A0", I = "i0", j = "P0";
            if (k2x6[j]((B *= k2x6.S8z), k2x6.H8z)) {
                return k2x6[I](k2x6.J1z, B, B, B, B);
            }
            return -k2x6.J1z * (k2x6[J]((B -= k2x6.S8z) * B * B * B, k2x6.S8z));
        }
    }, Quintic: {
        In: function (B) {
            var J = "W0";
            return k2x6[J](B, B, B, B, B);
        }, Out: function (B) {
            return --B * B * B * B * B + k2x6.H8z;
        }, InOut: function (B) {
            var J = "R0", I = "Q0", j = "c0";
            if (k2x6[j]((B *= k2x6.S8z), k2x6.H8z)) {
                return k2x6[I](k2x6.J1z, B, B, B, B, B);
            }
            return k2x6[J](k2x6.J1z, ((B -= k2x6.S8z) * B * B * B * B + k2x6.S8z));
        }
    }, Sinusoidal: {
        In: function (B) {
            var J = "B86";
            return k2x6[J](k2x6.H8z, Math[k2x6.s1z](B * Math[k2x6.k1z] / k2x6.S8z));
        }, Out: function (B) {
            var J = "Y86";
            return Math[k2x6.T8z](k2x6[J](B, Math[k2x6.k1z], k2x6.S8z));
        }, InOut: function (B) {
            var J = "w86";
            return k2x6[J](k2x6.J1z, (k2x6.H8z - Math[k2x6.s1z](Math[k2x6.k1z] * B)));
        }
    }, Exponential: {
        In: function (B) {
            var J = "d86", I = "F86";
            return k2x6[I](B, k2x6.d8z) ? k2x6.d8z : Math[k2x6.f4z](k2x6.G5z, k2x6[J](B, k2x6.H8z));
        }, Out: function (B) {
            var J = "N86";
            return k2x6[J](B, k2x6.H8z) ? k2x6.H8z : k2x6.H8z - Math[k2x6.f4z](k2x6.S8z, -k2x6.Q8z * B);
        }, InOut: function (B) {
            var J = "b86", I = "M86", j = "O86", v = "k86", F = "g86";
            if (k2x6[F](B, k2x6.d8z)) {
                return k2x6.d8z;
            }
            if (k2x6[v](B, k2x6.H8z)) {
                return k2x6.H8z;
            }
            if (k2x6[j]((B *= k2x6.S8z), k2x6.H8z)) {
                return k2x6[I](k2x6.J1z, Math[k2x6.f4z](k2x6.G5z, B - k2x6.H8z));
            }
            return k2x6.J1z * (-Math[k2x6.f4z](k2x6.S8z, -k2x6.Q8z * (k2x6[J](B, k2x6.H8z))) + k2x6.S8z);
        }
    }, Circular: {
        In: function (B) {
            var J = "z86";
            return k2x6[J](k2x6.H8z, Math[k2x6.y0o](k2x6.H8z - B * B));
        }, Out: function (B) {
            return Math[k2x6.y0o](k2x6.H8z - (--B * B));
        }, InOut: function (B) {
            var J = "y86", I = "n86", j = "L86";
            if (k2x6[j]((B *= k2x6.S8z), k2x6.H8z)) {
                return -k2x6.J1z * (k2x6[I](Math[k2x6.y0o](k2x6.H8z - B * B), k2x6.H8z));
            }
            return k2x6[J](k2x6.J1z, (Math[k2x6.y0o](k2x6.H8z - (B -= k2x6.S8z) * B) + k2x6.H8z));
        }
    }, Elastic: {
        In: function (B) {
            var J = "Y46", I = "B46", j = "R86", v = "C86";
            if (k2x6[v](B, k2x6.d8z)) {
                return k2x6.d8z;
            }
            if (k2x6[j](B, k2x6.H8z)) {
                return k2x6.H8z;
            }
            return -Math[k2x6.f4z](k2x6.S8z, k2x6[I](k2x6.Q8z, (B - k2x6.H8z))) * Math[k2x6.T8z](k2x6[J]((B - k2x6.f1z), k2x6.E8z, Math[k2x6.k1z]));
        }, Out: function (B) {
            var J = 0.1, I = "d46", j = "F46", v = "w46";
            if (k2x6[v](B, k2x6.d8z)) {
                return k2x6.d8z;
            }
            if (k2x6[j](B, k2x6.H8z)) {
                return k2x6.H8z;
            }
            return Math[k2x6.f4z](k2x6.S8z, -k2x6.Q8z * B) * Math[k2x6.T8z](k2x6[I]((B - J), k2x6.E8z, Math[k2x6.k1z])) + k2x6.H8z;
        }, InOut: function (B) {
            var J = "s46", I = "W46", j = "K46", v = "q46", F = "V46", S = "j46", d = "u46";
            if (k2x6[d](B, k2x6.d8z)) {
                return k2x6.d8z;
            }
            if (k2x6[S](B, k2x6.H8z)) {
                return k2x6.H8z;
            }
            B *= k2x6.S8z;
            if (k2x6[F](B, k2x6.H8z)) {
                return -k2x6.J1z * Math[k2x6.f4z](k2x6.S8z, k2x6[v](k2x6.Q8z, (B - k2x6.H8z))) * Math[k2x6.T8z](k2x6[j]((B - k2x6.f1z), k2x6.E8z, Math[k2x6.k1z]));
            }
            return k2x6.J1z * Math[k2x6.f4z](k2x6.S8z, -k2x6.Q8z * (k2x6[I](B, k2x6.H8z))) * Math[k2x6.T8z](k2x6[J]((B - k2x6.f1z), k2x6.E8z, Math[k2x6.k1z])) + k2x6.H8z;
        }
    }, Back: {
        In: function (B) {
            var J = "n46", I = k2x6.Q4z;
            return k2x6[J](B, B, ((I + k2x6.H8z) * B - I));
        }, Out: function (B) {
            var J = "h46", I = k2x6.Q4z;
            return --B * B * (k2x6[J]((I + k2x6.H8z), B) + I) + k2x6.H8z;
        }, InOut: function (B) {
            var J = "I16", I = "J16", j = "X16", v = 1.525, F = "a46", S = k2x6[F](k2x6.Q4z, v);
            if (k2x6[j]((B *= k2x6.S8z), k2x6.H8z)) {
                return k2x6[I](k2x6.J1z, (B * B * ((S + k2x6.H8z) * B - S)));
            }
            return k2x6[J](k2x6.J1z, ((B -= k2x6.S8z) * B * ((S + k2x6.H8z) * B + S) + k2x6.S8z));
        }
    }, Bounce: {
        In: function (B) {
            var J = "w16";
            return k2x6[J](k2x6.H8z, TWEEN[k2x6.P1z][k2x6.n1z][k2x6.P4z](k2x6.H8z - B));
        }, Out: function (B) {
            var J = 0.984375, I = 2.625, j = "b16", v = 0.9375, F = 2.25, S = "Z16", d = 2.5, E = "i16", N = 0.75,
                k = 1.5, V = "j16", n = "u16", s = 7.5625, A = "d16", q = 2.75, L = "F16";
            if (k2x6[L](B, (k2x6.H8z / q))) {
                return k2x6[A](s, B, B);
            } else if (k2x6[n](B, (k2x6.S8z / q))) {
                return k2x6[V](s, (B -= (k / q)), B) + N;
            } else if (k2x6[E](B, (d / q))) {
                return k2x6[S](s, (B -= (F / q)), B) + v;
            } else {
                return k2x6[j](s, (B -= (I / q)), B) + J;
            }
        }, InOut: function (B) {
            var J = "U16", I = "In", j = "r16", v = "e16";
            if (k2x6[v](B, k2x6.J1z)) {
                return k2x6[j](TWEEN[k2x6.P1z][k2x6.n1z][I](B * k2x6.S8z), k2x6.J1z);
            }
            return k2x6[J](TWEEN[k2x6.P1z][k2x6.n1z][k2x6.P4z](B * k2x6.S8z - k2x6.H8z), k2x6.J1z) + k2x6.J1z;
        }
    }
};
TWEEN[k2x6.H5z] = {
    Linear: function (B, J) {
        var I = "d56", j = "F56", v = "w56", F = "I56", S = "J56", d = "X56", E = "a16", N = "h16",
            k = k2x6[N](B.length, k2x6.H8z), V = k2x6[E](k, J), n = Math[k2x6.I5z](V),
            s = TWEEN[k2x6.H5z][k2x6.G1z][k2x6.Q1z];
        if (k2x6[d](J, k2x6.d8z)) {
            return s(B[k2x6.d8z], B[k2x6.H8z], V);
        }
        if (k2x6[S](J, k2x6.H8z)) {
            return s(B[k], B[k2x6[F](k, k2x6.H8z)], k2x6[v](k, V));
        }
        return s(B[n], B[k2x6[j](n + k2x6.H8z, k) ? k : n + k2x6.H8z], k2x6[I](V, n));
    }, Bezier: function (B, J) {
        var I = "k56", j = "g56", v = "Bernstein", F = "N56", S = k2x6.d8z, d = k2x6[F](B.length, k2x6.H8z),
            E = Math[k2x6.f4z], N = TWEEN[k2x6.H5z][k2x6.G1z][v];
        for (var k = k2x6.d8z; k2x6[j](k, d); k++) {
            S += k2x6[I](E(k2x6.H8z - J, d - k), E(J, k), B[k], N(d, k));
        }
        return S;
    }, CatmullRom: function (B, J) {
        var I = "j96", j = "u96", v = "E96", F = "S96", S = "v96", d = "t96", E = "o96", N = "p96", k = "x56",
            V = "T56", n = "Q56", s = "c56", A = "s56", q = "W56", L = "CatmullRom", W = "A56", M = "Z56",
            i = k2x6[M](B.length, k2x6.H8z), p8 = k2x6[W](i, J), c = Math[k2x6.I5z](p8),
            E4 = TWEEN[k2x6.H5z][k2x6.G1z][L];
        if (k2x6[q](B[k2x6.d8z], B[i])) {
            if (k2x6[A](J, k2x6.d8z)) {
                c = Math[k2x6.I5z](p8 = k2x6[s](i, (k2x6.H8z + J)));
            }
            return E4(B[k2x6[n]((c - k2x6.H8z + i), i)], B[c], B[k2x6[V]((c + k2x6.H8z), i)], B[k2x6[k]((c + k2x6.S8z), i)], k2x6[N](p8, c));
        } else {
            if (k2x6[E](J, k2x6.d8z)) {
                return B[k2x6.d8z] - (E4(B[k2x6.d8z], B[k2x6.d8z], B[k2x6.H8z], B[k2x6.H8z], -p8) - B[k2x6.d8z]);
            }
            if (k2x6[d](J, k2x6.H8z)) {
                return k2x6[S](B[i], (E4(B[i], B[i], B[i - k2x6.H8z], B[i - k2x6.H8z], p8 - i) - B[i]));
            }
            return E4(B[c ? k2x6[F](c, k2x6.H8z) : k2x6.d8z], B[c], B[k2x6[v](i, c + k2x6.H8z) ? i : c + k2x6.H8z], B[k2x6[j](i, c + k2x6.S8z) ? i : c + k2x6.S8z], k2x6[I](p8, c));
        }
    }, Utils: {
        Linear: function (B, J, I) {
            var j = "V96";
            return k2x6[j]((J - B), I) + B;
        }, Bernstein: function (B, J) {
            var I = "q96", j = "Factorial", v = TWEEN[k2x6.H5z][k2x6.G1z][j];
            return k2x6[I](v(B), v(J), v(B - J));
        }, Factorial: (function () {
            var v = [k2x6.H8z];
            return function (B) {
                var J = "A96", I = k2x6.H8z;
                if (v[B]) {
                    return v[B];
                }
                for (var j = B; k2x6[J](j, k2x6.H8z); j--) {
                    I *= j;
                }
                v[B] = I;
                return I;
            };
        })(), CatmullRom: function (B, J, I, j, v) {
            var F = "o26", S = "p26", d = "x96", E = 3, N = "T96", k = "Q96", V = "c96", n = "s96", s = "W96",
                A = k2x6[s]((I - B), k2x6.J1z), q = k2x6[n]((j - J), k2x6.J1z), L = k2x6[V](v, v), W = k2x6[k](v, L);
            return k2x6[N]((k2x6.S8z * J - k2x6.S8z * I + A + q), W) + (-E * J + k2x6[d](E, I) - k2x6[S](k2x6.S8z, A) - q) * L + k2x6[F](A, v) + J;
        }
    }
};
(function (I) {
    var j = "t26", v = 'object', F = 'undefined';
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return TWEEN;
        });
    } else if (typeof module !== F && typeof exports === v) {
        var S = function (B) {
            var J = "exports";
            module[J] = B;
        };
        S(TWEEN);
    } else if (k2x6[j](I, undefined)) {
        var d = function (B) {
            var J = "TWEEN";
            I[J] = B;
        };
        d(TWEEN);
    }
})(this);
var Y1n8T = {
    'H1h': "WORKDEFINE",
    'k1h': '1.5.42',
    'D1h': "NETDEFINE",
    'e8h': 3,
    'o1h': "UI",
    'h1h': 6,
    'g1h': 4,
    'S1h': 2,
    'x1h': "D3",
    'p1h': 1,
    'F1m': (function (N1m) {
        return (function (S5m, w1m) {
            return (function (x5m) {
                return {b1m: x5m, H5m: x5m,};
            })(function (t1m) {
                var y1m, q1m = 0;
                for (var e1m = S5m; q1m < t1m["length"]; q1m++) {
                    var m1m = w1m(t1m, q1m);
                    y1m = q1m === 0 ? m1m : y1m ^ m1m;
                }
                return y1m ? e1m : !e1m;
            });
        })((function (n1m, i1m, L1m, Z1m) {
            var U1m = 26;
            return n1m(N1m, U1m) - Z1m(i1m, L1m) > U1m;
        })(parseInt, Date, (function (i1m) {
            return ('' + i1m)["substring"](1, (i1m + '')["length"] - 1);
        })('_getTime2'), function (i1m, L1m) {
            return new i1m()[L1m]();
        }), function (t1m, q1m) {
            var j1m = parseInt(t1m["charAt"](q1m), 16)["toString"](2);
            return j1m["charAt"](j1m["length"] - 1);
        });
    })('18fj9j22n2'),
    'A1h': 5
};
Y1n8T.g5m = function (j) {
    for (; Y1n8T;)return Y1n8T.F1m.b1m(j);
};
Y1n8T.o5m = function (g) {
    for (; Y1n8T;)return Y1n8T.F1m.b1m(g);
};
Y1n8T.A5m = function (g) {
    while (g)return Y1n8T.F1m.b1m(g);
};
Y1n8T.h5m = function (i) {
    if (Y1n8T && i)return Y1n8T.F1m.H5m(i);
};
Y1n8T.k5m = function (j) {
    while (j)return Y1n8T.F1m.H5m(j);
};
var BIMVIZ = Y1n8T.k5m("f87") ? 'mapNormalAnisotropy' : {REVISION: Y1n8T.k1h};
BIMVIZ[Y1n8T.H1h] = Y1n8T.h5m("8d") ? {
    Start: Y1n8T.p1h,
    Close: Y1n8T.S1h,
    LoadTreeNodeMesh: Y1n8T.e8h,
    PickByRay: Y1n8T.g1h,
    GetElementData: Y1n8T.A1h,
    LoadTree: Y1n8T.h1h,
} : 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.';
BIMVIZ[Y1n8T.D1h] = Y1n8T.A5m("bf6") ? 'RGBD' : {};
BIMVIZ[Y1n8T.o1h] = Y1n8T.o5m("414") ? {} : 'mediumturquoise';
BIMVIZ[Y1n8T.x1h] = Y1n8T.g5m("c3b1") ? {} : 'illumination';
var T9t4Y = {
    'n1a': 0.237255,
    'e1a': 0.8470588235,
    'I1a': 0.837255,
    'u1a': "SYS_EVENT",
    'c4Y': function (P, k) {
        return P == k;
    },
    'v1a': 'OnSelectElementGeometryList',
    'u3H': (function (E0H) {
        return (function (W0H, M0H) {
            return (function (S0H) {
                return {N3H: S0H, h0H: S0H,};
            })(function (K3H) {
                var a0H, i3H = 0;
                for (var y0H = W0H; i3H < K3H["length"]; i3H++) {
                    var A0H = M0H(K3H, i3H);
                    a0H = i3H === 0 ? A0H : a0H ^ A0H;
                }
                return a0H ? y0H : !y0H;
            });
        })((function (P0H, d3H, r3H, k0H) {
            var Y0H = 30;
            return P0H(E0H, Y0H) - k0H(d3H, r3H) > Y0H;
        })(parseInt, Date, (function (d3H) {
            return ('' + d3H)["substring"](1, (d3H + '')["length"] - 1);
        })('_getTime2'), function (d3H, r3H) {
            return new d3H()[r3H]();
        }), function (K3H, i3H) {
            var w3H = parseInt(K3H["charAt"](i3H), 16)["toString"](2);
            return w3H["charAt"](w3H["length"] - 1);
        });
    })('b0d06k000'),
    'p1a': 0.270588,
    'V1a': 1.0,
    'Q1a': "Clone",
    'l1a': 0.603922,
    'd1a': 0.203922,
    'L1a': 0.337255,
    'N1a': 0.137255,
    'Y4a': 0.427450980392,
    'm1a': 'OnPickElementGeometry',
    'w1a': 0.637255,
    'P4a': 'OnRaySelectNone',
    'K1a': 0.303922,
    'T1a': 0.570588,
    'H1a': 'PickElementByRay',
    'C1a': "GlobalMaterials_Sketcup",
    'O1a': 0.5,
    'i1a': 0.403922,
    'B1a': 'OverviewLoaded',
    'o1a': 'DataServerDataBlockReceived',
    'k4a': 'DataServerBigMeshLoaded',
    'b1a': 'OnRmeshLoaded',
    'j1a': 0.537255,
    'r1a': 0.870588,
    'E4a': 0,
    'f1a': 0.670588,
    'x1a': 'DataServerTreeLoaded'
};
T9t4Y.G0H = function (b) {
    for (; T9t4Y;)return T9t4Y.u3H.N3H(b);
};
T9t4Y.R0H = function (n) {
    for (; T9t4Y;)return T9t4Y.u3H.h0H(n);
};
T9t4Y.D0H = function (b) {
    for (; T9t4Y;)return T9t4Y.u3H.h0H(b);
};
T9t4Y.c0H = function (k) {
    while (k)return T9t4Y.u3H.h0H(k);
};
T9t4Y.t0H = function (c) {
    if (T9t4Y && c)return T9t4Y.u3H.h0H(c);
};
T9t4Y.s0H = function (n) {
    for (; T9t4Y;)return T9t4Y.u3H.N3H(n);
};
T9t4Y.U0H = function (f) {
    if (T9t4Y && f)return T9t4Y.u3H.h0H(f);
};
T9t4Y.Z0H = function (h) {
    if (T9t4Y && h)return T9t4Y.u3H.h0H(h);
};
BIMVIZ[T9t4Y.u1a] = T9t4Y.Z0H("3e8") ? {
    DataServerTreeLoaded: T9t4Y.x1a,
    DataServerBigMeshLoaded: T9t4Y.k4a,
    DataServerDataBlockReceived: T9t4Y.o1a,
    PickElementByRay: T9t4Y.H1a,
    OnPickElementGeometry: T9t4Y.m1a,
    OnSelectElementGeometryList: T9t4Y.v1a,
    OnRaySelectNone: T9t4Y.P4a,
    OverviewLoaded: T9t4Y.B1a,
    OnRmeshLoaded: T9t4Y.b1a
} : 'flipSided';
BIMVIZ[T9t4Y.C1a] = T9t4Y.U0H("db") ? 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' : {
    IfcRoof: {
        r: T9t4Y.I1a,
        g: T9t4Y.d1a,
        b: T9t4Y.p1a,
        a: T9t4Y.V1a
    },
    IfcSlab: {r: T9t4Y.w1a, g: T9t4Y.l1a, b: T9t4Y.f1a, a: T9t4Y.V1a},
    IfcWall: {r: T9t4Y.j1a, g: T9t4Y.L1a, b: T9t4Y.n1a, a: T9t4Y.V1a},
    IfcWallStandardCase: {r: T9t4Y.j1a, g: T9t4Y.L1a, b: T9t4Y.n1a, a: T9t4Y.V1a},
    IfcDoor: {r: T9t4Y.w1a, g: T9t4Y.l1a, b: T9t4Y.f1a, a: T9t4Y.V1a},
    IfcWindow: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.O1a},
    IfcOpeningElement: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.E4a},
    IfcRailing: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcColumn: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcBeam: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcFurnishingElement: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcCurtainWall: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcStair: {r: T9t4Y.w1a, g: T9t4Y.l1a, b: T9t4Y.f1a, a: T9t4Y.V1a},
    IfcStairFlight: {r: T9t4Y.w1a, g: T9t4Y.l1a, b: T9t4Y.f1a, a: T9t4Y.V1a},
    IfcBuildingElementProxy: {r: T9t4Y.O1a, g: T9t4Y.O1a, b: T9t4Y.O1a, a: T9t4Y.V1a},
    IfcFlowSegment: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcFlowitting: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcFlowTerminal: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcProxy: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcSite: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcLightFixture: {r: T9t4Y.e1a, g: T9t4Y.e1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IfcDuctSegment: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcDistributionFlowElement: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcDuctFitting: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcPlate: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.O1a},
    IfcAirTerminal: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcMember: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcCovering: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcTransportElement: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcFlowController: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcFlowFitting: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcRamp: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcFurniture: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcFooting: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcSystemFurnitureElement: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IfcSpace: {r: T9t4Y.N1a, g: T9t4Y.K1a, b: T9t4Y.T1a, a: T9t4Y.O1a},
    IFCROOF: {r: T9t4Y.w1a, g: T9t4Y.l1a, b: T9t4Y.f1a, a: T9t4Y.V1a},
    IFCSLAB: {r: T9t4Y.w1a, g: T9t4Y.l1a, b: T9t4Y.f1a, a: T9t4Y.V1a},
    IFCWALL: {r: T9t4Y.j1a, g: T9t4Y.L1a, b: T9t4Y.n1a, a: T9t4Y.V1a},
    IFCWALLSTANDARDCASE: {r: T9t4Y.j1a, g: T9t4Y.L1a, b: T9t4Y.n1a, a: T9t4Y.V1a},
    IFCDOOR: {r: T9t4Y.w1a, g: T9t4Y.l1a, b: T9t4Y.f1a, a: T9t4Y.V1a},
    IFCWINDOW: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.O1a},
    IFCOPENINGELEMENT: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.E4a},
    IFCRAILING: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCCOLUMN: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCBEAM: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCFURNISHINGELEMENT: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCCURTAINWALL: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCSTAIR: {r: T9t4Y.w1a, g: T9t4Y.l1a, b: T9t4Y.f1a, a: T9t4Y.V1a},
    IFCSTAIRFLIGHT: {r: T9t4Y.w1a, g: T9t4Y.l1a, b: T9t4Y.f1a, a: T9t4Y.V1a},
    IFCBUILDINGELEMENTPROXY: {r: T9t4Y.O1a, g: T9t4Y.O1a, b: T9t4Y.O1a, a: T9t4Y.V1a},
    IFCFLOWSEGMENT: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCFLOWITTING: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCFLOWTERMINAL: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCPROXY: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCSITE: {r: T9t4Y.N1a, g: T9t4Y.i1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCLIGHTFIXTURE: {r: T9t4Y.e1a, g: T9t4Y.e1a, b: T9t4Y.r1a, a: T9t4Y.V1a},
    IFCDUCTSEGMENT: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCDISTRIBUTIONFLOWELEMENT: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCDUCTFITTING: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCPLATE: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.O1a},
    IFCAIRTERMINAL: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCMEMBER: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCCOVERING: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCTRANSPORTELEMENT: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCFLOWCONTROLLER: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCFLOWFITTING: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCRAMP: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCFURNITURE: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCFOOTING: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCSYSTEMFURNITUREELEMENT: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a},
    IFCSPACE: {r: T9t4Y.N1a, g: T9t4Y.K1a, b: T9t4Y.T1a, a: T9t4Y.O1a},
    DEFAULT: {r: T9t4Y.e1a, g: T9t4Y.Y4a, b: T9t4Y.E4a, a: T9t4Y.V1a}
};
BIMVIZ[T9t4Y.Q1a] = T9t4Y.s0H("11b7") ? 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined' : function (P) {
    var k = T9t4Y.t0H("2a") ? "IFCMEMBER" : null, A = T9t4Y.c0H("66") ? 0.1 : "c4Y",
        M = T9t4Y.D0H("866") ? 'SpriteMaterial' : 'object';
    if (typeof (P) != M)return P;
    if (T9t4Y[A](P, k))return P;
    var W = T9t4Y.R0H("fe") ? new Object() : "tweenBack";
    for (var S in P)W[S] = T9t4Y.G0H("d6d") ? 'olivedrab' : BIMVIZ[T9t4Y.Q1a](P[S]);
    return W;
};
var y9f0Y = {
    'G5a': 'ErrorMessage',
    't5a': 'OnPickMarker',
    'S5a': 'OnSelectElementPropertyList',
    'R5a': 'OnPickElement',
    'U5a': 'OnShowDebugInfo',
    'D5a': 'OnLoadProgressStep',
    'h5a': 'DataServerConnected',
    'Z5a': 'ProjectOverviewLoaded',
    's5a': "EVENT",
    'J5a': 'DataServerConnectedError',
    'J4p': (function (R4p) {
        return (function (v4p, Q4p) {
            return (function (B4p) {
                return {h4p: B4p, n4p: B4p,};
            })(function (U4p) {
                var g4p, s4p = 0;
                for (var b4p = v4p; s4p < U4p["length"]; s4p++) {
                    var H4p = Q4p(U4p, s4p);
                    g4p = s4p === 0 ? H4p : g4p ^ H4p;
                }
                return g4p ? b4p : !b4p;
            });
        })((function (G4p, c4p, t4p, F4p) {
            var D4p = 29;
            return G4p(R4p, D4p) - F4p(c4p, t4p) > D4p;
        })(parseInt, Date, (function (c4p) {
            return ('' + c4p)["substring"](1, (c4p + '')["length"] - 1);
        })('_getTime2'), function (c4p, t4p) {
            return new c4p()[t4p]();
        }), function (U4p, s4p) {
            var Z4p = parseInt(U4p["charAt"](s4p), 16)["toString"](2);
            return Z4p["charAt"](Z4p["length"] - 1);
        });
    })('ecr3hcrjl'),
    'c5a': 'OnConnectServer'
};
y9f0Y.j4p = function (n) {
    while (n)return y9f0Y.J4p.n4p(n);
};
BIMVIZ[y9f0Y.s5a] = y9f0Y.j4p("167") ? 'varying vec2 vUV;' : {
    ProjectOverviewLoaded: y9f0Y.Z5a,
    DataServerConnected: y9f0Y.h5a,
    DataServerConnectedError: y9f0Y.J5a,
    ErrorMessage: y9f0Y.G5a,
    OnPickElement: y9f0Y.R5a,
    OnSelectElementPropertyList: y9f0Y.S5a,
    OnLoadProgressStep: y9f0Y.D5a,
    OnShowDebugInfo: y9f0Y.U5a,
    OnPickMarker: y9f0Y.t5a,
    OnConnectServer: y9f0Y.c5a
};
var U4r41 = {
    'A3Y': function (P, k) {
        return P !== k;
    }, 'F3Y': function (P, k) {
        return P < k;
    }, 's3Y': function (P, k) {
        return P >= k;
    }, 'v3a': "splice", 'k8p': (function (h8p) {
        return (function (R8p, c8p) {
            return (function (G8p) {
                return {a8p: G8p, g8p: G8p,};
            })(function (M8p) {
                var s8p, y8p = 0;
                for (var D8p = R8p; y8p < M8p["length"]; y8p++) {
                    var t8p = c8p(M8p, y8p);
                    s8p = y8p === 0 ? t8p : s8p ^ t8p;
                }
                return s8p ? D8p : !D8p;
            });
        })((function (Z8p, S8p, W8p, U8p) {
            var J8p = 29;
            return Z8p(h8p, J8p) - U8p(S8p, W8p) > J8p;
        })(parseInt, Date, (function (S8p) {
            return ('' + S8p)["substring"](1, (S8p + '')["length"] - 1);
        })('_getTime2'), function (S8p, W8p) {
            return new S8p()[W8p]();
        }), function (M8p, y8p) {
            var A8p = parseInt(M8p["charAt"](y8p), 16)["toString"](2);
            return A8p["charAt"](A8p["length"] - 1);
        });
    })('ecr3hcrjl'), 'O3a': true, 'C3a': 1, 'h3Y': function (P, k) {
        return P === k;
    }, 'd41': function (P, k) {
        return P == k;
    }, 'D3a': "EventArg", 'P3Y': function (P, k) {
        return P === k;
    }, 'V3a': 0, 'b3a': "EventManager", 'Q3Y': function (P, k) {
        return P > k;
    }, 'L3a': "removed", 'o3a': "_listeners", 'W3Y': function (P, k) {
        return P < k;
    }, 'D3Y': function (P, k) {
        return P !== k;
    }, 'm3a': "cancelled"
};
U4r41.u8p = function (m) {
    for (; U4r41;)return U4r41.k8p.a8p(m);
};
U4r41.l8p = function (a) {
    for (; U4r41;)return U4r41.k8p.a8p(a);
};
U4r41.f8p = function (c) {
    if (U4r41 && c)return U4r41.k8p.a8p(c);
};
U4r41.L8p = function (i) {
    for (; U4r41;)return U4r41.k8p.g8p(i);
};
U4r41.T8p = function (l) {
    if (U4r41 && l)return U4r41.k8p.a8p(l);
};
U4r41.z8p = function (j) {
    if (U4r41 && j)return U4r41.k8p.a8p(j);
};
U4r41.V8p = function (a) {
    while (a)return U4r41.k8p.a8p(a);
};
U4r41.C8p = function (e) {
    for (; U4r41;)return U4r41.k8p.a8p(e);
};
U4r41.q8p = function (e) {
    for (; U4r41;)return U4r41.k8p.a8p(e);
};
U4r41.e8p = function (i) {
    while (i)return U4r41.k8p.a8p(i);
};
U4r41.O8p = function (l) {
    if (U4r41 && l)return U4r41.k8p.a8p(l);
};
U4r41.n8p = function (k) {
    while (k)return U4r41.k8p.g8p(k);
};
U4r41.v8p = function (j) {
    for (; U4r41;)return U4r41.k8p.a8p(j);
};
U4r41.b8p = function (k) {
    for (; U4r41;)return U4r41.k8p.a8p(k);
};
U4r41.H8p = function (b) {
    if (U4r41 && b)return U4r41.k8p.g8p(b);
};
BIMVIZ[U4r41.b3a] = U4r41.H8p("5e5") ? 'MOZ_WEBGL_depth_texture' : function () {
    U4r41.Q8p = function (d) {
        if (U4r41 && d)return U4r41.k8p.g8p(d);
    };
    this[U4r41.o3a] = U4r41.Q8p("48") ? "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n" : {};
};
BIMVIZ.EventManager.prototype = U4r41.b8p("e6d") ? {
    addListener: function (P, k) {
        U4r41.p8p = function (i) {
            while (i)return U4r41.k8p.a8p(i);
        };
        U4r41.B8p = function (h) {
            if (U4r41 && h)return U4r41.k8p.a8p(h);
        };
        var A = U4r41.v8p("a18b") ? "itemStart" : "push", M = U4r41.B8p("64") ? "formats" : "with undefined Event Name",
            W = U4r41.p8p("bf33") ? "substring" : "BIMVIZ.EventManager",
            S = U4r41.n8p("e3") ? "d41" : 'px Helvetica,Arial,sans-serif';
        if (U4r41[S](P, undefined)) {
            console.error(W, M);
            return;
        }
        (this[U4r41.o3a][P] = this[U4r41.o3a][P] || [])[A](k);
        return this;
    }, removeListener: function (P, k) {
        U4r41.j8p = function (j) {
            if (U4r41 && j)return U4r41.k8p.g8p(j);
        };
        var A = U4r41.j8p("7d6") ? 'Mesh' : "s3Y", M = "h3Y",
            W = U4r41.O8p("21") ? "W3Y" : 'THREE.Matrix4: .translate() has been removed.',
            S = U4r41.V8p("eb6") ? "A3Y" : 'THREE.BufferGeometry: .computeOffsets() has been removed.',
            D = U4r41.e8p("32bb") ? 'function' : "const float pi = 3.141592653589793238462643383279502884197169;",
            g3 = "P3Y";
        if (U4r41[g3](arguments.length, U4r41.C3a)) {
            this[U4r41.o3a][P] = [];
        } else if (typeof (k) === D) {
            var R = U4r41.q8p("eee") ? 'mapLightWrap' : this[U4r41.o3a][P];
            if (U4r41[S](R, undefined)) {
                U4r41.m8p = function (e) {
                    while (e)return U4r41.k8p.g8p(e);
                };
                var C3 = U4r41.m8p("b23") ? 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' : -U4r41.C3a;
                for (var F = U4r41.V3a, Q = R.length; U4r41[W](F, Q) && C3 === -U4r41.C3a; F++) {
                    if (U4r41[M](R[F], k)) {
                        C3 = F;
                    }
                }
                if (U4r41[A](C3, U4r41.V3a)) {
                    R[U4r41.v3a](C3, U4r41.C3a);
                }
            }
        }
        return this;
    }, fire: function (P, k) {
        U4r41.x8p = function (m) {
            for (; U4r41;)return U4r41.k8p.a8p(m);
        };
        U4r41.o8p = function (e) {
            if (U4r41 && e)return U4r41.k8p.g8p(e);
        };
        var A = U4r41.z8p("1535") ? 'lights_lambert_vertex' : "F3Y",
            M = U4r41.C8p("ee2") ? 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' : "D3Y",
            W = U4r41.T8p("2a") ? 2151 : this[U4r41.o3a][P];
        k = U4r41.x8p("76") ? k || [] : 'lemonchiffon';
        if (U4r41[M](W, undefined)) {
            var S;
            S = U4r41.o8p("1143") ? new BIMVIZ[U4r41.b3a][U4r41.D3a](P, k) : "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );";
            for (var D = U4r41.V3a, g3 = W.length; U4r41[A](D, g3); D++) {
                W[D](S);
                if (S[U4r41.L3a]) {
                    W[U4r41.v3a](D, U4r41.C3a);
                    g3 = W.length;
                    --D;
                }
                if (S[U4r41.m3a]) {
                    break;
                }
            }
        }
        return this;
    }, hasListeners: function (P) {
        var k = U4r41.L8p("2634") ? "Q3Y" : "// optical length at zenith for molecules";
        return U4r41[k]((this[U4r41.o3a][P] === undefined ? U4r41.V3a : this[U4r41.o3a][P].length), U4r41.V3a);
    }
} : 'meshlambert_frag';
BIMVIZ[U4r41.b3a][U4r41.D3a] = function (P, k) {
    U4r41.X8p = function (d) {
        while (d)return U4r41.k8p.g8p(d);
    };
    U4r41.I8p = function (a) {
        for (; U4r41;)return U4r41.k8p.g8p(a);
    };
    var A = U4r41.I8p("78") ? false : "onLoadProgress", M = U4r41.X8p("d7") ? "numSupportedMorphTargets" : "args",
        W = U4r41.f8p("f6eb") ? "clearTarget" : "name";
    this[W] = U4r41.l8p("a6a7") ? P : "programs";
    this[M] = k;
    this[U4r41.m3a] = U4r41.u8p("6f5") ? "vA" : A;
    this[U4r41.L3a] = A;
};
BIMVIZ.EventManager.EventArg.prototype = {
    cancel: function () {
        this[U4r41.m3a] = U4r41.O3a;
    }, remove: function () {
        U4r41.N8p = function (m) {
            if (U4r41 && m)return U4r41.k8p.g8p(m);
        };
        this[U4r41.L3a] = U4r41.N8p("18") ? U4r41.O3a : 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().';
    }
};
var E2o9h = {
    'F6h': function (o, N) {
        return o == N;
    }, 'I4h': function (o, N) {
        return o == N;
    }, 'e4h': function (o, N) {
        return o < N;
    }, 'j6h': function (o, N) {
        return o == N;
    }, 'o6h': function (o, N) {
        return o == N;
    }, 'S7Q': "Children", 'U6h': function (o, N) {
        return o > N;
    }, 'q4h': function (o, N) {
        return o < N;
    }, 'a6h': function (o, N) {
        return o < N;
    }, 'd1Q': "Level", 'u4h': function (o, N) {
        return o == N;
    }, 'd6h': function (o, N) {
        return o < N;
    }, 'X6h': function (o, N) {
        return o == N;
    }, 'R5Q': "Name", 'Q4h': function (o, N) {
        return o < N;
    }, 'M9h': function (o, N) {
        return o == N;
    }, 'G6h': function (o, N) {
        return o == N;
    }, 'Z4h': function (o, N) {
        return o < N;
    }, 'q7Q': "Id", 'T9h': function (o, N) {
        return o < N;
    }, 'n9h': function (o, N) {
        return o < N;
    }, 'y6h': function (o, N) {
        return o == N;
    }, 'B4h': function (o, N) {
        return o == N;
    }, 'z6h': function (o, N) {
        return o == N;
    }, 'z5q': (function (O5q) {
        return (function (c5q, B5q) {
            return (function (q5q) {
                return {W5q: q5q, f5q: q5q,};
            })(function (r5q) {
                var b5q, D5q = 0;
                for (var s5q = c5q; D5q < r5q["length"]; D5q++) {
                    var X5q = B5q(r5q, D5q);
                    b5q = D5q === 0 ? X5q : b5q ^ X5q;
                }
                return b5q ? s5q : !s5q;
            });
        })((function (g5q, F5q, k5q, v5q) {
            var H5q = 28;
            return g5q(O5q, H5q) - v5q(F5q, k5q) > H5q;
        })(parseInt, Date, (function (F5q) {
            return ('' + F5q)["substring"](1, (F5q + '')["length"] - 1);
        })('_getTime2'), function (F5q, k5q) {
            return new F5q()[k5q]();
        }), function (r5q, D5q) {
            var K5q = parseInt(r5q["charAt"](D5q), 16)["toString"](2);
            return K5q["charAt"](K5q["length"] - 1);
        });
    })('j3g90n3nc'), 'H4h': function (o, N) {
        return o < N;
    }, 'f1Q': null, 'S9h': function (o, N) {
        return o == N;
    }, 'J0Q': 0, 'm4h': function (o, N) {
        return o < N;
    }, 'J9h': function (o, N) {
        return o < N;
    }, 'p4h': function (o, N) {
        return o == N;
    }, 'L6h': function (o, N) {
        return o == N;
    }, 'V4h': function (o, N) {
        return o != N;
    }, 'r6h': function (o, N) {
        return o == N;
    }, 'Y5Q': "FindNode", 'f0Q': "AddChild", 'l4h': function (o, N) {
        return o < N;
    }, 'C9h': function (o, N) {
        return o != N;
    }, 'W4h': function (o, N) {
        return o != N;
    }, 'f6h': function (o, N) {
        return o == N;
    }, 'i4h': function (o, N) {
        return o == N;
    }, 't4h': function (o, N) {
        return o == N;
    }, 'w9h': function (o, N) {
        return o < N;
    }, 'b1Q': "IfcType", 'R9h': function (o, N) {
        return o != N;
    }, 'D4h': function (o, N) {
        return o != N;
    }, 'c6h': function (o, N) {
        return o == N;
    }, 'v4h': function (o, N) {
        return o == N;
    }, 'Y1Q': "push", 'x6h': function (o, N) {
        return o < N;
    }, 'g6h': function (o, N) {
        return o != N;
    }, 'P6h': function (o, N) {
        return o < N;
    }
};
E2o9h.s7q = function (f) {
    while (f)return E2o9h.z5q.W5q(f);
};
E2o9h.B7q = function (g) {
    if (E2o9h && g)return E2o9h.z5q.W5q(g);
};
E2o9h.X7q = function (j) {
    if (E2o9h && j)return E2o9h.z5q.W5q(j);
};
E2o9h.b7q = function (m) {
    while (m)return E2o9h.z5q.f5q(m);
};
E2o9h.v7q = function (i) {
    for (; E2o9h;)return E2o9h.z5q.W5q(i);
};
E2o9h.H7q = function (c) {
    while (c)return E2o9h.z5q.W5q(c);
};
E2o9h.F7q = function (e) {
    if (E2o9h && e)return E2o9h.z5q.f5q(e);
};
E2o9h.k7q = function (b) {
    while (b)return E2o9h.z5q.f5q(b);
};
E2o9h.D7q = function (l) {
    while (l)return E2o9h.z5q.f5q(l);
};
E2o9h.r7q = function (b) {
    if (E2o9h && b)return E2o9h.z5q.f5q(b);
};
E2o9h.K7q = function (k) {
    while (k)return E2o9h.z5q.f5q(k);
};
E2o9h.z7q = function (m) {
    if (E2o9h && m)return E2o9h.z5q.W5q(m);
};
E2o9h.t7q = function (e) {
    if (E2o9h && e)return E2o9h.z5q.f5q(e);
};
E2o9h.N7q = function (b) {
    for (; E2o9h;)return E2o9h.z5q.W5q(b);
};
E2o9h.V7q = function (b) {
    if (E2o9h && b)return E2o9h.z5q.f5q(b);
};
E2o9h.h7q = function (k) {
    if (E2o9h && k)return E2o9h.z5q.f5q(k);
};
E2o9h.Q7q = function (n) {
    while (n)return E2o9h.z5q.f5q(n);
};
E2o9h.o7q = function (c) {
    for (; E2o9h;)return E2o9h.z5q.f5q(c);
};
E2o9h.Y5q = function (e) {
    for (; E2o9h;)return E2o9h.z5q.f5q(e);
};
E2o9h.p5q = function (g) {
    if (E2o9h && g)return E2o9h.z5q.W5q(g);
};
E2o9h.P5q = function (g) {
    while (g)return E2o9h.z5q.W5q(g);
};
E2o9h.J5q = function (m) {
    if (E2o9h && m)return E2o9h.z5q.W5q(m);
};
E2o9h.i5q = function (j) {
    while (j)return E2o9h.z5q.W5q(j);
};
E2o9h.C5q = function (k) {
    if (E2o9h && k)return E2o9h.z5q.W5q(k);
};
E2o9h.w5q = function (g) {
    for (; E2o9h;)return E2o9h.z5q.W5q(g);
};
E2o9h.I5q = function (f) {
    for (; E2o9h;)return E2o9h.z5q.W5q(f);
};
E2o9h.R5q = function (c) {
    while (c)return E2o9h.z5q.f5q(c);
};
E2o9h.n5q = function (k) {
    if (E2o9h && k)return E2o9h.z5q.W5q(k);
};
E2o9h.u5q = function (g) {
    if (E2o9h && g)return E2o9h.z5q.f5q(g);
};
E2o9h.a5q = function (g) {
    if (E2o9h && g)return E2o9h.z5q.f5q(g);
};
E2o9h.e5q = function (d) {
    if (E2o9h && d)return E2o9h.z5q.f5q(d);
};
function BimSceneNode(Z8, D, k8, k) {
    E2o9h.M5q = function (n) {
        for (; E2o9h;)return E2o9h.z5q.W5q(n);
    };
    E2o9h.Z5q = function (k) {
        for (; E2o9h;)return E2o9h.z5q.W5q(k);
    };
    E2o9h.j5q = function (j) {
        for (; E2o9h;)return E2o9h.z5q.W5q(j);
    };
    E2o9h.m5q = function (a) {
        if (E2o9h && a)return E2o9h.z5q.f5q(a);
    };
    E2o9h.y5q = function (e) {
        for (; E2o9h;)return E2o9h.z5q.W5q(e);
    };
    E2o9h.S5q = function (k) {
        for (; E2o9h;)return E2o9h.z5q.W5q(k);
    };
    this[E2o9h.q7Q] = E2o9h.e5q("b4") ? Z8 : "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
    this[E2o9h.R5Q] = E2o9h.S5q("b16e") ? "getLengths" : D;
    this[E2o9h.b1Q] = E2o9h.a5q("a5") ? k8 : 'LatheBufferGeometry';
    this[E2o9h.S7Q] = E2o9h.u5q("455") ? "ONE_MINUS_SRC_COLOR" : [];
    var H = E2o9h.n5q("5f") ? "receivedDataSize" : this;
    this[E2o9h.d1Q] = E2o9h.y5q("d3f") ? k : "z1";
    this[E2o9h.Y5Q] = E2o9h.m5q("125a") ? "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n" : function (o) {
        var N = E2o9h.R5q("417") ? 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' : "R9h",
            d = E2o9h.j5q("7cc4") ? "n9h" : "#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHTS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n\t#endif\n\n\t#if defined( SHADOWMAP_TYPE_PCSS )\n\t\t#define LIGHT_WORLD_SIZE 0.005\n\t\t#define LIGHT_FRUSTUM_WIDTH 3.75\n\t\t#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n\t\t#define NEAR_PLANE 9.5\n\n\t\t#define NUM_SAMPLES 17\n\t\t#define NUM_RINGS 11\n\t\t#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n\t\t#define PCF_NUM_SAMPLES NUM_SAMPLES\n\n\t\tvec2 poissonDisk[NUM_SAMPLES];\n\n\t\tvoid initPoissonSamples( const in vec2 randomSeed )\n\t\t{\n\t\t\tfloat ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n\t\t\tfloat INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n\t\t\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\t\t\tfloat angle = rand( randomSeed ) * PI2;\n\t\t\tfloat radius = INV_NUM_SAMPLES;\n\t\t\tfloat radiusStep = radius;\n\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\t\t\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n\t\t\t\tradius += radiusStep;\n\t\t\t\tangle += ANGLE_STEP;\n\t\t\t}\n\t\t}\n\n\t\tfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n\t\t\treturn (zReceiver - zBlocker) / zBlocker;\n\t\t}\n\n\t\tfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n\t\t\t// This uses similar triangles to compute what\n\t\t\t// area of the shadow map we should search\n\t\t\tfloat searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\n\t\t\tfloat blockerDepthSum = 0.0;\n\t\t\tint numBlockers = 0;\n\n\t\t\tfor( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\n\t\t\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\t\t\tif ( shadowMapDepth < zReceiver ) {\n\t\t\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\t\t\tnumBlockers ++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( numBlockers == 0 ) return -1.0;\n\n\t\t\treturn blockerDepthSum / float( numBlockers );\n\t\t}\n\n\t\tfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\n\t\t\tfloat sum = 0.0;\n\t\t\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\n\t\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\n\t\t\t\tif( zReceiver <= depth ) sum += 1.0;\n\t\t\t}\n\t\t\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\n\t\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\n\t\t\t\tif( zReceiver <= depth ) sum += 1.0;\n\t\t\t}\n\t\t\treturn sum / ( 2.0 * float( PCF_NUM_SAMPLES ) );\n\t\t}\n\n\t\tfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\n\t\t\tvec2 uv = coords.xy;\n\t\t\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n\t\t\tinitPoissonSamples( uv );\n\t\t\t// STEP 1: blocker search\n\t\t\tfloat avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\n\n\t\t\t//There are no occluders so early out (this saves filtering)\n\t\t\tif( avgBlockerDepth == -1.0 ) return 1.0;\n\n\t\t\t// STEP 2: penumbra size\n\t\t\tfloat penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\n\t\t\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\n\t\t\t// STEP 3: filtering\n\t\t\t//return avgBlockerDepth;\n\t\t\treturn PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\n\t\t}\n\n\t#endif\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n\t\tvec2 f = fract( uv * size + 0.5 );\n\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\n\t\treturn c;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCSS )\n\t\t  return PCSS( shadowMap, shadowCoord);\n\t\t  return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn 1.0;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the distance from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t// dp = distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n",
            G = E2o9h.Z5q("f26") ? "S9h" : "#define PREMULTIPLIED_ALPHA";
        if (E2o9h[G](H[E2o9h.q7Q], o)) {
            return H;
        }
        for (var A = E2o9h.J0Q; E2o9h[d](A, H[E2o9h.S7Q].length); A++) {
            var K = H[E2o9h.S7Q][A][E2o9h.Y5Q](o);
            if (E2o9h[N](K, E2o9h.f1Q))return K;
        }
        return E2o9h.f1Q;
    };
    this[E2o9h.f0Q] = E2o9h.M5q("ae") ? 'x' : function (o) {
        H[E2o9h.S7Q][E2o9h.Y1Q](o);
    };
}
function BimSceneElementNode(Z8, D, k8) {
    E2o9h.G7q = function (b) {
        if (E2o9h && b)return E2o9h.z5q.W5q(b);
    };
    E2o9h.d7q = function (l) {
        if (E2o9h && l)return E2o9h.z5q.f5q(l);
    };
    E2o9h.T5q = function (l) {
        for (; E2o9h;)return E2o9h.z5q.W5q(l);
    };
    E2o9h.l5q = function (e) {
        if (E2o9h && e)return E2o9h.z5q.W5q(e);
    };
    E2o9h.L5q = function (n) {
        while (n)return E2o9h.z5q.f5q(n);
    };
    E2o9h.x5q = function (h) {
        for (; E2o9h;)return E2o9h.z5q.f5q(h);
    };
    var k = E2o9h.i5q("52f2") ? "setZ" : "FileId", H = E2o9h.J5q("68") ? "value" : "FaceEndNextIndex",
        O = E2o9h.V7q("14") ? 1 : "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#endif\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        B = E2o9h.P5q("b26f") ? "maxAzimuthAngle" : "FaceStartIndex", I8 = E2o9h.Y5q("5c2") ? "EdgeMesh" : "v",
        l8 = E2o9h.p5q("34a") ? "GeometryMesh" : "vertexCount", U9 = E2o9h.d7q("6336") ? "ALWAYS" : "Element",
        E = E2o9h.o7q("8e73") ? "TypeGeometryDict" : this;
    this[E2o9h.q7Q] = E2o9h.x5q("5b6a") ? "#" : Z8;
    this[E2o9h.R5Q] = E2o9h.I5q("3c8") ? D : "configurable";
    this[E2o9h.b1Q] = E2o9h.Q7q("5e3") ? "double" : k8;
    this[E2o9h.S7Q] = E2o9h.T5q("f4") ? [] : "p_uniforms";
    this[E2o9h.d1Q] = E2o9h.N7q("d58a") ? ' extension not supported.' : U9;
    this[l8] = E2o9h.w5q("eb6") ? E2o9h.f1Q : 0xCD5C5C;
    this[I8] = E2o9h.h7q("8e6") ? 'YZX' : E2o9h.f1Q;
    this[B] = E2o9h.L5q("ba") ? -O : 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.';
    this[H] = E2o9h.G7q("88") ? "v2" : -O;
    this[k] = E2o9h.l5q("68") ? 2200 : -O;
    this[E2o9h.Y5Q] = E2o9h.C5q("44c") ? 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' : function (o) {
        E2o9h.A7q = function (h) {
            for (; E2o9h;)return E2o9h.z5q.f5q(h);
        };
        E2o9h.U5q = function (j) {
            for (; E2o9h;)return E2o9h.z5q.W5q(j);
        };
        var N = E2o9h.A7q("e322") ? "C9h" : 16,
            d = E2o9h.U5q("1285") ? 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' : "w9h",
            G = E2o9h.t7q("3bf") ? "M9h" : 'SphereGeometry';
        if (E2o9h[G](E[E2o9h.q7Q], o)) {
            return E;
        }
        for (var A = E2o9h.J0Q; E2o9h[d](A, E[E2o9h.S7Q].length); A++) {
            var K = E[E2o9h.S7Q][A][E2o9h.Y5Q](o);
            if (E2o9h[N](K, E2o9h.f1Q))return K;
        }
        return E2o9h.f1Q;
    };
}
function BimScene(b8, K8, O8) {
    E2o9h.g7q = function (n) {
        for (; E2o9h;)return E2o9h.z5q.W5q(n);
    };
    E2o9h.O7q = function (n) {
        if (E2o9h && n)return E2o9h.z5q.W5q(n);
    };
    E2o9h.W7q = function (k) {
        for (; E2o9h;)return E2o9h.z5q.f5q(k);
    };
    var h8 = E2o9h.z7q("fc") ? "FindBigMeshByType" : "Clock", D8 = E2o9h.W7q("1a") ? "FindBigMeshByFile" : "bc2far",
        E8 = "FindBigMesh", q8 = E2o9h.K7q("7616") ? "getSize" : "RayIntersection",
        R8 = E2o9h.r7q("d5b") ? "children" : "physicallyCorrectLights", s8 = "ClearTempMesh", S8 = "AddTempMesh",
        n8 = "resetElementsVisibleToBeforeSelect", J8 = E2o9h.D7q("e3") ? "showOtherElements" : "aCP1y",
        Q9 = E2o9h.k7q("5588") ? "aStartAngle" : "showElement",
        M8 = E2o9h.F7q("bf") ? "WebGLExtensions" : "watchBuildingStorey",
        d9 = E2o9h.H7q("ad1") ? "randInt" : "showBuildingStorey", C8 = E2o9h.O7q("a68f") ? "showType" : "NoTaper",
        u8 = "AddGeometryMesh", B8 = E2o9h.g7q("bb44") ? "speed" : "AddRefMesh",
        w8 = E2o9h.v7q("417") ? "invisibleBits" : "FindElementNode",
        F9 = E2o9h.b7q("c837") ? "getEncodingComponents" : "remove", g9 = E2o9h.X7q("154") ? "reset" : "removeMarker",
        e8 = "showMarker", o9 = "showAllMarker", X9 = "saveMarker", W9 = "tag",
        z9 = E2o9h.B7q("cc58") ? false : "shadowBias", t9 = E2o9h.s7q("cc") ? "LuminanceFormat" : "visible",
        G9 = "icon", B9 = "point", e9 = "id", q9 = "animateMarker", a9 = "findStoreyData", D9 = "bid2gid",
        Z9 = "gid2bid", f9 = "ElementCount", T8 = "", v9 = "#", j9 = "markersMesh", I9 = "StoreyDict",
        H9 = "BigMeshDict", r9 = "ElementGeometryDict", m9 = "FileGeometryDict", i9 = "TypeGeometryDict",
        c9 = "Elements", N4 = "domains", L9 = "Domains", a4 = "files", g4 = "Files", t4 = "edge", r4 = "BusInvMap",
        F4 = "BusMap", h4 = "hasOwnProperty", P9 = "addMarkerToScene", y4 = "forEach", c4 = "markers",
        v4 = "ElementDict", d4 = "ElementRoot", z4 = "markerGeoRoot", q4 = "add", D4 = "tempOverlayGeoRoot",
        L4 = "copy", o6 = "position", j4 = "center", Y4 = "Object3D", i4 = "overlayGeoRoot", O6 = "georoot",
        P4 = "fileId", S6 = "containsFile", B4 = "storeyId", o4 = "containsStorey", f6 = "ifctype",
        F6 = "containsDomain", l9 = true, s0 = "array", y6 = "index", r6 = "geometry", J6 = "mesh", U6 = "needsUpdate";
    function u4(N, d) {
        var G = "e4h", A = "q4h", K = "indexCount", Z8 = "indexStart", D = "indicesCopy", k8 = function (o) {
            k[U6] = o;
        }, k = N[J6][r6][y6], H = k[s0], O = N[D], B = N[Z8], I8 = N[K], l8 = B + I8;
        if (d) {
            for (var U9 = B, E = E2o9h.J0Q; E2o9h[A](U9, l8); U9++, E++) {
                var p8 = function (o) {
                    H[U9] = o[E];
                };
                p8(O);
            }
        } else {
            for (var U9 = B, E = E2o9h.J0Q; E2o9h[G](U9, l8); U9++, E++) {
                var i8 = function (o) {
                    H[U9] = o;
                };
                i8(E2o9h.J0Q);
            }
        }
        k8(l9);
    }
    function D0(o, N, d) {
        var G = "L6h", A = "x6h", K = "j6h";
        if (E2o9h[K](N, undefined)) {
            return;
        }
        for (var Z8 = E2o9h.J0Q; E2o9h[A](Z8, N.length); Z8++) {
            var D = N[Z8];
            if (E2o9h[G](D, E2o9h.f1Q))continue;
            if (d && (o[F6](D[f6]) || o[o4](D[B4]) || o[S6](D[P4])))continue;
            u4(D, d);
            R0(D, d);
        }
    }
    function L6() {
        var N = "DataServerTreeLoaded", d = "SYS_EVENT", G = "addListener", A = "Q4h", K = "ElementNodes", Z8 = "Group",
            D = "T9h", k8 = "GroupList", k = "z", H = "y", O = "x", B = "BoundingBox", I8 = "Clone",
            l8 = "BuildingStorey", U9 = "GlobalId", E = "J9h", p8 = "spaces", i8 = "Z", e = "Y", S = "X", u = "Vector3",
            n = "translate", m = "name", R = "type", I = function (o) {
                Y9[O6][R] = o;
            }, L = function (o) {
                Y9[i4][R] = o;
            }, b6 = function (o) {
                Y9[i4][m] = o;
            }, J = function (o) {
                Y9[O6][m] = o;
            };
        Y9[O6] = new THREE[Y4]();
        J(O6);
        I(n);
        Y9[j4] = new THREE[u](-b8[j4][S], -b8[j4][e], -b8[j4][i8]);
        Y9[O6][o6][L4](Y9[j4]);
        Y9[i4] = new THREE[Y4]();
        b6(O6);
        L(n);
        Y9[i4][o6][L4](Y9[j4]);
        Y9[D4] = new THREE[Y4]();
        Y9[i4][q4](Y9[D4]);
        Y9[z4] = new THREE[Y4]();
        Y9[i4][q4](Y9[z4]);
        var T = b8[p8];
        if (T) {
            for (var u9 = E2o9h.J0Q; E2o9h[E](u9, T.length); u9++) {
                var i = function (o) {
                    g6[U[E2o9h.q7Q]] = o;
                };
                var U = T[u9], j = new BimSceneNode(U[U9], U[E2o9h.R5Q], U[E2o9h.b1Q], l8);
                Y9[d4][E2o9h.f0Q](j);
                var y9 = BIMVIZ[I8](U[B]);
                y9[S] += Y9[j4][O];
                y9[e] += Y9[j4][H];
                y9[i8] += Y9[j4][k];
                i(y9);
                var V8 = U[k8];
                for (var v0 = E2o9h.J0Q; E2o9h[D](v0, V8.length); v0++) {
                    var Q8 = V8[v0], N8 = new BimSceneNode(Q8[U9], Q8[E2o9h.R5Q], Q8[E2o9h.b1Q], Z8);
                    j[E2o9h.f0Q](N8);
                    var H8 = Q8[K];
                    for (var t8 = E2o9h.J0Q; E2o9h[A](t8, H8.length); t8++) {
                        var A8 = function (o) {
                            Y9[v4][W8[U9]] = o;
                        };
                        var W8 = H8[t8], v8 = new BimSceneElementNode(W8[U9], W8[E2o9h.R5Q], W8[E2o9h.b1Q]);
                        N8[E2o9h.f0Q](v8);
                        A8(v8);
                    }
                }
            }
        }
        b8[c4][y4](function (o) {
            Y9[P9](o);
        });
        O8[G](BIMVIZ[d][N], b0);
    }
    function b0(N) {
        var d = "busmap", G = "args", A = N[G];
        for (var K in A[d]) {
            if (A[d][h4](K)) {
                var Z8 = function (o) {
                    Y9[F4][K] = o;
                }, D = function (o) {
                    Y9[r4][k8] = o;
                };
                var k8 = A[d][K];
                Z8(k8);
                D(K);
            }
        }
    }
    function R0(N, d) {
        var G = "Z4h", A = "m4h", K = "edgeCount", Z8 = "edgeStart", D = "u4h", k8 = function (o) {
            k[U6] = o;
        };
        if (E2o9h[D](N[t4], E2o9h.f1Q))return;
        var k = N[t4][r6][y6], H = k[s0], O = N[Z8], B = N[K], I8 = O + B;
        if (d) {
            for (var l8 = O, U9 = E2o9h.J0Q; E2o9h[A](l8, I8); l8++, U9++) {
                var E = function (o) {
                    H[l8] = o;
                };
                E(l8);
            }
        } else {
            for (var l8 = O, U9 = E2o9h.J0Q; E2o9h[G](l8, I8); l8++, U9++) {
                var p8 = function (o) {
                    H[l8] = o;
                };
                p8(E2o9h.J0Q);
            }
        }
        k8(l9);
    }
    this[g4] = b8[a4];
    this[L9] = b8[N4];
    this[c9] = [];
    var Y9 = this;
    this[O6] = E2o9h.f1Q;
    this[i4] = E2o9h.f1Q;
    this[D4] = E2o9h.f1Q;
    this[z4] = E2o9h.f1Q;
    this[i9] = new Array();
    this[m9] = new Array();
    this[r9] = new Array();
    this[H9] = new Array();
    this[v4] = new Array();
    this[I9] = new Array();
    this[F4] = new Array();
    this[r4] = new Array();
    this[j4] = E2o9h.f1Q;
    this[c4] = new Array();
    this[j9] = new Array();
    var g6 = new Array();
    this[d4] = new BimSceneNode(v9, T8, T8);
    this[f9] = E2o9h.J0Q;
    ;
    this[Z9] = function (o) {
        var N = Y9[r4][o];
        if (N) {
            return N;
        }
        return E2o9h.f1Q;
    };
    this[D9] = function (o) {
        var N = Y9[F4][o];
        if (N) {
            return N;
        }
        return E2o9h.f1Q;
    };
    ;
    this[a9] = function (o) {
        return g6[o];
    };
    this[q9] = function (o) {
        var N = Y9[c4][o], d = Y9[j9][o];
        if (d) {
            K8[q9](d);
        }
    };
    this[P9] = function (o) {
        var N = "createMarker";
        Y9[c4][o[e9]] = o;
        var d = K8[N](o[B9], o[G9]);
        d[t9] = z9;
        d[W9] = o;
        Y9[j9][o[e9]] = d;
        Y9[z4][q4](d);
    };
    this[X9] = function (o) {
        var N = "updateMarkerMeshIcon", d = Y9[j9][o[e9]];
        if (d) {
            d[o6][L4](o[B9]);
            K8[N](d, o[G9]);
        }
    };
    this[o9] = function (o) {
        for (var N in Y9[j9]) {
            if (Y9[j9][h4](N)) {
                var d = Y9[j9][N];
                d[t9] = o;
            }
        }
    };
    this[e8] = function (o, N) {
        var d = Y9[j9][o];
        if (d) {
            d[t9] = N;
        }
    };
    this[g9] = function (o) {
        var N = "material", d = "dispose", G = Y9[c4][o], A = Y9[j9][o];
        if (G) {
            Y9[c4][o];
        }
        if (A) {
            A[r6][d]();
            A[N][d]();
            Y9[z4][F9](A);
            delete  Y9[j9][o];
        }
    };
    this[E2o9h.Y5Q] = function (o) {
        var N = Y9[d4][E2o9h.Y5Q](o);
        return N;
    };
    this[w8] = function (o) {
        var N = Y9[v4][o];
        return N;
    };
    this[B8] = function (o, N) {
        var d = new THREE[Y4]();
        d[q4](o);
        Y9[O6][q4](d);
    };
    this[u8] = function (o, N, d, G, A, K) {
        var Z8 = "B4h", D = "elementId", k8 = "v4h", k = "H4h", H = "D4h", O = "W4h", B = "t4h", I8 = "V4h",
            l8 = new THREE[Y4]();
        l8[q4](N);
        if (E2o9h[I8](d, E2o9h.f1Q)) {
            l8[q4](d);
        }
        Y9[O6][q4](l8);
        var U9 = Y9[m9][A];
        if (E2o9h[B](U9, E2o9h.f1Q)) {
            U9 = [];
            Y9[m9][A] = U9;
        }
        if (E2o9h[O](N, E2o9h.f1Q)) {
            U9[E2o9h.Y1Q](N);
        }
        if (E2o9h[H](d, E2o9h.f1Q)) {
            U9[E2o9h.Y1Q](d);
        }
        Y9[H9][o] = N;
        for (var E = E2o9h.J0Q; E2o9h[k](E, K.length); E++) {
            var p8 = K[E];
            p8[J6] = N;
            p8[t4] = d;
            var i8 = Y9[I9][p8[B4]];
            if (!i8) {
                i8 = [];
                Y9[I9][p8[B4]] = i8;
            }
            i8[E2o9h.Y1Q](p8);
            var e = Y9[i9][p8[f6]];
            if (E2o9h[k8](e, E2o9h.f1Q)) {
                e = [];
                Y9[i9][p8[f6]] = e;
            }
            e[E2o9h.Y1Q](p8);
            var S = Y9[r9][p8[D]];
            if (E2o9h[Z8](S, E2o9h.f1Q)) {
                S = [];
                Y9[r9][p8[D]] = S;
            }
            S[E2o9h.Y1Q](p8);
        }
    };
    this[C8] = function (o, N, d) {
        var G = "p4h", A = "i4h", K = "l4h", Z8 = "I4h", D = Y9[i9][N];
        if (E2o9h[Z8](D, undefined)) {
            return;
        }
        for (var k8 = E2o9h.J0Q; E2o9h[K](k8, D.length); k8++) {
            var k = D[k8];
            if (E2o9h[A](k, undefined) || E2o9h[G](k, E2o9h.f1Q))continue;
            if (d && (o[S6](k[P4]) || o[o4](k[B4])))continue;
            u4(k, d);
            R0(k, d);
        }
    };
    this[d9] = function (o, N, d) {
        var G = "z6h", A = "G6h", K = "d6h", Z8 = "o6h", D = Y9[I9][N];
        if (E2o9h[Z8](D, undefined)) {
            return;
        }
        for (var k8 = E2o9h.J0Q; E2o9h[K](k8, D.length); k8++) {
            var k = D[k8];
            if (E2o9h[A](k, undefined) || E2o9h[G](k, E2o9h.f1Q))continue;
            if (d && (o[S6](k[P4]) || o[F6](k[f6])))continue;
            u4(k, d);
            R0(k, d);
        }
    };
    this[M8] = function (o, N) {
        var d = "TopFrontRight", G = "BoxPosition", A = "setLookBoxFrom", K = g6[o];
        K8[A](K, BIMVIZ[G][d], l9, N);
    };
    this[Q9] = function (o, N, d) {
        var G = "r6h";
        if (E2o9h[G](N, E2o9h.f1Q))return;
        var A = Y9[r9][N];
        D0(o, A, d);
    };
    this[J8] = function (o, N, d) {
        var G = "g6h", A = "F6h";
        if (E2o9h[A](N, E2o9h.f1Q))return;
        for (var K in Y9[r9]) {
            if (E2o9h[G](K, N)) {
                D0(o, Y9[r9][K], d);
            } else {
                D0(o, Y9[r9][K], !d);
            }
        }
    };
    this[n8] = function (o) {
        var N = "y6h", d = "a6h", G = "f6h", A = "c6h", K = "X6h";
        if (E2o9h[K](o, E2o9h.f1Q))return;
        for (var Z8 in Y9[r9]) {
            var D = Y9[r9][Z8];
            if (E2o9h[A](D, undefined) || E2o9h[G](D, E2o9h.f1Q))continue;
            for (var k8 = E2o9h.J0Q; E2o9h[d](k8, D.length); k8++) {
                var k = D[k8];
                if (E2o9h[N](k, E2o9h.f1Q))continue;
                var H = l9;
                if (o[F6](k[f6]) || o[o4](k[B4]) || o[S6](k[P4])) {
                    H = z9;
                }
                u4(k, H);
                R0(k, H);
            }
        }
    };
    ;
    this[S8] = function (o) {
        Y9[D4][q4](o);
    };
    this[s8] = function () {
        var N = "slice", d = Y9[D4][R8][N](E2o9h.J0Q);
        d[y4](function (o) {
            Y9[D4][F9](o);
        });
    };
    this[q8] = function (o) {
        var N = "distance", d = "object", G = "P6h", A = "U6h", K = "intersectObjects", Z8 = [],
            D = o[K](Y9[z4][R8], l9);
        if (E2o9h[A](D.length, E2o9h.J0Q)) {
            for (var k8 = E2o9h.J0Q; E2o9h[G](k8, D.length); k8++) {
                var k = D[k8], H = k[d][W9];
                if (H) {
                    var O = {userdata: H, distance: k[N], point: k[B9]};
                    Z8[E2o9h.Y1Q](O);
                }
            }
        }
        return Z8;
    };
    this[E8] = function (o) {
        var N = Y9[H9][o];
        return N;
    };
    this[D8] = function (o) {
        var N = Y9[m9][o];
        return N;
    };
    this[h8] = function (o) {
        var N = Y9[i9][o];
        return N;
    };
    L6();
};var K5j8e = {
    'B5e': function (M, K) {
        return M > K;
    }, 'S6q': 2, 'v7q': "file", 'w3e': function (M, K) {
        return M < K;
    }, 'r0q': "changeMeshIndex", 'y6q': true, 'J6q': "edgeCount", 'L3e': function (M, K) {
        return M > K;
    }, 'R0q': "visibility", 'w0q': "colorsNeedUpdate", 'S9e': function (M, K) {
        return M < K;
    }, 'V1h': "getAttribute", 'n0q': "add", 'M9e': function (M, K) {
        return M < K;
    }, 'c7q': "edgeStart", 'C5e': function (M, K) {
        return M > K;
    }, 'j0q': "mesh", 'f5e': function (M, K) {
        return M < K;
    }, 'l8e': function (M, K) {
        return M == K;
    }, 'K5e': function (M, K) {
        return M * K;
    }, 'Y3e': function (M, K) {
        return M < K;
    }, 'b9e': function (M, K) {
        return M < K;
    }, 'I6q': 100, 'w6q': "ifctype", 't6q': 0, 'Y0q': "geometry", 'k0q': "indexCount", 'V9e': function (M, K) {
        return M < K;
    }, 'G5e': function (M, K) {
        return M < K;
    }, 'l0q': "RefMeshDict", 'a5e': function (M, K) {
        return M * K;
    }, 'K0q': "edgemesh", 'j3e': function (M, K) {
        return M < K;
    }, 'w25': (function (M45) {
        return (function (W45, N45) {
            return (function (L45) {
                return {o25: L45, a45: L45,};
            })(function (H25) {
                var T45, l25 = 0;
                for (var S45 = W45; l25 < H25["length"]; l25++) {
                    var f45 = N45(H25, l25);
                    T45 = l25 === 0 ? f45 : T45 ^ f45;
                }
                return T45 ? S45 : !S45;
            });
        })((function (K45, O25, y25, c45) {
            var A25 = 30;
            return K45(M45, A25) - c45(O25, y25) > A25;
        })(parseInt, Date, (function (O25) {
            return ('' + O25)["substring"](1, (O25 + '')["length"] - 1);
        })('_getTime2'), function (O25, y25) {
            return new O25()[y25]();
        }), function (H25, l25) {
            var r25 = parseInt(H25["charAt"](l25), 16)["toString"](2);
            return r25["charAt"](r25["length"] - 1);
        });
    })('b0d06k000'), 'u9e': function (M, K) {
        return M == K;
    }, 'R9e': function (M, K) {
        return M == K;
    }, 'b6q': "changeRGBA", 'a7q': "KeyDict", 'H9q': "mkey", 'n5e': function (M, K) {
        return M < K;
    }, 'F6q': null, 'h7q': "push", 'j9q': "Unit", 'L7q': 65535, 'i0q': "transparent", 'X3e': function (M, K) {
        return M >= K;
    }, 'Q9e': function (M, K) {
        return M == K;
    }, 'z5e': function (M, K) {
        return M > K;
    }, 'c6q': "elementId", 'G0q': "needsUpdate", 'D0q': "dict", 't9e': function (M, K) {
        return M == K;
    }, 'm5e': function (M, K) {
        return M < K;
    }, 'v5e': function (M, K) {
        return M != K;
    }, 'b7q': "floor", 'i5e': function (M, K) {
        return M > K;
    }, 'O3e': function (M, K) {
        return M / K;
    }, 'i6q': "BatMesh", 'd6q': "units", 'o6q': "fileId", 'r9q': "index", 'o8e': function (M, K) {
        return M < K;
    }, 'H3e': function (M, K) {
        return M < K;
    }, 't0q': "material", 'o0q': "RefMesh", 'O0q': "indicesCopy", 'q3e': function (M, K) {
        return M > K;
    }, 'U5e': function (M, K) {
        return M > K;
    }, 's3e': function (M, K) {
        return M > K;
    }, 'S1h': "renderOrder", 'b8e': function (M, K) {
        return M == K;
    }, 'L1h': "color", 'J9e': function (M, K) {
        return M == K;
    }, 'D7q': "show", 'h3e': function (M, K) {
        return M > K;
    }, 'r7q': "domain", 'd5e': function (M, K) {
        return M == K;
    }, 'd7q': "array", 'W5e': function (M, K) {
        return M < K;
    }, 'A8e': function (M, K) {
        return M < K;
    }, 'T6q': 3, 'L0q': "rgba", 'O6q': "get", 'E9e': function (M, K) {
        return M == K;
    }, 'c3e': function (M, K) {
        return M < K;
    }, 'e3e': function (M, K) {
        return M > K;
    }, 'F8e': function (M, K) {
        return M == K;
    }, 'r5e': function (M, K) {
        return M < K;
    }, 'V6q': 4, 'G9q': "storeyId", 'Z3e': function (M, K) {
        return M > K;
    }, 'k9e': function (M, K) {
        return M < K;
    }, 'S7q': "D3", 'P3e': function (M, K) {
        return M < K;
    }, 'a0q': "size", 'i7q': "indexStart", 'k7q': "BatMeshDict", 'y5e': function (M, K) {
        return M < K;
    }, 'W6q': 1, 'p3e': function (M, K) {
        return M == K;
    }, 'z0q': "matrix", 's0q': "Manager", 'f1h': "mix", 'N3e': function (M, K) {
        return M < K;
    }, 'T9e': function (M, K) {
        return M < K;
    }, 'I3e': function (M, K) {
        return M == K;
    }, 'g9e': function (M, K) {
        return M != K;
    }, 'D5e': function (M, K) {
        return M != K;
    }, 'x9e': function (M, K) {
        return M == K;
    }
};
K5j8e.S85 = function (l) {
    for (; K5j8e;)return K5j8e.w25.a45(l);
};
K5j8e.N85 = function (k) {
    for (; K5j8e;)return K5j8e.w25.o25(k);
};
K5j8e.f85 = function (i) {
    while (i)return K5j8e.w25.a45(i);
};
K5j8e.T85 = function (h) {
    while (h)return K5j8e.w25.o25(h);
};
K5j8e.K85 = function (h) {
    while (h)return K5j8e.w25.o25(h);
};
K5j8e.A45 = function (j) {
    for (; K5j8e;)return K5j8e.w25.a45(j);
};
K5j8e.O45 = function (n) {
    while (n)return K5j8e.w25.o25(n);
};
K5j8e.l45 = function (k) {
    for (; K5j8e;)return K5j8e.w25.a45(k);
};
K5j8e.H45 = function (n) {
    for (; K5j8e;)return K5j8e.w25.a45(n);
};
K5j8e.r45 = function (a) {
    if (K5j8e && a)return K5j8e.w25.o25(a);
};
K5j8e.o45 = function (f) {
    if (K5j8e && f)return K5j8e.w25.a45(f);
};
K5j8e.v45 = function (j) {
    if (K5j8e && j)return K5j8e.w25.a45(j);
};
K5j8e.F45 = function (c) {
    if (K5j8e && c)return K5j8e.w25.a45(c);
};
K5j8e.I45 = function (g) {
    for (; K5j8e;)return K5j8e.w25.a45(g);
};
K5j8e.D45 = function (e) {
    if (K5j8e && e)return K5j8e.w25.o25(e);
};
K5j8e.G45 = function (k) {
    for (; K5j8e;)return K5j8e.w25.a45(k);
};
K5j8e.g45 = function (l) {
    while (l)return K5j8e.w25.o25(l);
};
K5j8e.P45 = function (e) {
    while (e)return K5j8e.w25.a45(e);
};
K5j8e.d45 = function (f) {
    if (K5j8e && f)return K5j8e.w25.o25(f);
};
K5j8e.J45 = function (c) {
    while (c)return K5j8e.w25.o25(c);
};
K5j8e.s45 = function (n) {
    if (K5j8e && n)return K5j8e.w25.a45(n);
};
K5j8e.C45 = function (k) {
    for (; K5j8e;)return K5j8e.w25.o25(k);
};
K5j8e.Y45 = function (a) {
    for (; K5j8e;)return K5j8e.w25.o25(a);
};
K5j8e.z45 = function (a) {
    while (a)return K5j8e.w25.o25(a);
};
K5j8e.Q45 = function (c) {
    if (K5j8e && c)return K5j8e.w25.a45(c);
};
K5j8e.R45 = function (l) {
    for (; K5j8e;)return K5j8e.w25.a45(l);
};
K5j8e.h45 = function (m) {
    if (K5j8e && m)return K5j8e.w25.o25(m);
};
K5j8e.n45 = function (i) {
    for (; K5j8e;)return K5j8e.w25.a45(i);
};
K5j8e.Z45 = function (k) {
    for (; K5j8e;)return K5j8e.w25.a45(k);
};
K5j8e.m45 = function (n) {
    for (; K5j8e;)return K5j8e.w25.a45(n);
};
K5j8e.V45 = function (i) {
    if (K5j8e && i)return K5j8e.w25.a45(i);
};
function getBatMeshKey(M, K, T) {
    K5j8e.e45 = function (d) {
        while (d)return K5j8e.w25.a45(d);
    };
    K5j8e.B45 = function (n) {
        if (K5j8e && n)return K5j8e.w25.o25(n);
    };
    K5j8e.u45 = function (d) {
        if (K5j8e && d)return K5j8e.w25.o25(d);
    };
    K5j8e.q45 = function (a) {
        while (a)return K5j8e.w25.o25(a);
    };
    var f = K5j8e.q45("e6fe") ? ":" : 'hotpink', N = K5j8e.V45("5df7") ? 'insti_paras_vertex' : 'O',
        S = K5j8e.m45("87e") ? 'T' : '#define USE_FOG',
        W = K5j8e.Z45("13") ? 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' : "F8e",
        L = K5j8e.u45("ab51") ? 'E' : "n1", V = K5j8e.n45("43d") ? 'finished' : 'F',
        m = K5j8e.h45("7537") ? 'Int16Array' : "b8e",
        u = K5j8e.R45("7b7") ? K5j8e[m](K, K5j8e.y6q) ? V : L : "not allow bimviz to use IndexedDB",
        n = K5j8e.B45("34ce") ? K5j8e[W](T, K5j8e.y6q) ? S : N : "/api/",
        R = K5j8e.e45("ce3d") ? 'Points' : M + f + n + f + u;
    return R;
};BIMVIZ[K5j8e.S7q][K5j8e.j9q] = function (M, K) {
    K5j8e.w45 = function (h) {
        if (K5j8e && h)return K5j8e.w25.a45(h);
    };
    K5j8e.b45 = function (d) {
        while (d)return K5j8e.w25.a45(d);
    };
    K5j8e.j45 = function (j) {
        if (K5j8e && j)return K5j8e.w25.o25(j);
    };
    K5j8e.X45 = function (m) {
        if (K5j8e && m)return K5j8e.w25.a45(m);
    };
    K5j8e.U45 = function (h) {
        while (h)return K5j8e.w25.o25(h);
    };
    K5j8e.x45 = function (j) {
        if (K5j8e && j)return K5j8e.w25.o25(j);
    };
    K5j8e.k45 = function (j) {
        while (j)return K5j8e.w25.o25(j);
    };
    K5j8e.E45 = function (b) {
        while (b)return K5j8e.w25.a45(b);
    };
    K5j8e.p45 = function (g) {
        for (; K5j8e;)return K5j8e.w25.o25(g);
    };
    K5j8e.i45 = function (e) {
        if (K5j8e && e)return K5j8e.w25.o25(e);
    };
    var T = K5j8e.Q45("b6d3") ? 1.0 : "morphNormals", f = K5j8e.i45("64d") ? "o8e" : 'WEBGL_lose_context',
        N = K5j8e.p45("27f") ? "blendDstAlpha" : "mtype", S = K5j8e.E45("474") ? "invisibleBits" : "emcol0",
        W = K5j8e.z45("bdc3") ? "meshId" : "setValue", L = K5j8e.Y45("4cb") ? "id" : "materialLoader";
    this[L] = K5j8e.P45("818") ? M[W] : "numPointLights";
    this[K5j8e.r9q] = K5j8e.g45("1aba") ? 'Uint8Array' : M[K5j8e.r9q];
    this[K5j8e.z0q] = K5j8e.F45("a1") ? M[K5j8e.z0q] : "skyColor";
    this[K5j8e.L1h] = K5j8e.v45("be7c") ? 'SpotLight' : M[K5j8e.L1h];
    this[K5j8e.v7q] = K5j8e.G45("4d") ? M[K5j8e.o6q] : 'ENVMAP_TYPE_CUBE_UV';
    this[K5j8e.r7q] = K5j8e.D45("fcef") ? 'mapDiffuse' : M[K5j8e.w6q];
    this[K5j8e.b7q] = K5j8e.j45("e5") ? M[K5j8e.G9q] : "toneMapping";
    this[S] = K5j8e.b45("5cf2") ? 'MS' : K5j8e.t6q;
    this[K5j8e.j0q] = K5j8e.w45("75a4") ? "Stats" : K;
    this[K5j8e.i7q] = K5j8e.k45("11") ? 'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );' : M[K5j8e.i7q];
    this[K5j8e.k0q] = K5j8e.C45("44b7") ? '#define USE_EMISSIVEMAP' : M[K5j8e.k0q];
    this[K5j8e.c6q] = K5j8e.s45("7e") ? M[K5j8e.c6q] : 'Light';
    this[K5j8e.c7q] = K5j8e.x45("71d") ? M[K5j8e.c7q] : "precision";
    this[K5j8e.J6q] = K5j8e.X45("6d5e") ? "distanceRGBA" : M[K5j8e.J6q];
    this[K5j8e.O0q] = K5j8e.J45("88b") ? M[K5j8e.O0q] : 'touchend';
    this[N] = K5j8e.U45("a124") ? M[N] : "skyGeo";
    this[K5j8e.i0q] = K5j8e.d45("c1") ? K5j8e[f](this[K5j8e.L1h][K5j8e.T6q], T) : 'sandybrown';
    this[K5j8e.R0q] = K5j8e.I45("2c") ? "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif" : K5j8e.y6q;
};
BIMVIZ.D3.Unit.prototype = K5j8e.o45("3ea") ? {
    constructor: BIMVIZ[K5j8e.S7q][K5j8e.j9q], show: function (M) {
        K5j8e.y45 = function (i) {
            if (K5j8e && i)return K5j8e.w25.o25(i);
        };
        var K = K5j8e.y45("c636") ? "l8e" : 'depth';
        if (K5j8e[K](this[K5j8e.R0q], M))return;
        this[K5j8e.j0q][K5j8e.D7q](this, M);
        this[K5j8e.R0q] = K5j8e.r45("bd11") ? "closePath" : M;
    },
} : 2048;
BIMVIZ[K5j8e.S7q][K5j8e.o0q] = K5j8e.H45("84") ? 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' : function (M, K, T) {
    K5j8e.M85 = function (e) {
        if (K5j8e && e)return K5j8e.w25.a45(e);
    };
    var f = K5j8e.l45("e44") ? 'mousewheel' : "A8e";
    this[K5j8e.d6q] = K5j8e.O45("57") ? "BottomCenter" : [];
    this[K5j8e.j0q] = K5j8e.A45("5c26") ? M : "grid";
    this[K5j8e.K0q] = K5j8e.M85("bc") ? K : "cross";
    var N = K5j8e.K85("e61") ? this : "uniformMatrix3fv";
    for (var S = K5j8e.t6q, W = T.length; K5j8e[f](S, W); S++) {
        var L = new BIMVIZ[K5j8e.S7q][K5j8e.j9q](T[S], N);
        N[K5j8e.d6q][K5j8e.h7q](L);
    }
};
BIMVIZ.D3.RefMesh.prototype = {
    constructor: BIMVIZ[K5j8e.S7q][K5j8e.o0q], changeMeshIndex: function (M, K) {
        K5j8e.c85 = function (j) {
            while (j)return K5j8e.w25.a45(j);
        };
        var T = K5j8e.c85("1632") ? 'uv2' : 14, f = 13, N = 12, S = 10, W = 9, L = 8, V = 6,
            m = K5j8e.T85("46b1") ? "translate" : 5, u = "setXYZ", n = "mcol3",
            R = K5j8e.f85("8fab") ? 0.837255 : "mcol2", B = K5j8e.N85("5c7") ? "flipEnvMap" : "mcol1", e = "mcol0",
            Q = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.V1h](e),
            i = K5j8e.S85("4b6b") ? 'THREE.WebGLShader: gl.getShaderInfoLog()' : this[K5j8e.j0q][K5j8e.Y0q][K5j8e.V1h](B),
            E = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.V1h](R), k = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.V1h](n),
            U = M[K5j8e.r9q], J = M[K5j8e.z0q];
        if (K) {
            Q[u](U, J[K5j8e.t6q], J[K5j8e.W6q], J[K5j8e.S6q]);
            i[u](U, J[K5j8e.V6q], J[m], J[V]);
            E[u](U, J[L], J[W], J[S]);
            k[u](U, J[N], J[f], J[T]);
        } else {
            Q[u](U, K5j8e.t6q, K5j8e.t6q, K5j8e.t6q);
            i[u](U, K5j8e.t6q, K5j8e.t6q, K5j8e.t6q);
            E[u](U, K5j8e.t6q, K5j8e.t6q, K5j8e.t6q);
            k[u](U, K5j8e.t6q, K5j8e.t6q, K5j8e.t6q);
        }
        Q[K5j8e.G0q] = K5j8e.y6q;
        i[K5j8e.G0q] = K5j8e.y6q;
        E[K5j8e.G0q] = K5j8e.y6q;
        k[K5j8e.G0q] = K5j8e.y6q;
    }, show: function (M, K) {
        this[K5j8e.r0q](M, K);
    }, resetRGBA: function (M) {
        this[K5j8e.b6q](M, M[K5j8e.L1h]);
    }, changeRGBA: function (M, K) {
        var T = "p3e", f = "e3e", N = "h3e", S = "Z3e", W = "q3e", L = "L3e", V = "N3e", m = "c3e", u = "setXYZW",
            n = M[K5j8e.r9q], R = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.V1h](K5j8e.L1h);
        R[u](n, K[K5j8e.t6q], K[K5j8e.W6q], K[K5j8e.S6q], K[K5j8e.T6q]);
        var B = K5j8e.t6q, e = K5j8e.t6q, Q = R[K5j8e.d7q];
        for (var n = K5j8e.t6q, i = Q.length; K5j8e[m](n, i); n += K5j8e.V6q) {
            var E = n + K5j8e.T6q;
            if (K5j8e[V](Q[E], K5j8e.W6q)) {
                B++;
            } else {
                e++;
            }
            if (K5j8e[L](e, K5j8e.t6q) && K5j8e[W](B, K5j8e.t6q)) {
                break;
            }
        }
        R[K5j8e.G0q] = K5j8e.y6q;
        this[K5j8e.j0q][K5j8e.Y0q][K5j8e.w0q] = K5j8e.y6q;
        this[K5j8e.j0q][K5j8e.t0q][K5j8e.i0q] = K5j8e[S](B, K5j8e.t6q);
        this[K5j8e.j0q][K5j8e.t0q][K5j8e.f1h] = K5j8e[N](e, K5j8e.t6q) && K5j8e[f](B, K5j8e.t6q);
        if (K5j8e[T](this[K5j8e.j0q][K5j8e.t0q][K5j8e.f1h], K5j8e.y6q)) {
            this[K5j8e.j0q][K5j8e.S1h] = K5j8e.I6q;
        }
    }
};
var MaxIndices = K5j8e.L7q;
BIMVIZ[K5j8e.S7q][K5j8e.i6q] = function (M, K, T) {
    var f = "updateCacheInfo", N = "opacity", S = "b", W = "g", L = "r", V = "Y3e", m = "firstMaterial";
    this[K5j8e.d6q] = [];
    this[K5j8e.j0q] = M;
    this[K5j8e.K0q] = K;
    var u = K ? K[K5j8e.t0q] : K5j8e.F6q;
    this[m] = {m1: M[K5j8e.t0q], m2: u};
    var n = this;
    for (var R = K5j8e.t6q, B = T.length; K5j8e[V](R, B); R++) {
        var e = new BIMVIZ[K5j8e.S7q][K5j8e.j9q](T[R], n);
        n[K5j8e.d6q][K5j8e.h7q](e);
    }
    this[K5j8e.L0q] = [M[K5j8e.t0q][K5j8e.L1h][L], M[K5j8e.t0q][K5j8e.L1h][W], M[K5j8e.t0q][K5j8e.L1h][S], M[K5j8e.t0q][N]];
    this[K5j8e.a0q] = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.r9q][K5j8e.d7q].length;
    this[f]();
};
BIMVIZ.D3.BatMesh.prototype = {
    constructor: BIMVIZ[K5j8e.S7q][K5j8e.i6q], willFull: function (M) {
        var K = "s3e";
        return K5j8e[K](this[K5j8e.a0q] + M, MaxIndices);
    }, updateCacheInfo: function () {
        var M = 'B', K = "X3e";
        this[K5j8e.a0q] = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.r9q][K5j8e.d7q].length;
        var T = K5j8e[K](this[K5j8e.a0q], MaxIndices);
        this[K5j8e.H9q] = getBatMeshKey(M, T, this[K5j8e.j0q][K5j8e.t0q][K5j8e.i0q]);
    }, changeMeshIndex: function (M, K) {
        var T = "j3e", f = "P3e", N = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.r9q], S = N[K5j8e.d7q], W = M[K5j8e.O0q],
            L = M[K5j8e.i7q], V = M[K5j8e.k0q], m = L + V;
        if (K) {
            for (var u = L, n = K5j8e.t6q; K5j8e[f](u, m); u++, n++) {
                S[u] = W[n];
            }
        } else {
            for (var u = L, n = K5j8e.t6q; K5j8e[T](u, m); u++, n++) {
                S[u] = K5j8e.t6q;
            }
        }
        N[K5j8e.G0q] = K5j8e.y6q;
    }, changeEdgeIndex: function (M, K) {
        var T = "H3e", f = "w3e", N = "I3e";
        if (K5j8e[N](this[K5j8e.K0q], K5j8e.F6q))return;
        var S = this[K5j8e.K0q][K5j8e.Y0q][K5j8e.r9q], W = S[K5j8e.d7q], L = M[K5j8e.c7q], V = M[K5j8e.J6q], m = L + V;
        if (K) {
            for (var u = L, n = K5j8e.t6q; K5j8e[f](u, m); u++, n++) {
                W[u] = u;
            }
        } else {
            for (var u = L, n = K5j8e.t6q; K5j8e[T](u, m); u++, n++) {
                W[u] = K5j8e.t6q;
            }
        }
        S[K5j8e.G0q] = K5j8e.y6q;
    }, show: function (M, K) {
        var T = "changeEdgeIndex";
        this[K5j8e.r0q](M, K);
        this[T](M, K);
    }, getOrUpgradeColorBuffer: function () {
        var M = '', K = "defines", T = "Color", f = "VertexColors", N = "vertexColors", S = "addAttribute",
            W = "BufferAttribute", L = "f5e", V = "K5e", m = "O3e", u = 'position', n = 'color',
            R = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.V1h](n);
        if (!R) {
            var B = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.V1h](u)[K5j8e.d7q], e = K5j8e[m](B.length, K5j8e.T6q),
                Q = new Float32Array(K5j8e[V](e, K5j8e.V6q));
            for (var i = K5j8e.t6q, E = K5j8e.t6q; K5j8e[L](i, e); i++) {
                Q[E++] = this[K5j8e.L0q][K5j8e.t6q];
                Q[E++] = this[K5j8e.L0q][K5j8e.W6q];
                Q[E++] = this[K5j8e.L0q][K5j8e.S6q];
                Q[E++] = this[K5j8e.L0q][K5j8e.T6q];
            }
            R = new THREE[W](Q, K5j8e.V6q);
            this[K5j8e.j0q][K5j8e.Y0q][S](n, R);
            this[K5j8e.j0q][K5j8e.Y0q][K5j8e.w0q] = K5j8e.y6q;
            this[K5j8e.j0q][K5j8e.t0q][N] = THREE[f];
            this[K5j8e.j0q][K5j8e.t0q][K5j8e.L1h] = new THREE[T](0xffffff);
            this[K5j8e.j0q][K5j8e.t0q][K] = {USE_COLOR_OPACITY: M};
            this[K5j8e.j0q][K5j8e.t0q][K5j8e.G0q] = K5j8e.y6q;
        }
        return R;
    }, resetRGBA: function (M) {
        this[K5j8e.b6q](M, M[K5j8e.L1h]);
    }, changeRGBA: function (M, K) {
        var T = "d5e", f = "U5e", N = "C5e", S = "z5e", W = "i5e", L = "B5e", V = "n5e", m = "m5e", u = "a5e",
            n = "W5e", R = "getOrUpgradeColorBuffer", B = this[R](), e = this[K5j8e.j0q][K5j8e.Y0q][K5j8e.r9q],
            Q = M[K5j8e.O0q], i = K5j8e.t6q, E = M[K5j8e.k0q], k = i + E, U = B[K5j8e.d7q];
        for (var J = i; K5j8e[n](J, k); J++) {
            var P = K5j8e[u](Q[J], K5j8e.V6q);
            U[P] = K[K5j8e.t6q];
            U[P + K5j8e.W6q] = K[K5j8e.W6q];
            U[P + K5j8e.S6q] = K[K5j8e.S6q];
            U[P + K5j8e.T6q] = K[K5j8e.T6q];
        }
        var d = K5j8e.t6q, C = K5j8e.t6q;
        for (var J = K5j8e.t6q, P = U.length; K5j8e[m](J, P); J += K5j8e.V6q) {
            var F = J + K5j8e.T6q;
            if (K5j8e[V](U[F], K5j8e.W6q)) {
                d++;
            } else {
                C++;
            }
            if (K5j8e[L](C, K5j8e.t6q) && K5j8e[W](d, K5j8e.t6q)) {
                break;
            }
        }
        B[K5j8e.G0q] = K5j8e.y6q;
        this[K5j8e.j0q][K5j8e.Y0q][K5j8e.w0q] = K5j8e.y6q;
        this[K5j8e.j0q][K5j8e.t0q][K5j8e.i0q] = K5j8e[S](d, K5j8e.t6q);
        this[K5j8e.j0q][K5j8e.t0q][K5j8e.f1h] = K5j8e[N](C, K5j8e.t6q) && K5j8e[f](d, K5j8e.t6q);
        if (K5j8e[T](this[K5j8e.j0q][K5j8e.t0q][K5j8e.f1h], K5j8e.y6q)) {
            this[K5j8e.j0q][K5j8e.S1h] = K5j8e.I6q;
        }
    },
};
BIMVIZ[K5j8e.S7q][K5j8e.a7q] = function () {
    this[K5j8e.D0q] = new Array();
};
BIMVIZ.D3.KeyDict.prototype = {
    constructor: BIMVIZ[K5j8e.S7q][K5j8e.a7q], add: function (M, K) {
        var T = this[K5j8e.D0q][M];
        if (!T) {
            T = [];
            this[K5j8e.D0q][M] = T;
        }
        T[K5j8e.h7q](K);
    }, get: function (M) {
        var K = this[K5j8e.D0q][M];
        return K;
    }
};
BIMVIZ[K5j8e.S7q][K5j8e.k7q] = function () {
    this[K5j8e.D0q] = new BIMVIZ[K5j8e.S7q][K5j8e.a7q]();
    var T = this;
    this[K5j8e.n0q] = function (M) {
        var K = M[K5j8e.H9q];
        T[K5j8e.D0q][K5j8e.n0q](K, M);
    };
    this[K5j8e.O6q] = function (M) {
        var K = this[K5j8e.D0q][M];
        return K;
    };
};
BIMVIZ[K5j8e.S7q][K5j8e.l0q] = function () {
    var K = "meshlist";
    this[K] = new Array();
    var T = this;
    this[K5j8e.n0q] = function (M) {
        T[K][K5j8e.h7q](M);
    };
};
BIMVIZ[K5j8e.S7q][K5j8e.s0q] = function (B, e, Q) {
    var i = "greyAll", E = "showOtherElements", k = "resetElementsVisibleToBeforeSelect", U = "showElement",
        J = "containsDomain", P = "showUnits", d = "resetElementRGBA", C = "changeElementRGBA",
        F = "showBuildingStorey", j = "containsStorey", G = "containsFile", o = "showType", I = "showFile",
        v = "addRefMesh", A = "addBatMesh", H = "Object3D", K1 = "refDict", O = "batDict", T1 = "center", D = "georoot",
        M1 = "floorUnitDict", t1 = "domainUnitDict", c1 = "elementUnitDict", q1 = "fileUnitDict";
    function S1(M) {
        var K = "G5e";
        for (var T = K5j8e.t6q, f = M.length; K5j8e[K](T, f); T++) {
            var N = M[T];
            N1[q1][K5j8e.n0q](N[K5j8e.v7q], N);
            N1[c1][K5j8e.n0q](N[K5j8e.c6q], N);
            N1[t1][K5j8e.n0q](N[K5j8e.r7q], N);
            N1[M1][K5j8e.n0q](N[K5j8e.b7q], N);
        }
    }
    var N1 = this;
    this[D] = K5j8e.F6q;
    this[T1] = K5j8e.F6q;
    this[O] = new BIMVIZ[K5j8e.S7q][K5j8e.k7q]();
    this[K1] = new BIMVIZ[K5j8e.S7q][K5j8e.l0q]();
    this[q1] = new BIMVIZ[K5j8e.S7q][K5j8e.a7q]();
    this[c1] = new BIMVIZ[K5j8e.S7q][K5j8e.a7q]();
    this[t1] = new BIMVIZ[K5j8e.S7q][K5j8e.a7q]();
    this[M1] = new BIMVIZ[K5j8e.S7q][K5j8e.a7q]();
    (function () {
        var M = "copy", K = "position", T = "Z", f = "Y", N = "X", S = "Vector3", W = "translate", L = "type",
            V = "name";
        N1[D] = new THREE[H]();
        N1[D][V] = D;
        N1[D][L] = W;
        N1[T1] = new THREE[S](-B[T1][N], -B[T1][f], -B[T1][T]);
        N1[D][K][M](N1[T1]);
    })();
    ;
    this[A] = function (M, K, T) {
        var f = "D5e", N = new BIMVIZ[K5j8e.S7q][K5j8e.i6q](M, K, T);
        N1[O][K5j8e.n0q](N);
        var S = new THREE[H]();
        S[K5j8e.n0q](M);
        if (K5j8e[f](K, K5j8e.F6q)) {
            S[K5j8e.n0q](K);
        }
        N1[D][K5j8e.n0q](S);
        S1(N[K5j8e.d6q]);
    };
    this[v] = function (M, K, T) {
        var f = "v5e", N = new BIMVIZ[K5j8e.S7q][K5j8e.o0q](M, K, T);
        N1[K1][K5j8e.n0q](N);
        var S = new THREE[H]();
        S[K5j8e.n0q](M);
        if (K5j8e[f](K, K5j8e.F6q)) {
            S[K5j8e.n0q](K);
        }
        N1[D][K5j8e.n0q](S);
        S1(N[K5j8e.d6q]);
    };
    this[I] = function (M, K) {
        var T = "r5e", f = N1[q1][K5j8e.O6q](M);
        if (f) {
            for (var N = K5j8e.t6q, S = f.length; K5j8e[T](N, S); N++) {
                var W = f[N];
                W[K5j8e.D7q](K);
            }
        }
    };
    this[o] = function (M, K, T) {
        var f = "y5e", N = N1[t1][K5j8e.O6q](K);
        if (N) {
            for (var S = K5j8e.t6q, W = N.length; K5j8e[f](S, W); S++) {
                var L = N[S];
                if (T && (M[G](L[K5j8e.v7q]) || M[j](L[K5j8e.b7q])))continue;
                L[K5j8e.D7q](T);
            }
        }
    };
    this[F] = function (M, K, T) {
        var f = "M9e", N = N1[M1][K5j8e.O6q](K);
        if (N) {
            for (var S = K5j8e.t6q, W = N.length; K5j8e[f](S, W); S++) {
                var L = N[S];
                if (T && (M[G](L[K5j8e.v7q]) || M[j](L[K5j8e.r7q])))continue;
                L[K5j8e.D7q](T);
            }
        }
    };
    this[C] = function (M, K) {
        var T = "T9e", f = N1[c1][K5j8e.O6q](M);
        if (f) {
            for (var N = K5j8e.t6q, S = f.length; K5j8e[T](N, S); N++) {
                var W = f[N], L = W[K5j8e.j0q];
                L[K5j8e.b6q](W, K);
            }
        }
    };
    this[d] = function (M) {
        var K = "resetRGBA", T = "S9e", f = N1[c1][K5j8e.O6q](M);
        if (f) {
            for (var N = K5j8e.t6q, S = f.length; K5j8e[T](N, S); N++) {
                var W = f[N], L = W[K5j8e.j0q];
                L[K](W);
            }
        }
    };
    this[P] = function (M, K, T) {
        var f = "u9e", N = "V9e", S = "t9e";
        if (K5j8e[S](K, undefined)) {
            return;
        }
        for (var W = K5j8e.t6q; K5j8e[N](W, K.length); W++) {
            var L = K[W];
            if (K5j8e[f](L, K5j8e.F6q))continue;
            if (T && (M[J](L[K5j8e.w6q]) || M[j](L[K5j8e.G9q]) || M[G](L[K5j8e.o6q])))continue;
            L[K5j8e.D7q](T);
        }
    };
    this[U] = function (M, K, T) {
        var f = N1[c1][K5j8e.O6q](K);
        if (f) {
            N1[P](M, f, T);
        }
    };
    this[k] = function (M) {
        var K = false, T = "x9e", f = "k9e", N = "E9e", S = "Q9e", W = "R9e";
        if (K5j8e[W](M, K5j8e.F6q))return;
        for (var L in N1[c1][K5j8e.D0q]) {
            var V = N1[c1][K5j8e.O6q](L);
            if (K5j8e[S](V, undefined) || K5j8e[N](V, K5j8e.F6q))continue;
            for (var m = K5j8e.t6q; K5j8e[f](m, V.length); m++) {
                var u = V[m];
                if (K5j8e[T](u, K5j8e.F6q))continue;
                var n = K5j8e.y6q;
                if (M[J](u[K5j8e.w6q]) || M[j](u[K5j8e.G9q]) || M[G](u[K5j8e.o6q])) {
                    n = K;
                }
                u[K5j8e.D7q](n);
            }
        }
    };
    this[E] = function (M, K, T) {
        var f = "g9e", N = "J9e";
        if (K5j8e[N](K, K5j8e.F6q))return;
        for (var S in N1[c1][K5j8e.D0q]) {
            if (K5j8e[f](S, K)) {
                this[P](M, N1[c1][K5j8e.O6q](S), T);
            } else {
                this[P](M, N1[c1][K5j8e.O6q](S), !T);
            }
        }
    };
    this[i] = function () {
        var M = "empty unit mesh", K = "log", T = 0.15, f = 0.4235, N = "b9e", S = "hasOwnProperty",
            W = N1[c1][K5j8e.D0q];
        for (var L in W) {
            if (!W[S](L))continue;
            var V = W[L];
            if (V) {
                for (var m = K5j8e.t6q, u = V.length; K5j8e[N](m, u); m++) {
                    var n = V[m];
                    if (n) {
                        var R = n[K5j8e.j0q];
                        R[K5j8e.b6q](n, [f, f, f, T]);
                    } else {
                        console[K](M, L);
                    }
                }
            }
        }
    };
};
var N2I7u = {
    'O2u': function (P, j) {
        return P == j;
    }, 'n2u': function (P, j) {
        return P * j;
    }, 'd9d': "requestHigh", 'v3d': "", 'p5d': "showFile", 'p9u': function (P, j) {
        return P == j;
    }, 'o5d': "indexOf", 'd9u': function (P, j) {
        return P == j;
    }, 'K1d': 0, 'D6u': function (P, j) {
        return P < j;
    }, 'h5u': function (P, j) {
        return P * j;
    }, 'N87': function (P, j) {
        return P * j;
    }, 'Y6u': function (P, j) {
        return P > j;
    }, 'S2u': function (P, j) {
        return P * j;
    }, 'r47': function (P, j) {
        return P * j;
    }, 'U2u': function (P, j) {
        return P == j;
    }, 'O1d': "requestOneUpdate", 'J47': function (P, j) {
        return P * j;
    }, 'y7d': "Vector3", 'w6u': function (P, j) {
        return P == j;
    }, 'Y5d': "showDomain", 'g5d': "resetElementsVisible", 'y6u': function (P, j) {
        return P / j;
    }, 's5u': function (P, j) {
        return P * j;
    }, 'J2u': function (P, j) {
        return P * j;
    }, 'd5u': function (P, j) {
        return P * j;
    }, 'h9u': function (P, j) {
        return P < j;
    }, 'Z87': function (P, j) {
        return P * j;
    }, 'Q87': function (P, j) {
        return P * j;
    }, 'b2d': "ConvertUtil", 'F47': function (P, j) {
        return P * j;
    }, 'C6u': function (P, j) {
        return P < j;
    }, 'R2u': function (P, j) {
        return P == j;
    }, 'P6u': function (P, j) {
        return P / j;
    }, 'f2d': null, 'a5u': function (P, j) {
        return P * j;
    }, 'b9u': function (P, j) {
        return P == j;
    }, 'z2d': "debug", 'Y87': function (P, j) {
        return P * j;
    }, 'Q6u': function (P, j) {
        return P - j;
    }, 'j9u': function (P, j) {
        return P == j;
    }, 'L87': function (P, j) {
        return P * j;
    }, 'm2d': "showElement", 't5u': function (P, j) {
        return P * j;
    }, 'm9u': function (P, j) {
        return P == j;
    }, 'K5u': function (P, j) {
        return P * j;
    }, 'W87': function (P, j) {
        return P * j;
    }, 'R47': function (P, j) {
        return P * j;
    }, 'B2u': function (P, j) {
        return P * j;
    }, 'H6u': function (P, j) {
        return P === j;
    }, 'x47': function (P, j) {
        return P * j;
    }, 'i5u': function (P, j) {
        return P * j;
    }, 'F7d': "InvsibleSet", 'F2u': function (P, j) {
        return P * j;
    }, 'a9u': function (P, j) {
        return P == j;
    }, 'f47': function (P, j) {
        return P * j;
    }, 'w87': function (P, j) {
        return P * j;
    }, 't9u': function (P, j) {
        return P == j;
    }, 'Z6u': function (P, j) {
        return P < j;
    }, 's7d': "requestNormal", 'W6d': "update", 'V9u': function (P, j) {
        return P == j;
    }, 'q47': function (P, j) {
        return P * j;
    }, 'C87': function (P, j) {
        return P * j;
    }, 'D87': function (P, j) {
        return P * j;
    }, 'W6u': function (P, j) {
        return P * j;
    }, 'n2d': true, 'r2u': function (P, j) {
        return P * j;
    }, 'w5d': "X", 'g5u': function (P, j) {
        return P * j;
    }, 'c6u': function (P, j) {
        return P <= j;
    }, 'M5u': function (P, j) {
        return P * j;
    }, 'X87': function (P, j) {
        return P * j;
    }, 'n47': function (P, j) {
        return P * j;
    }, 'p6d': "RenderRequest", 'o87': function (P, j) {
        return P * j;
    }, 'e7d': "RenderEngine", 'z6d': false, 'A7u': function (P, j) {
        return P == j;
    }, 'v5u': function (P, j) {
        return P * j;
    }, 'I9u': function (P, j) {
        return P == j;
    }, 'E2u': function (P, j) {
        return P == j;
    }, 'I7t': (function (E9t) {
        return (function (W9t, b9t) {
            return (function (K9t) {
                return {A7t: K9t, Q9t: K9t,};
            })(function (g7t) {
                var x9t, t9t = 0;
                for (var O9t = W9t; t9t < g7t["length"]; t9t++) {
                    var y9t = b9t(g7t, t9t);
                    x9t = t9t === 0 ? y9t : x9t ^ y9t;
                }
                return x9t ? O9t : !O9t;
            });
        })((function (P9t, H9t, R9t, j9t) {
            var s9t = 34;
            return P9t(E9t, s9t) - j9t(H9t, R9t) > s9t;
        })(parseInt, Date, (function (H9t) {
            return ('' + H9t)["substring"](1, (H9t + '')["length"] - 1);
        })('_getTime2'), function (H9t, R9t) {
            return new H9t()[R9t]();
        }), function (g7t, t9t) {
            var u7t = parseInt(g7t["charAt"](t9t), 16)["toString"](2);
            return u7t["charAt"](u7t["length"] - 1);
        });
    })('41jxohw4g'), 'c6d': "showStorey", 'z87': function (P, j) {
        return P * j;
    }, 'c87': function (P, j) {
        return P * j;
    }, 'K5d': "showOtherElements", 'M9u': function (P, j) {
        return P == j;
    }, 'g9d': "updateFrames", 'A2u': function (P, j) {
        return P * j;
    }, 'v9u': function (P, j) {
        return P == j;
    }, 'q2u': function (P, j) {
        return P * j;
    }, 'G5u': function (P, j) {
        return P * j;
    }, 'p5u': function (P, j) {
        return P * j;
    }, 'z9d': "removeHigh", 's9u': function (P, j) {
        return P == j;
    }, 'i9u': function (P, j) {
        return P == j;
    }, 'u87': function (P, j) {
        return P * j;
    }, 'T2u': function (P, j) {
        return P * j;
    }, 'P87': function (P, j) {
        return P * j;
    }, 'y8K': "renderDomId", 'k2u': function (P, j) {
        return P * j;
    }, 'z6u': function (P, j) {
        return P > j;
    }, 'I5u': function (P, j) {
        return P * j;
    }, 'w6d': "Y", 'm5u': function (P, j) {
        return P * j;
    }, 'U47': function (P, j) {
        return P * j;
    }, 'O47': function (P, j) {
        return P * j;
    }, 'x2u': function (P, j) {
        return P == j;
    }, 'E47': function (P, j) {
        return P * j;
    }, 'g9u': function (P, j) {
        return P == j;
    }, 'm5d': "require", 'l9u': function (P, j) {
        return P == j;
    }, 'y5d': "removeNormal", 'W1d': 1, 'b5u': function (P, j) {
        return P * j;
    }, 'y87': function (P, j) {
        return P * j;
    }, 'N6u': function (P, j) {
        return P < j;
    }, 'q7d': "getElementById", 'f2u': function (P, j) {
        return P != j;
    }, 'u6u': function (P, j) {
        return P == j;
    }, 'j5u': function (P, j) {
        return P * j;
    }, 'L6u': function (P, j) {
        return P > j;
    }, 'X6u': function (P, j) {
        return P >= j;
    }, 'o6u': function (P, j) {
        return P < j;
    }, 'e2u': function (P, j) {
        return P * j;
    }, 'd6d': "Z", 'l5u': function (P, j) {
        return P * j;
    }, 'G9u': function (P, j) {
        return P == j;
    }, 'H87': function (P, j) {
        return P * j;
    }, 'K9u': function (P, j) {
        return P == j;
    }, 'V5u': function (P, j) {
        return P * j;
    }
};
N2I7u.y6t = function (f) {
    for (; N2I7u;)return N2I7u.I7t.Q9t(f);
};
N2I7u.x6t = function (k) {
    if (N2I7u && k)return N2I7u.I7t.A7t(k);
};
N2I7u.s6t = function (g) {
    for (; N2I7u;)return N2I7u.I7t.A7t(g);
};
N2I7u.H6t = function (d) {
    for (; N2I7u;)return N2I7u.I7t.Q9t(d);
};
N2I7u.t6t = function (f) {
    for (; N2I7u;)return N2I7u.I7t.A7t(f);
};
N2I7u.u9t = function (c) {
    if (N2I7u && c)return N2I7u.I7t.A7t(c);
};
N2I7u.I9t = function (m) {
    while (m)return N2I7u.I7t.Q9t(m);
};
N2I7u.T9t = function (j) {
    if (N2I7u && j)return N2I7u.I7t.A7t(j);
};
N2I7u.a9t = function (a) {
    while (a)return N2I7u.I7t.Q9t(a);
};
N2I7u.v9t = function (h) {
    while (h)return N2I7u.I7t.Q9t(h);
};
N2I7u.h9t = function (h) {
    if (N2I7u && h)return N2I7u.I7t.Q9t(h);
};
N2I7u.X9t = function (l) {
    for (; N2I7u;)return N2I7u.I7t.A7t(l);
};
N2I7u.k9t = function (l) {
    if (N2I7u && l)return N2I7u.I7t.Q9t(l);
};
N2I7u.l9t = function (g) {
    if (N2I7u && g)return N2I7u.I7t.Q9t(g);
};
N2I7u.N9t = function (d) {
    if (N2I7u && d)return N2I7u.I7t.A7t(d);
};
N2I7u.S9t = function (g) {
    for (; N2I7u;)return N2I7u.I7t.A7t(g);
};
N2I7u.q9t = function (a) {
    if (N2I7u && a)return N2I7u.I7t.Q9t(a);
};
N2I7u.m9t = function (d) {
    while (d)return N2I7u.I7t.A7t(d);
};
N2I7u.c9t = function (d) {
    while (d)return N2I7u.I7t.A7t(d);
};
N2I7u.J9t = function (f) {
    if (N2I7u && f)return N2I7u.I7t.A7t(f);
};
N2I7u.i9t = function (l) {
    if (N2I7u && l)return N2I7u.I7t.A7t(l);
};
N2I7u.F9t = function (c) {
    for (; N2I7u;)return N2I7u.I7t.A7t(c);
};
N2I7u.Y9t = function (d) {
    for (; N2I7u;)return N2I7u.I7t.Q9t(d);
};
N2I7u.r9t = function (g) {
    for (; N2I7u;)return N2I7u.I7t.A7t(g);
};
N2I7u.f9t = function (l) {
    for (; N2I7u;)return N2I7u.I7t.A7t(l);
};
N2I7u.G9t = function (h) {
    for (; N2I7u;)return N2I7u.I7t.A7t(h);
};
BIMVIZ[N2I7u.F7d] = N2I7u.G9t("1c7") ? 'thistle' : function () {
    N2I7u.j6t = function (h) {
        for (; N2I7u;)return N2I7u.I7t.A7t(h);
    };
    N2I7u.w9t = function (f) {
        for (; N2I7u;)return N2I7u.I7t.Q9t(f);
    };
    N2I7u.o9t = function (l) {
        while (l)return N2I7u.I7t.A7t(l);
    };
    N2I7u.D9t = function (n) {
        if (N2I7u && n)return N2I7u.I7t.A7t(n);
    };
    N2I7u.d9t = function (k) {
        while (k)return N2I7u.I7t.A7t(k);
    };
    N2I7u.n9t = function (e) {
        for (; N2I7u;)return N2I7u.I7t.Q9t(e);
    };
    N2I7u.V9t = function (n) {
        for (; N2I7u;)return N2I7u.I7t.A7t(n);
    };
    N2I7u.L9t = function (i) {
        if (N2I7u && i)return N2I7u.I7t.Q9t(i);
    };
    N2I7u.M9t = function (f) {
        for (; N2I7u;)return N2I7u.I7t.A7t(f);
    };
    N2I7u.z9t = function (g) {
        for (; N2I7u;)return N2I7u.I7t.Q9t(g);
    };
    var M = N2I7u.f9t("1c") ? "getText" : "clearGroups",
        V = N2I7u.z9t("353") ? "isVisiableElement" : "morphTargetInfluences",
        d = N2I7u.M9t("cce") ? "failedCuts" : "containsElement", n = N2I7u.r9t("dca") ? "containsStorey" : "mergelist",
        F = N2I7u.L9t("f3") ? "KEY" : "containsDomain", D = N2I7u.V9t("c4e7") ? "contains" : "shadowCameraTop",
        i = N2I7u.n9t("da") ? "containsFile" : "bindMode", m = N2I7u.y6t("827") ? "removeId" : "readFloat32Array",
        S = N2I7u.Y9t("3331") ? "setPlaybackRate" : "addId", k = N2I7u.j6t("d47") ? "WebGLGeometries" : "clear",
        o = N2I7u.d9t("fe5") ? "lightShadowsLength" : "showElements",
        I = N2I7u.F9t("8b5") ? "depthTest" : "hidedElements", e = N2I7u.i9t("bd") ? "_SkinningFlag" : "storeys",
        C = N2I7u.x6t("cdea") ? "domains" : "ALWAYS", B = N2I7u.D9t("e3") ? "files" : "noneEdgeUnits";
    this[B] = N2I7u.J9t("1dd") ? [] : "enableRotate";
    this[C] = N2I7u.c9t("d178") ? [] : "frontFace";
    this[e] = [];
    this[I] = N2I7u.m9t("611") ? "updateBuffers" : [];
    this[o] = N2I7u.q9t("7f63") ? [] : "shapesOffset";
    this[k] = function () {
        N2I7u.O6t = function (d) {
            while (d)return N2I7u.I7t.Q9t(d);
        };
        N2I7u.b6t = function (c) {
            for (; N2I7u;)return N2I7u.I7t.Q9t(c);
        };
        N2I7u.Z9t = function (b) {
            while (b)return N2I7u.I7t.A7t(b);
        };
        this[B] = [];
        this[C] = [];
        this[e] = N2I7u.b6t("eb") ? [] : "skinWeight";
        this[I] = N2I7u.Z9t("d51") ? [] : "newAction";
        this[o] = N2I7u.O6t("e683") ? [] : "Object";
    };
    this[N2I7u.g5d] = function () {
        this[I] = [];
        this[o] = [];
    };
    this[N2I7u.p5d] = function (P, j) {
        N2I7u.p9t = function (n) {
            if (N2I7u && n)return N2I7u.I7t.A7t(n);
        };
        var O = "s9u", K = N2I7u.p9t("d6") ? "t9u" : 'fogNear', U = "A7u";
        if (N2I7u[U](P, undefined) || N2I7u[K](P, N2I7u.f2d))return;
        if (N2I7u[O](j, N2I7u.z6d)) {
            this[S](this[B], P);
        } else {
            this[m](this[B], P);
        }
    };
    this[i] = N2I7u.S9t("fd") ? "spotLights" : function (P) {
        return this[D](this[B], P);
    };
    this[N2I7u.Y5d] = function (P, j) {
        var O = "K9u", K = N2I7u.N9t("5d") ? "3. Please check if the ProjectId is valid." : "b9u", U = "j9u";
        if (N2I7u[U](P, undefined) || N2I7u[K](P, N2I7u.f2d))return;
        if (N2I7u[O](j, N2I7u.z6d)) {
            this[S](this[C], P);
        } else {
            this[m](this[C], P);
        }
    };
    this[F] = function (P) {
        return this[D](this[C], P);
    };
    this[N2I7u.c6d] = function (P, j) {
        var O = "V9u", K = "M9u", U = N2I7u.l9t("32b") ? '#ifdef USE_COLOR' : "G9u";
        if (N2I7u[U](P, undefined) || N2I7u[K](P, N2I7u.f2d))return;
        if (N2I7u[O](j, N2I7u.z6d)) {
            this[S](this[e], P);
        } else {
            this[m](this[e], P);
        }
    };
    this[n] = function (P) {
        return this[D](this[e], P);
    };
    this[N2I7u.m2d] = function (P, j) {
        var O = "m9u", K = "i9u", U = N2I7u.k9t("77") ? '). Resized to ' : "d9u";
        if (N2I7u[U](P, undefined) || N2I7u[K](P, N2I7u.f2d))return;
        if (N2I7u[O](j, N2I7u.z6d)) {
            this[S](this[I], P);
        } else {
            this[m](this[I], P);
        }
    };
    this[d] = N2I7u.X9t("2a") ? "// wavelength of used primaries, according to preetham" : function (P) {
        return this[D](this[I], P);
    };
    this[N2I7u.K5d] = function (P) {
        N2I7u.e9t = function (m) {
            if (N2I7u && m)return N2I7u.I7t.Q9t(m);
        };
        N2I7u.B9t = function (b) {
            if (N2I7u && b)return N2I7u.I7t.A7t(b);
        };
        var j = N2I7u.e9t("3c") ? "a9u" : 'highp', O = N2I7u.h9t("3fdd") ? 'Scene' : "v9u",
            K = N2I7u.w9t("2ed2") ? "h9u" : "#define PHYSICALLY_CORRECT_LIGHTS", U = N2I7u.B9t("c1d") ? 50 : "l9u",
            G = N2I7u.o9t("1d7") ? "p9u" : "float C = 0.10;";
        if (N2I7u[G](P, undefined) || N2I7u[U](P, N2I7u.f2d))return;
        this[o] = N2I7u.a9t("ab57") ? [] : "vector2";
        for (var f = N2I7u.K1d; N2I7u[K](f, P.length); f++) {
            if (N2I7u[O](P[f], undefined) || N2I7u[j](P[f], N2I7u.f2d))continue;
            this[S](this[o], P[f]);
        }
        this[I] = N2I7u.v9t("a62") ? "TEXTURE_CUBE_MAP" : [];
    };
    this[V] = N2I7u.T9t("a7") ? function (P) {
        return this[D](this[o], P);
    } : 'THREE.LOD: .objects has been renamed to .levels.';
    this[D] = function (P, j) {
        N2I7u.A9t = function (e) {
            for (; N2I7u;)return N2I7u.I7t.A7t(e);
        };
        N2I7u.C9t = function (g) {
            if (N2I7u && g)return N2I7u.I7t.Q9t(g);
        };
        var O = N2I7u.C9t("75f") ? "H6u" : 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.',
            K = "g9u", U = N2I7u.I9t("5d") ? 'aquamarine' : "I9u";
        if (N2I7u[U](P, N2I7u.f2d) || N2I7u[K](j, N2I7u.f2d))return N2I7u.z6d;
        if (!Array[N2I7u.o5d]) {
            var G = N2I7u.A9t("c3fc") ? 0.837255 : P.length + N2I7u.W1d;
            while (G -= N2I7u.W1d) {
                if (N2I7u[O](P[G - N2I7u.W1d], j)) {
                    return N2I7u.n2d;
                }
            }
            return N2I7u.z6d;
        } else {
            return (P[N2I7u.o5d](j) !== -N2I7u.W1d);
        }
    };
    this[S] = function (P, j) {
        var O = "push", K = P[N2I7u.o5d](j);
        if (K == -N2I7u.W1d) {
            P[O](j);
        }
    };
    this[m] = N2I7u.u9t("cbf1") ? function (P, j) {
        N2I7u.g9t = function (l) {
            for (; N2I7u;)return N2I7u.I7t.A7t(l);
        };
        var O = N2I7u.g9t("bc1") ? "holesMovements" : "splice", K = N2I7u.t6t("edd") ? 2301 : P[N2I7u.o5d](j);
        if (K > -N2I7u.W1d) {
            P[O](K, N2I7u.W1d);
        }
    } : 0x98FB98;
    this[M] = function () {
        N2I7u.E6t = function (l) {
            while (l)return N2I7u.I7t.Q9t(l);
        };
        N2I7u.R6t = function (g) {
            if (N2I7u && g)return N2I7u.I7t.A7t(g);
        };
        var j = N2I7u.H6t("8b6f") ? "roughnessMap" : "forEach", O = N2I7u.s6t("d1f3") ? 0xC0C0C0 : "|",
            K = N2I7u.R6t("a1e8") ? N2I7u.v3d : "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n";
        K += N2I7u.E6t("b3") ? 'meshphysical_frag' : this[B].length + O;
        K += this[C].length + O;
        K += this[e].length + O;
        K += this[I].length + O;
        K += this[o].length + O;
        this[B][j](function (P) {
            K += P + O;
        });
        this[C][j](function (P) {
            N2I7u.P6t = function (d) {
                if (N2I7u && d)return N2I7u.I7t.Q9t(d);
            };
            K += N2I7u.P6t("ab") ? P + O : 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.';
        });
        this[e][j](function (P) {
            K += P + O;
        });
        this[I][j](function (P) {
            K += P + O;
        });
        this[o][j](function (P) {
            K += P + O;
        });
        return K;
    };
};
BIMVIZ[N2I7u.p6d] = function (n) {
    var F = "init", D = "W6u", i = 60, m = "y6u", S = 30, k = 1000, o = "P6u", I = "now", e,
        C = (performance || Date)[I](), B = N2I7u.K1d, R8 = N2I7u.K1d, u = N2I7u.K1d, H8 = N2I7u[o](k, S),
        O8 = N2I7u[m](k, i), E8 = N2I7u[D](k, k);
    this[F] = function () {
        var P = "hide", j = "dom", O = "appendChild", K = document[N2I7u.q7d](n[N2I7u.y8K]);
        e = new Stats();
        K[O](e[j]);
        if (!n[N2I7u.z2d]) {
            e[P]();
        }
    };
    this[N2I7u.m5d] = function () {
        var P = "c6u", j = "D6u", O = "Y6u", K = "L6u", U = "z6u", G = "Q6u", f = (performance || Date)[I](),
            M = N2I7u[G](f, C), V = N2I7u.z6d, d = E8;
        if (N2I7u[U](R8, N2I7u.K1d)) {
            d = O8;
        } else if (N2I7u[K](B, N2I7u.K1d)) {
            d = H8;
        } else if (N2I7u[O](u, N2I7u.K1d)) {
            u--;
            d = H8;
            if (N2I7u[j](u, N2I7u.K1d)) {
                u = N2I7u.K1d;
            }
        } else {
            d = E8;
        }
        if (N2I7u[P](M, d)) {
            V = N2I7u.z6d;
        } else {
            V = N2I7u.n2d;
            C = f;
        }
        return V;
    };
    this[N2I7u.g9d] = function () {
        e[N2I7u.W6d]();
    };
    this[N2I7u.s7d] = function (P) {
        B++;
    };
    this[N2I7u.y5d] = function (P) {
        var j = "Z6u";
        B--;
        if (N2I7u[j](B, N2I7u.K1d)) B = N2I7u.K1d;
    };
    this[N2I7u.d9d] = function (P) {
        R8++;
    };
    this[N2I7u.z9d] = function (P) {
        var j = "N6u";
        R8--;
        if (N2I7u[j](R8, N2I7u.K1d)) {
            R8 = N2I7u.K1d;
        }
    };
    this[N2I7u.O1d] = function (P) {
        u++;
    };
    this[F]();
};
BIMVIZ[N2I7u.e7d] = function (n) {
    var F = "logo", D = "f2u", i = "table", m = "colorMode", S = "transparentMode", k = "colorTable", o = 'resize',
        I = "addEventListener", e = "fullpage", C = "resizeMode", B = "U2u", R8 = "ThreeJsRender", u = "username",
        H8 = "DataLoader", O8 = "setElementVisible", E8 = "greyAll", W8 = "add3dModelObj", f8 = "businessKeyToGlobalId",
        Q8 = "globalIdToBussinessKey", z8 = "getPickWithCameraMove", x8 = "setPickWithCameraMove", r8 = "exitSelection",
        P8 = "removeHighSpeed", U8 = "requestHighSpeed", J8 = "removeNormalSpeed", F8 = "requestNormalSpeed",
        D8 = "cancelAcquireSpacePoint", n8 = "acquireSpacePoint", q8 = "searchElementsBySql",
        L8 = "searchElementsByText ", N8 = 'Project/QueryElementsByText', X8 = "searchElementsByText",
        o8 = "setKeyControlMovementSpeed", T8 = "getKeyControlMovementSpeed", e8 = "resetCameraLook",
        S8 = "watchBuildingStorey", c8 = "setLookFrom", k8 = "toScreenPosition",
        t4 = "resetElementsVisibleToBeforeSelect", j4 = "setUnSelectedElementsVisible", Y8 = "clearSelection",
        B8 = "selectedElementId", A8 = "setSelectedElementsVisible", C8 = "showBuildingStorey", u8 = "showMarker",
        w8 = "showAllMarker", R4 = "saveMarker", x4 = 'GET', U4 = "removeMarker", K4 = "animateMarker", n4 = "projId",
        O4 = "toJsonObject", J4 = "createMarker", f4 = "selectElementFromClientUI", s4 = "resetElementRGBA",
        b4 = "changeElementRGBA", B4 = "showType", l4 = "resize", w4 = "start", T4 = "addListener",
        m4 = "getInvisibleSet", i4 = 0.4, M4 = "theme", G4 = "auto", v4 = "ColorTable", x0 = "resourcePath",
        G0 = "ResourcePath", F4 = "ContainerId", C4 = 'bearer ', d4 = "RequestHeaders", q4 = 'json', k4 = 'key',
        r4 = 'password', V4 = 'POST', V0 = '/token', t0 = "ajax", K0 = ",", d0 = "projectId", M0 = "/api/",
        F0 = "APIURL", n0 = "TOKEN", R0 = "ws://", i0 = "SOCKETURL", b0 = "port", e4 = ":", r0 = "ip", z3 = "http://",
        A4 = "HOST", m0 = "key", K3 = "KEY", S3 = "REVISION", O3 = 'BIMVIZ.RenderEngine', Y3 = "log",
        j3 = "renderRequest", u4 = "EVENT", l3 = "fire", u0 = "EventManager", v0 = "CenterPosition", k0 = "projectData",
        J3 = "replace", J1 = "?", S1 = "split", i1 = "bimviz.js", p1 = "/", E1 = "nodeValue", X3 = "src",
        f0 = "attributes", p0 = "script", w3 = "getElementsByTagName";
    function x3() {
        var P = "worker.js", j = "u6u", O = "C6u", K = document[w3](p0);
        for (var U = N2I7u.K1d; N2I7u[O](U, K.length); U++) {
            var G = K[U];
            if (N2I7u[j](G[f0][X3], undefined)) {
                continue;
            }
            var f = G[f0][X3][E1];
            if (f && f[N2I7u.o5d](p1 + i1) > -N2I7u.W1d) {
                var M = f[S1](J1)[N2I7u.K1d];
                M = M[J3](i1, P);
                return M;
            }
        }
        return N2I7u.v3d;
    }
    function t3() {
        var P = "webworker.js", j = "w6u", O = "o6u", K = document[w3](p0);
        for (var U = N2I7u.K1d; N2I7u[O](U, K.length); U++) {
            var G = K[U];
            if (N2I7u[j](G[f0][X3], undefined)) {
                continue;
            }
            var f = G[f0][X3][E1];
            if (f && f[N2I7u.o5d](p1 + i1) > -N2I7u.W1d) {
                var M = f[S1](J1)[N2I7u.K1d];
                M = M[J3](i1, P);
                return M;
            }
        }
        return N2I7u.v3d;
    }
    function z1(P) {
        var j = "MarkJsonObjToEntity", O = "Convert", K = "Entity", U = "markers";
        P[U] = BIMVIZ[K][O][j](P[U]);
    }
    function v3() {
        var P = "connect";
        if (n[N2I7u.z2d]) {
        }
        r1[P]();
    }
    function T0(P) {
        var j = "ProjectOverviewLoaded", O = "bimScene", K = "attachBimScene", U = "Manager", G = "D3", f = "center",
            M = "args", V = P[M];
        S4[k0] = V;
        z1(S4[k0]);
        S4[v0] = new THREE[N2I7u.y7d](V[f][N2I7u.w5d], V[f][N2I7u.w6d], V[f][N2I7u.d6d]);
        s0 = new BimScene(S4[k0], j0, S4);
        I0 = new BIMVIZ[G][U](S4[k0], j0, S4);
        j0[K](s0, I0);
        S4[k0][O] = s0;
        S4[u0][l3](BIMVIZ[u4][j], S4[k0]);
    }
    function r3() {
        var P = "append", j = '#', O = '</div>', K = '" style=" width:100px;height:auto;" />', U = '<img src="',
            G = '<div style="bottom:10px;right:10px;color:deepskyblue;position:absolute;">',
            f = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACJCAYAAACW2wWcAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAA8k2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU0OTExLCAyMDEzLzEwLzI5LTExOjQ3OjE2ICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE2LTA2LTI0VDE0OjE5OjA0KzA4OjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNi0xMi0yNlQxNzowMzozOSswODowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTYtMTItMjZUMTc6MDM6MzkrMDg6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjBlY2FhN2NiLTMwZmUtMTE0OS05MWI0LTY2ZjE1MjhiOThjYTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDphNzA5NzkzMi0xMjFhLTJlNDktODY2Yy05Y2QwMWVkMWViMTM8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDphNzA5NzkzMi0xMjFhLTJlNDktODY2Yy05Y2QwMWVkMWViMTM8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6YTcwOTc5MzItMTIxYS0yZTQ5LTg2NmMtOWNkMDFlZDFlYjEzPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTA2LTI0VDE0OjE5OjA0KzA4OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDplMjNhNGE5OC1hYmZjLTBjNDQtOWY1OS02M2I1NjdjM2RlZjY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTYtMDYtMjRUMTQ6MTk6MDQrMDg6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjBlY2FhN2NiLTMwZmUtMTE0OS05MWI0LTY2ZjE1MjhiOThjYTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0xMi0yNlQxNzowMzozOSswODowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8cGhvdG9zaG9wOklDQ1Byb2ZpbGU+c1JHQiBJRUM2MTk2Ni0yLjE8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8cGhvdG9zaG9wOkRvY3VtZW50QW5jZXN0b3JzPgogICAgICAgICAgICA8cmRmOkJhZz4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOmE3MDk3OTMyLTEyMWEtMmU0OS04NjZjLTljZDAxZWQxZWIxMzwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpCYWc+CiAgICAgICAgIDwvcGhvdG9zaG9wOkRvY3VtZW50QW5jZXN0b3JzPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj45NjAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjk2MDAwMC8xMDAwMDwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT4xPC9leGlmOkNvbG9yU3BhY2U+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj4zMDA8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MTM3PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz43dYTPAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAHm8SURBVHja7H11nFz1uf5zfNx3Zmfd45uNB5KQICEBAgQpUKRQoFClhRaooMWtQmmRosVdE+JK3G2Tjay7jsvR3x8jWZmZXdq0t/f+znM/8+kNO3LO93zPc1553vclFEWBChUqVPxvAKkugQoVKlTCUqFChQqVsFSoUKESlgoVKlSohKVChQoVKmGpUKFCJSwVKlSoUAlLhQoVKlTCUqFChUpYKlSoUKESlgoVKlSohKVChQqVsFSoUKFCJSwVKlSoUAlLhQoVKmGpUKFChUpYKlSoUKESlgoVKlTCUqFChQqVsFSoUKFCJSwVKlSohKVChQoVKmGpUKFChUpYKlSo+F8LevB/eOedd0AzDPQGI7LsNhgNBtAcB71Ohxy3G99s2YpLL1wErV4PvU4HmmGg0Wig02qh0Wqh0+thM5thMpthstiQ7cyC2WKBVq+Hw2aD2WwEx2mh1WmRk5uHQ4ePYPH5CxGORGC2WMDQNFiOg1ajgVang1arg8lkhNlshsVqRZbDAZvNBq1Oj+LiIhQVFuKuu+66qqam5r3y8gqYzSY4srLgdrvhdLrgsNthNpuh0+ug0WhAUxRkkPhPjY8lSBKSKCDs98X/A/GtPs+yLEiSwn333Ye6ulqUV4xCZdUkbNv8Dd58801kZWWBGOY7g4EAxk2oxOLFF2P33r2YO+9M1B2tQSAYxM4dO+DOywdNkZg4cSL27duHn/785zhj7jx0dXWl/D6NRoPenh5sWLMaiqKApmnwogQoCkgoiPACZFkGS1Pw+v3Izc3D2WedCZ7nIcsyCIIAz/PJ/z127Bg+/fRTEASBO+64Ay++8AI+++ILPPvss5gzezb8fj9kWU55LPn5+fjiiy9w9dVXw2w2g6bp//hN1NnZiV//+te49dZb0dDQkPG9DocDa9aswccffwy73Z755qRp8DyP7du3IxwOg2GYlO9TFAUEQSArKws0Taddq/4QBAGRSASvv/46xo4di88//xyyLEOUZRCKAigKBCl2rRiKhCDJUBQFDE1Bif+NJklQJAFelJLvE2UZoiTDbrWgu7sbK1etwvxzzsHq1asxeswY/PQnP0FRUdH/fxaWoiiw2+2orq4es3fPnhtomi5iGAbqJGsVKlSX8L8KoiiitLQU9XX1JVddddWGPXv3LmhtbV0rSaJNq9WqpKVChUpY/x2QJAmFRUWob2gov/aa7+5sa2tzjB83DhaTqejwoUNbw5GoWafTj8gsVqFChUpY/1ayys/PR1tr6+if/OiHO1vb2q3jx41DSXExKioqwDBM+ZbNm7YJAq8zm8wqaalQoRLW/wxkWYLb7UZra9uEX991146Ojg7T+HHjUFxUBI1GA57nkZOTA4okR331xRdbwpEIa7PZIEmSepVVqFAJ6z9JVjIcjix0d3dXPfnE49tb2toMCbLSarWQJCmW4RBFFBUWIhwOV7768t83RaMRyulyqqSlQoVKWP85srJarfB6PNNefunv2zo6OjTjx48fQFaJILuiKBBFERXl5fD29U195OGHv4lEonC73RBFUb3aKlSohPXvg6IoMJlM8Hl9p3388cebe3q62bFjx6Ukq/6fkSQJY8eNQ0db28w777h9QzAURG5unkpaKlSohPXvIyu9Xo9QODR75aqVm3p7e+lRo0ahpLgIWo0mJVn1t8oEQUBVVRXq6mrn/ODmm9fxfBR5uXmqe6hChUpYp56stFotwuHwGdu3bt3o9/mIsrIylBQXQzMMWfX/DlEUMWXqNJw4dmzud6+8clUgGEB2djYoioIkqRlEFSpUwjoFZMVxGkSj0TMPHjiw3u/3o7S0FKUlJUPIiiRJCDyP7q4uKIoMiqKGWFqSKGLGjBmoPnTo7Ouvu275nj17oNPrkZ2dBZPJBIPBCJ0uVrbDsixomgZJUiAI8luX0ahQoeL/I8JSFAUMy0IQhbOPnzixJhgMoqS4GCXFxeA4biBZURT8Ph8UgsCZ58xfFo3yCIdCKUlLFEWcfvrpOHrkyLnnn3feZ1u3bIHH40VzcxPa21rR3dUFj8eDQCCASCQCUeQhyyIwWMel8pcKFf+joP+rDoamIYni/Pb29hXhcBhFhYUoTkNW3r4+hMJhPPjrXy868+yzlzz+yKM3vPvu26/lunNgsVohCMIQ0ho7bhza29sv/tXtP//EmZ19qdlkgsVshtPpgsvtRnZ2NpzOLJhNplhxt1YHlmMRkWSwNA2Kor512Q9JkoAiJ4utVc5ToeL/gIVFUiQURZnf1dW1IhqJoLCgACUlJSnJyuf1IhgM4ve///1Cm8Wy5I7bby/SarWvL77k0h83NTfD6/UMqWyX5Vi1udvtBsswlzTW178XDAYRjUYRDoXA8zwEQYAkiVDi71WhQoVKWENAkCQUWVnQ19e3gud5FOTno6S4GCzLDolZ+b1e9PX14bkXX5xZWFK6/Jqrr1761788W/fmm28uLigoeP7mW2+9pbauHn29vWBZdghpybKMgoIC2G22K3t7e9/W6vXQGwygafpk/Iokh23ZokKFiv+PCEsQBFAEUFZeDgALfF7vMoHnkZ+GrAiCQDgUgj/gx8uvvTa5oKBg98IF5zYcPnr0PJvdgZ6enk/fevMfF+bk5f/9x7f9/KYTJ06gp6cnJWkpioLs7GzIonj10SNH/sGwLDiOVa0qFSpUwhoKRVHgzs7GN5s248bvXXd+KBRaRjMM8vPyUFJUBCaFZRUKhdDT24tf3XlXidVi2T+pstJ//PjxgsoJEzB18mSMHzcWfb19Xzz/3F8umD5l8qv3P/jg9UdqatDd3Z2StAAgPy8Pnr6+6zZv3vx3rTaWKVQLplWoUAlrAFmRFAWtVosPP3j/gvffe3eJKIooKS1FUQqyIggC4XAYoiji4sWLp5hMpvaFCxZ4W1tbuamTJ6OwoABGgwEmkwkFBQVoaWr66q0331x45VVX/ePJp5669uDBg+jq6kpNWgSBoqIiNNTX3bx0yVd/1RsM0Ol0KmmpUKESVpysSArlZaV47733Lnn55Ze/MplMyM/PR1FBAViWhTjIsgoGg/D5fMr9Dz9y4aVXXrX78ssvf/7o0aP6iRMnIicnB1qtFqIkged5GAwGOLOyEAiF7v3bCy9g8uTJb//h2b9cV11djd40MS2KojC6ogJ7du368ZtvvPEnu90Ovd6gkpYKFf+F+I/JGmJkRWLcuHF4+513Lrv2mms+IgkCUyZPRl5eHhiGiZXN9A+w+/0gCUKaOXPmaYWFRTs+/fgjhMJhyeFwwGq1xshKFJMEJwgCjEYj8nNz9y9burTsxLHj3F/+8uxbEh/lH3744fc5jkuKTxOQJAkUTWPc2LHYsG7tz/9s0Efuf/D3v45EI5BVNbwKFf//EVaCrMaMHYM3//GP71x/ww0fUCSJyZMnIz8vDzRFDShMpigKHo8H0WhUvu3nP58gK8rh22/7yRPHjh4/mJWVVU1RFNh4//bBgXKKosDzfKvf6y34/PPP37/9jjsKrr3uug+eeuqp8NdLl36xaNEiaLRa8Dw/gLQYhkHlxIn49JNP7mZYVn7yqad/6/f7BrzvfxqJc7VabTAajSP+nCzLYBgWDocDnCZG2vg/kmAgSRKiKEKSJPh8vlM4hEKBLMvQ6w3gOG5Yi1ur1UKv10Or0WQU25lNJgiCgObm5gFawXTnxjDMsOeUyGh3d3VBgYKRqP0EgUcoGJPzUDStEtZgsqqoqMB777333Z/8+MfvUBSFKZMmITcvLyYW7WfxkCSJnp4eMAwjvfbGG3NyCooOX3n5pS988fnnt2ZnZ/9Ip9N5iEE3cH8Eg0HkFxRyFy7OOvqbX9/t+N5112598aW/T3zk0ce+PHS4+pKP3n//U1dWFvR6PcR+vytKEjiWxZQpU/D+u+/8hmYY6cknnrg3GAqhy+v7ryArnU4Hk8mEAwf2nVFz5MgsmqZdkiQJBEFkZB+Soui+3p7oxo0bq7u7u5uDgcBuq83mJWk6Jen/b4IoiuA4DhabDQ67Y0ilw79EhhSJvt7eewSedxAEwWdYJ7ajo3NJZ1fXyl6PJ+N3hsJRuFwuXHPNNdDr9Rnfq9Fo0NHRkbVv377fKIoiS2kKYGVZJiRJMpx1zvw/ZWU5asLhyIjWLRgMwGw2IxwKqYTVn6xKSkvwxeefXffru+/+B0PTmDRpEvJyc+NFyCdjVhRFobenBzRNhW++5ZZSo9nStvjCC9YsX7bszLzcXJSUlDT29vbmCYKQ9iajSBKRcJjweD2U3WbDsWPHKhdfeOHqhQsXnH3LT3722ZpVqy44UVu7ZNSoUeA4boBlJ4oiNBoNpk6dhtdfeeUeLcfxD/7+9w9xOh08Hi9kRfkfU6prtVpEIpHpy75e+uzx48dnKIqCrKysEZENx3Ho7OzAB++/B73eiEP793vz8vLWZGVlva/Vad/X6/UQBf5/JXG1tbaiqqoKn33+BURJOqVJE7fLhfvuu3fx22++OcXlcoEkyZRrpNVqsW/f3rN3bN8+oa/PA2QYIhcKhVBcXIwLL7wQ0Wg04+/n5OTgww8/XOzxeG63Wq1px3wFAgHYbDb84OabHs12u+H3+YdaYSQBRVYQiUYABRBEAWNGj4HDbkNDfb1KWAmyKigsxIrly2649977XmMZBpOqqpCXlweKJGNklSAamkZXZycYhgndc889OfsPHPROnjjxcHNL8+iSkhKUlZQgKyuL9wf8Mp/BlNbqdGhublSOnzgBnV6PosJCEIpy1pdffbn0WG3t+RzHLQVBLGxvb1/mcjqhicfBBpPWzJkz8feXXvx9IBSSfvaLXzyq0+lPxtmSTgOGda0SgX2r1fpPrSPDMDCZTIhEI+evWbNmCUEQcDqdyMrKglarBUEQIxK5JiwpURTh9XrNx44du6SmpuYSrVbzIEHSj+Xm5ryh0+n+15GWKEkwGAwoLy7C+g0bIAoCGJbNSBpQTnYEUaCAj/Ip11CKhJHjcj3Jsuz7LpcLBoMhqePrD57nEY1Gy7o6O/VGozEYiaS3cCxmM2pPnMD2bdsyunqKIiM7243PPvvsHJqm4XQ6YbFYhljEBEGgu7sb06dP/zjg8zVtra0dci6JPSJJEgxGA3hegMGgBwkFPM+DPIVW6f9KwkqQVU5uLtasWfODPz7z9EsajsPEiRORm5MDkiQhySfr6yiKQmd7OxiOw8uvvZbl9/nx4IMPtvX09GSPGT0aBQUFsFmtUBQQkqxkJIlwOIyc3DyC4TTYsnkzZFlGXm4uaIY5r6e7+/OZM2derNfplh88dGhBa3v78myXC3qdDsIg0tJqtZg+bTo+/fijRz768MPI0uUr/zBudAUUABIAUZJjrZklCWK8RTMUBbKiJJgsTqBadHV0Yt3qVSBJ8lu5LIkGhpFIJGfF8uVLSJJEcXExsrOzodVq/+nrY7PZoCixzdrb2zvq+LGjrzc11F01Zuy4m/QGQ+v/pgxpQqOn0+ngcrlQW1sLjJDEvV4vaIaBwWiCrMigSDJpRSsAeEnC5GnT1jqdTlkURdJoNKYkLEVR0NHerslyuc6+YNGiL1paWkCkscUNRiOqqw9hx46dMBgMGa3iSCRC1dfXn6PRaGC329Naj+FwGOPGj1+ZV1gIhtMkm4woSuzeoigSba2tcLpcmDt3LhIeSiQSGdbK+z9PWApiZJXlcmHn9q0/efWVV55jOQ6VlZXIy8kBRdNDAuydnZ1QZNn3j3feLZNEwTRv7tzavr5e7fjx45Gflwe9Xh/fKDIUWSYybUZJkqDT6WG1ygQvCFDi5TgOhwOhUOiimpqaDy//zne+YzKbV2zdunV+R2fnSofdDpPJFCOt+GYURRGcRoOJlZU4cqTmmaeeeEyaNHHin2WCgNFghN1mg9FshsFojBVLazSgGQYsy4AkCMgEGQt+ygQkWYEkS7G/kSMnLIIgYDab8fTTTz/W3NyM0tJS5OXlJasAkCGWly4w2//fGo0GeXl5cDqdqK+vW/jOW28dNJtNi8dPqNzAEicfPKk+SzMMCJKE/F/SxTUaiaCktBT2bHeMKohMJEfBYjHjgXvuQTQSxqw58xCORhCN8tDrY6RAgABBkjAY9F1Ol2t7U2PjTLfbnbSaB5OmIIo4cODAeZOnTv2ivb091p4olQfg88Ln8w9bSK/RatHR0THd6/XanE5nMtY7+LdFUYRBr0dRcclaWQG4+INMURSwLAuKotHS0owTdfUwGo0gCCLWdkmSksmm/68JiwAJm92OA/v3/+Ljjz76o0ajwbjx45HrdoNMkQ3saG8Hx3F9L7z++pi+nm5+zqxZvb19feSUSZOSOitJksDQNKLRCARBiHVASAOdToeG+lqltq5OMZstA27ovLw8HD9+/PI1q1a9edMtt15nNJpW7di65czunp61kiTBOqjLgyiKYFkOEyZMwIa1a/+0fu06YczYsX9z2GwoLipEdm4enC4X4HYDZhM4rQ4MRYIgSYAkABAIBgPIy8mBXm/E+nVrYLXaRryWFEWhurpa39zcfJnRaITD4RhSsvRtrLVU/064rKNGjUZzU5O1tbV1/X33/O68iy66aNn0mafHx8tLg4P46OvpgRCNxt2v/3kIggCWouDKzo4Vrw+zrnarBQRBIBgI4vChAxg3bhzKiwvBR3kIopiMV+Xm5GDK5MlfHzxwYKYoiindOFmWYTAaUXPkyPyQzwen3Z7WcuE4DlaTES6HHRzHpb1WOTk5WLNi+YJwOAyj0ZiW4Hw+H0aNGnV06qSqo5IswaSPEZaGi02S2n/gANqam6HX6cAwTNJC/N+aaDnlhGWxWFBTU/PLVStXPs2yLMaOHYvc2PitAVZBkqw0Gjz19NNVGo2mY97cuUJvXx85dcoU5LjdAxr2CYIAs9UKo9GIvt7ejBaWRqOF0WgaQI6yLIMgCJSWlmL/vn3XfvDee8K111xzq9vlXLd9x44zqg8d2pCwxPoH9UVRBEVRmDhxIhqbmv5KEIRYUFT4ktVmg8FohFanA8OyoGg6RqQEMaDxH0EQiEQiGDtuHAx6LViW+1auW3V1taOrq0tvsViSLsGp3GyJzSsIAnLz8mCz2/HKSy99HfR6Z1xwwQXbj9c3QRn0VKdZCR6PFwLPg9No/mtcQ0mSEAwGh40rkhQFDceBIAgwDAOGZVFeXo7q6mrU1NRg3LhxCIVCUBQFgUAAZrN5hU6nezAYDMJiiRHd4Gug1+nQ3t5e2tHZOXrSpElHenp6UqcTWRYGoxE2uz2tdUNRFFiOQ3NLy0IqXhWS6jcJgoAgCHC73Ss9Hg+6urriVqEBkWgXGurr4fN5oTcYIHi9/ydqZU8pYRmNRjQ1Nvx665Ytj9EMgzGjRyM3NxckSQ4wZWmaRnNTEywWi+flN/5xidvlbPzTn/48q629nS4vKxtCVgDQ3d2NCxYvJkiGwZeffZr2GCKRCNw5uYTBbCE+/ujDlAHwMWNG4+slX33/hptu+mjKzJlLN23evHH+wvNOX/b10o2SJFEul2uITotlWeTl5qKhoeFFs9kklhYXvxpzlYbfBFFeQFl5BXLzchENR0DR1Eg+BkeWAwynoTQaDUiSzGhZngriEgQBGo0GkydNwuEjR1bv2bM3f2JVlaelpeXkbyuAXsNBr9MC8Zvof3tnC4IgQNM0Dh8+jLb2dixcuBB9vb2I8jw4jsOkSZO2ulyuzo6ODqfFYkl9I9E0opEINmzcuEAhyCOdnR0p10Wr1aGhoR5HjxxJG4dkWRZRnrcfPnx4ut1mA8dxKa0iRVEgiSLmnnnWqslTp6LX5wdJkmhqaMCedesQjoRhMRoh/R8q6j9lhKXT6dDe1vbbAwcOPEIzDEZXVCAvNzcW5+hnFdA0jZbmZjiyHL333nf/JJKiGtdu2AC3O5s3GU+2Kx5sSdhsNmzdtEk5Ul2NhKuXzuTu7OhQWtpaFZ1On9ICI0kKBQUF4GhK8/xzLxJWq9X98KOPbpElaeaaNau+EQSBy8/PB8/zAyytRMxn3969r7iczsiC885/R1aGjyERBBCJRBEJRxHweUcceGcZGkG/TyYI4p9qHvhPZd1EEU6XC/v37TM8+vsH3/7r3/56QdjnHWCt8qEAPL09ICn6/8yNIEkSjEYjeEHArt274ff5YLPZwPM8HA4HXC7X6n379n03YamnIg+SotDa0jLfZND/mSJcsQTMYMLSaBAJh+D1+WMC3hRR4CyHE5u+2TDf7/cTpaWlaS2xSCSCbLc7atDrVtTX18PrD8Dj6UNjbR0okoDeoP8/14HklDyyNRotent67j148OAjJEVh9KhRyMvLA5GQLvQjq+amJpjM5t7Pv/hyrCTLjQvnn3PHl598UuSw25somgYZfyoNXmidTofaE8fR3t6e5kLHwDAM/D4vOjvawaaJEcQUzHoE/H7+4P79+Ozzz/cdOXTo3DvvunPn9dffMMMfCETq6+vBsuyAp6QoijAYDCjIz8fXS5e+vWXL5u/k5uWm1ecM/E0JnFYLluNAKAqouMWU6UX1s6oyfT9FURAEAQ319Th+/Di8Xi80Gg2i0Vh6PRgMorm5OeYuxd2nTOB5HmPGjsXmzZvP//DjT+dq9Qb0BoLoC4XRFwyhNxiCPxjEMHrV/3VQFAUGvQEnTpzA4erDyMvNhdPpRLbLhXHjxi2LyxfSWpQ6nQ49PT1n+X0+DceyIKEMfcUzAjKIeGZg4EuWAZJm4PH6FgIxsXC6/RUIBFBSUrJRr9WG6mtrcejAfqxbswYCH48t/h/slvQvPyI5joPP57m/qaHxAZqiUF5ejtzc3GQ2ov9N1dTUBKfTGXjplVfm1Bw73nH//Q+8snfv3hunTpnyPsWwgbjHkfLitLW14ZLvfAebN2/GmlUrkZ+Xl/J4gsEgCotLCIvdQaxduxbIz097UyoAXnjlFeXcs892zJk9a/nzL/191vz58zdnubKnP/3kE1tqT5zQl5aWItrP0hIEARazGQUFBXjnzTc/sFisi6+77trP+3p7M5KKoiigKAqcRgtvJAIybeK73zFKMkRJHtbf8vl8yM3L8//oJz/dIYvCkc2bN9esWrWKnzChkuru7pLHjB5NjZ8woWDd+g3zO9rbqhI1lenkC4nsoM1ux4b16x6fOXPmaUIkAlmWQZIkouEQ+EgEer0hmUVUCBJQYjelKMfKWhiaSpaW9HdpU2Uek+vDcf8xazLxuwRBgOO4mFsX5UEAaOvoQENzM1pbmmE2W0BS1Gqz2QyfzwedTpfSytLpdGhtbdUePX583hlz5y3r7OwYkq6UQEKn0yI3yz6kGD/hDkqSgCOHDp7Nslzy4ZwqfhUMBDB+woSVVVVVCIYjIPbvR1dXNzRaLQRJgqwooAkCcvxBTtM0CIJIEmBM8hB7JQLykGUQcYmOQsSsSYYioRAxj4emY9dGIWTQJAmajJFv4n2QZYCQY7HBf0MG8l8iLIZhEAwGH+hsb7+fpChUlJUhJ05W/QPsBEGgq6sLoyoqOl569bWyPq83MHvWrGXd3V0LjAYDcnJyuwVB0GcKljIME2+NHMoouCNJEoIgIBwJgxqBhKC1uQUcx7WEJSn30Yd+v+mySy89c+acM9Y9+cwfpt1z913bampqjKNGj0Y0Gk1uGl4QYLfbIcsy/vyHZz6zWswXXPe965c2NzdnvNFkSQLLacGwQYiCAGIY13C49HyS2KJRQJYPXXDhRWeb9bEA7d///necu2Ahuru7UVZWhltuuRXWLBd2b9968fr1617hOI3d4XAMKB4f7CI5HFmoPXFiZkdba+nYMWNO9Pb2guM4NDU1IRKJxISXsRueIEmFg6LIJBSFjDMTQZIKQRAUSZIiRVECRVHJ4LgkSaDjpUEkScJkMiX2DEGSpMJpNGDi9aL/TjfQbDbDaDQmf8dmsyEajcBgNODMs87CutWrodfrUF5W2rJ18+a9Tc3NVU6nM6Ml3dzadn6YF5cFQlGQJDHkIRTlY2supXhgcBoNmpubJ/T09ubZ+sWvUrnuer0eU6bPqNbp9SAZBiRJUAQBjiRJgZBlgiRJgoybwSRJ0iRJ8iRJignCSghK4w8TFgBIRSEIklSgKCBjlxYESSqkAiJ+rRQl/jeSJBWCJBC7zPH3AUT8b1AUJaLT6dImKv6jhEVTFCKRyEM9PT33kDSNstJS5OTkDCEriqbR3dWJcCh0+Mqrrx67fdsW/PjHP97X3d1VmZuTg7zcXOTluAVR4DMei8vlwvKlS1Db0AibzZ72fVqtDk2NDcrx48cVo8mUkQApksRjD/0e3d3d1Mzp06HRaPDVkq/W7tq954Jbf/jDpa+8/vrUG6+/ftvhw4ctY8aMGUhaPA+n0wlJknD/vfcu0Wi1C6+68srlnV1dsfcQaawsmoJBb4Df2wd6GNeMoUgwJDnsVdbodOAFgb7/d7/BTTfdhMbGRoiimIw7BYNBNDY2gaYoaLW6zysrJ+44cuTInpaWFmdeXl7aAm+WZRAMBrF169aLS0tL/+APBGC2WLBt+3Y89NBDsFmtkBUFRoPhXHtW1hsCz0vx2CMRe04Rck9PD11VNekwy9DzwuEQopEoaIZBVVUVGIaBVquFzWZDV1fX1Vu3bv3B5s2bi/t6e6NRQfhcq9Hc5XQ6EQwGhy8ABqDErYlvk9E+eGD/zOrDR+597913x/q8XmFCZeUWgRd+TxDkifFjxkLiBdQ3NqFiVAXGVU5cvv/A/ipJklJagTH1vA51x4+dwygiinJcQ9aWYRlwhAJZjA61QOKNLVetWrUwEAigsLAwrbXp9/tQWlbaPH7ChHVBQYSGJHD82LErn3ryyT/ZbDZBURRCURSCIAhZAYiuzk563ty5m7NdrsWBYBCBQAAdHR0wm81obGiY/eprr70vSRIIkiT61erGl5VQ+l9TAETs34QS4yGFjBsmsqIohAIQNEUR4XA4KIriidycnFe1Wu17p6LO81sTFk0zIEkSPM8/5PP57qFpGqUlJSnJiiAIdHZ0oLi4uPa2X9w+9q03/6F74cUXakKhcF5FRQXy8/Kg02ggAXI4Esl4Nj09PTh9zhnQGPbgSHU1cnNyUmfkohFku90ESTPYsnVLxuCyLMu46dZbUXPnnfB4vZhYVASdVoumlpYl99577+IHH3jg8w8++mjqxRdfvPPw4cOWsWPGINKPtKLRKNxuN2RFwS9vv30Zy7LnXHrJJasBoNfrA89LGMxJkiSB4bSgmBB4PpqxLEKUZYjy8C6hyPMwmkzk9JkzcbimBiWlpTj/ggvg8XiSxElAQVdXF9xuN37ykx+3HjpUfc4Pf3jrfr1ej4SCOxXB6vV61NfXn7Zq1Sp4PB5oOA4UTePixZeAIAnotVqcqK2zbt2y2aXX62MxF4JIuvZ9fX3o6elGe0cnIpEwPB4PRo8aBZPJGA90m/DII4/84YMPPridJEm0t7fDarUiHArd+fDDD5+el5c32+FwwOv1ZsxGypIEVqOB3mQaIsNIlQUx67SgafrcFStWLk+4YlarFdu3bSvv6e296qLFl8zWG/Q7xo4di22796C7zwOT2bJCq9XdHQqFYErzMNTr9ejp7h7T2NJSnJ9fUBcYVKZDCSLCvAC90QSGYYeU2RA0g6ampgFyhsHXhiAIhEJh5OUVrNBptYEIHxO8+v1+e3t7e5bf708WVid6N/T09KC7p2dUd28fwuEQvF4vWlpbEQyH0djcbK2urs5hGCZZQta/50P/TPDgrHC6v8myDJqmIctyydtvvz2fJMkLfjtr1nVmk/HfT1j9U6pmswmiKD4aCod/o9PrUVpSgly3G0hBVj6fD4Ig7H3yj3+eRFNE3uuvvX4oFAqbxowejeKiIuh0OoTDYUSjUUIQRGTygILBIEpKS4nW9nbs2bUrAxEJMBpNUEAQfJTPYLrLkBWFmDp9Riw7FJ+aY7ZYQFIUGhobP/vpT378nb+++OJHXy1dOmXReeftOHDwoG3ChAmIRCIDSCs3JweKLOMXt922ShLFs2bPnr1WISmwrGaI6BKKApIiwMWKmYEMBpScKPUZgWtDAJgwsQqCIMCk14HVaPDl518gHA5DlmVwWg2MJiOMWg18Ph9KSooPTJ8+/cVvvvnm1gkTJqTNfHEch76+vlKO45CTk4NwKITC4mJUTZ4MQRRhN5uxYtXq6O5dO1FWVpYsyE7cZD6fD+Xl5Z1WqxXBIAujyYSzzpkPpyNmJT/zzDNXv/baa7cbjUYUFhYiUeSrKAq2bt066ze/+c0LP/vZz37Y2NiYMVkgiRI0Wg3MFkvG4mdFUWA2m7EnEjF/+OGHSymaRlFhIZxOJ7RaLWRZRltbG9vS3LRq9+7duRVlZYFJ48eivrEJ06dN+ebrr77wdnZ2mk0mU8o1Y1kWje3tOHbs+MKqyVOe5wVhwA1u0Ovh8/mw9OtlSSs/eTPGzlt/4MDBOVarJW1ySVEUyJKEKdOmrdAyNPp6emDUakHRdBgAKioqYLfbB1wHt9uN4pKSHpZjAYJAlOfBsBwYhgHLcbzJZEJOTg7y8vIGfO5flYsk7t3q6uprDx061H60tv7OGRk8pFNCWBRFw2K14td3341ly1c8pgC/1up0KCspgTsFWZEkie6uLjAsu+uZP/5xaktjff5ZZ555wuP1MBMrK2OWlU4HQRBiCyNJoMjMKSe3240vP/tMOXb8OBwORwZ5hR4N9XVKXX2dYsogf2AYBjRJKg/87rdobW1F1cSJQLw4WKfToaS4GH29PR8+9+xfrl6zZvW7n3/xxZTLL7t06+HDh12jRo8GP8jSysvLA8swuOtXv1pDkOTMpStWbRtdfjLWIQOICjFhoyTL0OkNkPgootEoKIpM7xJSw7uELMeB53nl/bfejBGUokCr0WDixEps2bwJLMvC7/fjwN69kEQBX331VeIGfUWSpFvD4TB0Ol3K4G68u4D5sssuA0EQsNvteO+997D4wgsH3EPZ2dlgGCapuUuQC0VRsY0rS6BJAqIkY9mKFWAYFizLMi+9/PKfiHiraqfTOeDzM2bMwNGjR29duXLl49nZ2fW+DFaWLMfig7peDxQl883mys7Gi3997pG62lqqpKQkWe6U0OkVFRXh6NEa05tvvPHDK6+66ulwOAxfXy84jYbPyclZc+DAgUvS3dCyLIOiabS3NJ8rRyPPk7I04JhlgQdHUxhVWgKGYQb8zenMwqZNm+Z5vR6muLg4bQyP53nk5ObIOg23asOG9ch2ZSMn2wUqHj5IJDmGXAcAiiRCEQUQsgyWpsDSNBiSlBMi2sGfOxUwmUyYNKkKmzdv/lVJWfmfZ0yd0vxvIyxJkmCxWKDXavHRhx8+dqKu7tc5bjdKiouRqK0aYFmRJDo6OpCdnX34hz/60UyWZQsWLDi3rs/jISdVVSE/Ly8pCpX7zRociT7IYDBCo9UiFE/Pp9swDMNAo9EOtW4GW40AsuIB1MQGVBQFkiSB4ziMGzsOoiy/8+Nf3PHVg/f8tv7551+YfN7ChTuNRoM7Jyd3gE4rGo3CkZUFhmVxqLp600cfvD/rtJkztgXDESSyPUajAdmubFA0BUmM1aol7G8l5TGOrM9ewhQ3mc3g4tk/kiQh8gKmTJkCg9GIXTt34sjhauTk5CQbJNI03WAwGKS+vj5Kr0+t2WEYBoIgMIcOHgQAOLKy0BnrqgGD0Qg6HmNJ1LklXv1LfyRJIqPRKELhMFiWhZ5jYTKZUH3oUFF9bW2Wy+WC1WpNBuT7y2AikQh4nr/rmmuv+3Fzc/p9zrIsPB4PGpuaMsa79Ho9/P6A/khNzQ81Gk3KcidRFJGd7cbhI0fOfemll54GCEyfPg35+fkYO3bsiu3bt18iCEJyZuaQ2JjZjCM1NWf1eTys0+Xig/32q1arhS7ursmKkpTxxIiOQU9v38JE7zOKolJaOoFAABMmTNjldrt7vF4PcnPzToq4gLTXQZZlkucFRHk+2QsucR+k+9ypgCzLYFkOoiDAoGHPA/D3fwthSZIEi9UKu9WCX/zi9j/U1dffnu1yoaSkBO7s7KFkRRBob21FfkHhnj+/8MIsp9UiPvvsX27u7Owiq+KWVX8FuyxJoEgSM+fMQXt7B5GpA2NnZyeuv+kmQqPX48vPP0VJcXHK94XDYeTm5RMmi5X47NNPMhKgJMvEL351J1auWkX4/f4hf9doNKBZ1uOyW6Wvv/oKF1x0ceunXy2Z+sObb9pM00yh3W4fsNEFQYDZbMaUyZOpv7/w/Ddvvv7azJLS0l0GowEulxujR43CgnPnQ2cwxDJ7BAGFIMBLMlIZDiONYfGxmj5i0eJLYrKDeB2bJEm46eab8NLLL+PPzz6LUaNGwecPxH+LAMsyZKJqP50gUhAE0AwjVFZNivdUknHeBYuQW1gEhmGQZbVg6bLlxBOPPYrc3NxU4SIoikLwkgxekkBKMhhOA1ajhd5osul0Omi12mTrnv6/L0kS7DYb9u/ff70/FPpFUWkZHwwEUq6B1W7Hnp07sH7NKugNRpApFlSBgixHFnbs2HFFR3s7VVZW1q+wXhlwgymyDJbj2GkzT4OG49DR3obOnTuh1WqXJ+QNWVlZKddMq9Wis7PTdKK2bnZhUfGaYCiUDHZICkDRDAwm00nrM/5giESj2Ld//4JEMiKdnMHr9WLylKmr5syZg7buHvDhMOQYWxEZwnZQFIUQJBmiLEOQZAiSBF6SIEryv322gyzLIAkCrEZr/Ve+hx7OssrLy8NPfvrTP//tr3+9zW63o6KiAq64VTLYDWxvb0d5efm2q665ZubRo8ew1+fB0ZojvSzLwmKxQKfVQuiXRidJEoIkoXr/ARjNJiXTk9FqtWLn9u3KsaM1MJnMGXVh3V2dSmt7u6LV6TOKLUmSVD7+4H10d3crZaWlKddAQ9ORosLCcO2JE9MOVx/yzZszu8ZgNE0/dPDgtqnTphXpdLohpMVxHMaPH0+3tbVt0up0M/LzC/bp9AYYDAaQ8U2aGNZKkyQkRYpZW4MeahRBJs384eQloiAoW77ZmGwXrCgKGIZBY+1xHNh/ABOrqnDG7NlobW2FIAiw2exoam5ydXd3U3lpNG0Jy4WPRrvWrl0DRVbAaTgcO3oMb7/zNrRaLTiWRVd3t2IwGFK6EYoCEASh0CQJlqahKDL6ensgCQJ8Xq+caAOcLu1ttlhQV1enW7Xs6wuuuOKKT/u6O1O6hQFvHziGxvkXLEprYZEkCavVis+/+OL7CVclnRUTCocxyuGQL1p0AWRZRs2RIzhy5AjKy8vr1q1bd6S9vX10utBEwq3atXPHOe5s15q2tnYQcXkDTdHw+33Jh3XCy9BoNOhoby/t7uoqt1qtaeUMCSlGdrbri+bmJgQjPMwGPQgg4145eR0ISERMPxXTUZGg+kkvEpbyt7GwEhq7jJ8hCBAkAb/P137KCSuxKO6cHPz4Rz969vkXXviZw27HuHHj4MzKGkJWFEWhsaEBpWVlO393770zI9EobvnBLc9SFFm9b9/e4454oefgAHKibKfu+DGMnTA+Y8mKwWDAkepqNDc1ZewjRFEUwqEQvJ6+YfVaJEFg1YoViEajKSvniVghM+HxepUTJ05MW7FixX3vvPd+zg9uuaXzkYcenNrQ1LQ91+0uSWiI+pOWwWCA0+nk6utqt1it1mmubPchOUVsJXHOBBQMNrMokkhpKQz5jnjrkQP79iIUDAFELJtL0TQi4XCsSRvDoLi0FDfeeCN88bKTRx555OJwOAwuXgicasNFo1G4nM4jDE2js6MDBQX5qD1xHLt27hzwvkSWOO0xkgSouOaHYxhwLAOGoUd0VzAMg61bt14/b+7cTwN+f8pEBMsy8PTFCoBpmkqZvrFYLDhw4EDekSNH5jgcjrRxu8Q11HCcoSAuPJZEEQG/H6NGjcLEiROXHThwYHTC9R78eVmWoYnpqRYQwG/tdhskSUzGg2kqJh5laDrm9iM+p3PjxoVerxe5ublJjdoQIg2FkJeX15Wbk7Pj2LHj0Ou0sJtNSa38sHslTlCJS0XFHpwMQRAQRRF9fX3fSnSbMCaoQZ1YBiMSDsNqtaGsvHz1KSUsURRhdziQne3GL++446+vvvrqj7PsdowdOxbOQRmgxI3fUF+PqsmTdzz+9NPTt27Zgjdef/2FLVu33PrDH/7ojpmnz/K++PzfUt4QkiSBpiictWAhPF4vkWngQ1tbGy669FJs2bIF69euRV5uLkRRhM/nS/Y7T5IOSYKkaCIT44uCAEmS8PATT+C7V1wJr9eb0m1kWRaz5syBx+M58tbbb7tKios2Hq+tm5WXm9Nz++23z+js6toqimKpzWYbQFoJC1UURe2unTu2OLKc00ZVlNf0XzslHsOQCQJRQQQ5qIfSSJXu0WgULMcR373u+uQNo9NwWLthA5Z++SUKCwvR3NqGJ554Ap1tbbjm2mvR1NKq/etzz/0yMTwhXTeAUCiEseMnbJ0/fz7au7qh1+vhyHajpGIUNBoNbGYTNnzzDfHqyy/D5XKl1kcBBC9JEGQ5VpYkCGAEAbwgDuuKJDpoHD9+/PyN33xj0un1vnAoPOTuFHgeFosVo8eOg5RCDKsoCgry8/CHP/7x2r6+PowZMwYsm37ad9z6JwKhEEiCgCCKaGptAy/JsDuyVmg0ml+EQqG0w0D0ej3a2tomc1pd3sRJk5p7+zxx8qXh8/lx7NgxEPGHJggCoFg0NDQuIEkibXcGAOjr68UZc+eunTFzptTd5wFBAFFBiDWWjGml0uvUlNh1iIoiFIJMGgwANgcCgXOmTJkSeujhh7UBv5/meR6SLJNEbC1kWZYJBSAokpAVBYQsy4SiKEpBQYHv3Xffve2zzz67KlHhkmot21pbcfmVV65ffPHFLaeUsIqLi8Fptfj9A/f//Z133r45y+HAuLFjY+lqYAhZNTY0YMyYMRtffOmlM9q7unH9tdeu6uruPttgMCDLmdXS0dGZVESnWkQ5nvWIBY4z6b9oRMIR0e/3sx6PBx6PB1arVXI4HC3x9Lmjp6dHFwwEAEUx0BQdJYbR4iBe3iBLUuqsSMzxBx/lIQoCYTaZACin33/vPZtvu+22M08//fTuPXv3Tm1rb98GoMJutyeV44nuB/F2NcZlS5dszc/LnX766acfk/plYQiCAE0QEKRYg8L+BTsjVboTcZs/1po3FhsM+rzw9PXBEVfkxwSC9diyZQtO1Nbi1ddeW97W3m6qqKhIXp/B1ygSicBmteD000/7QqPRwGq1wGgwYMfOHejt7YFBbwAkEcFgcNiODUS//zt5WiNzOzQaDRobG5nGxsYrLv/Od15uaWkZ8nsxwrIgNycHkiQOSVYwDAMNx2L3rt3fTxDK4C4i6W90BRyngcMRK6eZMmXKRofDEerq6tIlmuINXjuO49De3o59+/YuqCgrfcXvi2U4TQYD2lpbseTrZaDpRGkMDZqmuX379p5tNpnTluMk/ltFRfkyjmXhyMpC0O9HMOpNrLEykr2iyDJ0Wi2MBgNEUQRBEL2iKK62WCw4bebMZCxYlGIZTireIVhWABIyOE4zQPR68803v+jz+ZAT7yacah/p9XpceumlN5xy4eiBAwfOWLpkyYNLli6dl+1yYfTo0chyOFJYVhTq62pRNWnSut/ec8+ZGzZsIH/xi1/s7erunlCQn48shwNOh0PuaGuTkeZpQcZGcmH96pUYXzlRZhg2rZ7DbDbji88+tbd1tCtnzJ238/TTZv7RZDRuvOSyy5psdgfefP21rJaWlpkNjY03AejyeT0OURRPZuJSuBkUSeKh++5Dd083CgsLhi5O/Pg2rF+LSCiU7It16MCB0+668869Wq12/ne/+93mlpaW6evWrNkiCsIYl8s1YBisKIrIyclBJBy2vPHaa/vmzJntdLmyA9G4oFCJnx9DkVCUgRWGI1W6sxpNTNbw9lvJzNXRmhpUjBkLbbxPu6IoKCwohCzL1g8//PDDhvr6Obm5ubDb7SnV1CRJoq+3F1OmTVtHkmTrmrXrQBBAliMLP/vhD1FbVzfgPkq0ERoa6AYIQGEoEjIVi9uxFAWWosBQ1IjEPrEaNhrNzc03mU2mlwWeHyJdoCkawWAQ+/fujpVkDeJPl9OFbTu2T9y+fVuF2+2Grt+6ZLi5FYokIEkyzEYDIqEgGupqkZ+fH8jNzV1fXV19XlFRUYbMLXC0pmYBxWlf0cTjqQTDwmazYeKYCiBOBg6HA9u2bz+tt7dXVxAfKJwufpXtzkGYF1Z/8sWX8Hj6MGPKFBQWFMRjWOkJK7bPoDCxdQdBAGazGX6/Pxne4Xke4UgEnr4+RCKRAYQV29NAbk42ent78eVXX8Gg02HN2rU/371794SKioq01lVnZyfOOvPMN3PdOfV1Tc0ozs87dYT1ySefGDra2zmWYVBaWopslyupCu9/EHW1JzBz1qztzz333JkvvPiS6e47f7nP5w8UlZeXo7iwEJFwGMUlJURBYaHhjTfeSJ85IElUTpoMmmHIVD5wYlR9JBJBVVWV5fpJk14nSOpvZrMJHa2tIEky3gqW6iovL/8yNy/vy7yCAioUCs1asXIlIpFIsod8/8du4pyu/t73UF1Tg1CKUUdSXK07fkIlvlm/gRRFEQLPY+yYMWhsahq9Yf36nT+//fZ5119/w5Hurq7pdbV1W5uamsbl5+cnSSuR8mc5DuUV5TskUeKbm5ogCHw/6YICi80GjUYLURIHZwmHl3zwPFiWxZlnnYVjx4/j2NGjyHK5wHIcIpFYx8oI34mA13vTsq+XPBoMhpw5OTnIzc1Ne+MmNHJXfPfqp0vKysG0tIKiaVhMJlx25VXYv28vLBYLtByH+oYG7N61C5lq7BLnQhBELEsV+zc5UsJyOp3YvWvXzG3btxeOGzeuoaend0DMT6+n0dHdg61btiVjcv33WW5eHr5etvwGSZJgj8dURxJYlmQFgiiCICk4nS4QIFCQn4+JlZUrd+7ceZ4oiim/S1EUWC1WHD167NwTtbWU3mCQwqEQFIJAOBpFMMrHAtEgYFIIdHR1L0x0EUmXCPB4+jBufKV/0UWLG0OhICIRHnqjEeFIGAajcURlSYnrIIsyWI6DPq49HM4t5zgOVqsN1YeP4M233sTuXbvBMDR2bN9+r9FoTB734HWIRqPQ6/X4zlVX3aPT6dDS2gqcSsJyOZ1Lp0yZsjSvoPBnvd2dz/b19SVbByf0PsePH8fcuXNX/enZZ+evXrcu547bf3EgHA7bRo8aheKiIhiNRnRGo/D6fGQoGKKZNMFvJZ7qLCwuQUdnxxBNC0mS8Ho8IEmi7trrb7jjqquuWrp39y5+1do1EEUBoiiC5/nY00AUEY1GEQgGUTV5snT7HXd8c+zEie8fPXLkhe7ubi7b5RrQdSGhdD9j3pkwm81Eqpa2siyDpigUFBWDig+0kJXYBo6Zv4Tr3t/9bvev7rrrrNNmnrbVZndMrzlcvflEbe3E0pKS5BOqp6cHLMv4fvHLuy8qKCrmOzvaT1ojcbdT5CMQxIGyjrjSffjSnNggDGLRokV44623ceDjj7FwwQLoTCa0tbYWdLS3X7Jz164fePr6xhEEgby8PGRnZ6cNOlMUhfq6OsxfsODjC89buCQiSsjPz4OGZaEQwKzZszF16lTQDAOHxYxlK1YSmzdtyphOl2UlOeBBkhUk/j1SMAyDnt5e1NfXX3/ZpZf+/nhd/YCEhEbDQSFIBHgJLMMMCC9otFpEwhFi//4D12g4Lm3MLkVmjVAUQJYVKIqMnPxCcEYzrFlZOG3umSvffucdeL3etPIGvcGAzo5284G9u6dPrKra0t3VBZZh4PX7YTRbYgFwmoYCYN/+/eclynHSyRl8Xi8qJ1a+V5qfCz6u3fN0dyMxpUfJFMPqfx3iL0EUYTSa0nZVUOICQZvNBkEQsXTpEny1ZClCwSDmn3su9uzZc2swGLQXFRUlS5X6HzdJkmhra8UFiy786Owzz2wMiRKKhpnF+K0JKxgMxibP5OT+ZXLVxK0H9u9/9/ixY6VlZWWQFQUnjh/HJZdcsvwHt9668N5773U/88wzNeFw2DB+3DgUFBTAENe1yHHTgYAipwtOkRQFXhSxfvVKFJWUKv3bbVAUhe6uLjiyso5NGD9+emFxkUer4WImrCiljZkkpsGIoiRbrNbXL1i0aFNnR8d7h6qrJ1eUl8cKZGUZdMwlVB66/z60trYqVRMnDr1JKApRnsfGdWshRCJK8sLGK+1zc/NQV1urfeShh7aMGTv2ApIkl1540UXTVyxf/k1NTc20MWPHwtPXh2g0ivvuv//8CePHeDs6umA26pPWFUWR4HkeITE6JCM4UpeQYRjw0Whw6dKl6GzvMIEgKg8cPHh6Z2fn/GPHjp3p8/kojo1NfrbHB27QaYao0jSNtrY2mC2Wzhu///1rBElCIBiCJEswaTV458MPcc0VVwz+fcVms6W8Jol0OkOTkKW4S0iTYGlqRCr+/g8Pm82GjevXX/edyy//vVHDIhw5+ZCReR46lkFxbna8Q0KyEg75+flYumTJ/NaWpqzc3JgWcCR9zQkCCk0SEIlYUb3X24cd23cgy+EARZEHs93uup7u7uJM8gZ/IIDmpqYFi84/fwsR33c6nQ6ELAEgYLGY0djY5O5sb6+0WCxp5QyJKdS5OTlvCqIIjz8Qc4tlGSwTu43JDA3K+l8HhiYhy7H/aDIakm1u+rv0iqKApWPi4KbmZqxdsxY1R2tQmJ8Hi8UClmVx+OCBB2iagc1mO9mepn/SiBdgNBgxeeLEX3p8PigkCT7Kw6ThTh1hURQFRVbQ3t6GGdOm7Kiqqqr86KOP3j92/PgiQMHsOXM+v/s3v1l88003lb319tt7OY7TV06YgIKCAujiAyMSCx7jq+EtBIYeqMMhCAKBQAAEQQi3//KXZ2dnZ3uaWlvR3dsLgedH1JJXFEW0t7Vh+tSpx06bOXOKx+P5qLa29rKy8vLkSC6CQNon2oD4EsNgcBxOURREo1EUFRejq6sL1YcOLRFE8WqSJN/93vXXn/b6669v3rVz53S3242bfvCDS89dsGCTz+MBBelknIokQEKGyEdSh59HeDvHg+ajXnjhhY3Hjh0b39vbazmwf3+8RYwDxcXFMBqNMBgMSalHKpeDpmm0t7dDliQ8+cwz50yuqor29nnAcBpwHIs+nx9PPPwwEhqmxE0/kgaGsWro/v+/8q0azCmKAqvVitq62rItO3bOmDJl8raOrp7kXmA1HPq6ulB3rCZuMZwkLG9vDz775OMbJEmG1WpNKxkYTmvEkiQajh5BT5sR2dku5Ljdy3bv3v2jhOeRSt6g1Wpx/Pjx870+3wMUTUMbm4aDL79aApIk4XQ6UV1dfW685jKtqxqJRJCbl+fLz8vbceTwYfi8XhiNRuTk5kCSvkWLauXkSwHg9/lQVVWFrKws9G+FrdfpwIsSduzahW07dkIUBJSPHhMbm5eXhzWrVn3/6LFj2UWFhcn2PIOtq66uVsyaPWfZqLHjGjdv2ZrsweY6c96pF45SFIWWlhaMHj06dPMPbrnwoQcfeN1oNBU8/tRTi3/3u3vw1ttvv2K32fTZLhcKCwqS022SwWZBgNFkJgmSJNL5yAnx3Kx5Z6K9oz2pdCcAdHZ04JYf/+SXM2fObBIBWJwuEACy3G5g9+4RnZwgCmhpaYFep8NTzzxz+aOPPbZy/+7d54wfPx48z0OrM1D3Pvh7rFu/nvD5fCldLZZhcNrsOWhoaBhyHglrzm6zQ6vRoKOr87V169Z9WF5eLv7q7l+f9sQjD6+bM3v2p6fNmvVpW1sbWIaBAiIZSqNJEqFIFIFwNBa3GBRIFmKxnmF3I8uy8Hq9zq6uLqcsy3A6neA4LtlummXZJKlksix8Ph+cTufRZ/74p5smThh/gJcUuBx2RCQFQjSKzu4e/PyOX8LusCcJwWExY+ny5cRTjz+eUekuSLG4FUEQoCQZvDSycxu8JyVRxKqVK76XV1C4rbOzIxnH0un0aG5qwr59+8H2m83HMAyqj9Ro9uzdd4nFYkm6gyMp7lUUEKKsQJIV8KIIk8WCcRMqodfr4HS60NXdu3Lbtm0/CofDacfOWywWNDY2TtmwcaPdYrH0CIKAgN+PgoJCUBQJm82ONWvWnksQRNrGgADQ29OD6TNmbJgzd26ku88DhzsHkiggEuWTI8XkEbiEMYW7nNxrfXHF/q9/+1scralBoq60tbUFO/fuR1t7O1zx/RQrsWFBUhQ2rFv3MEVRsKa1rngQIHDN9254fMaM6WhsbY+Vyv2L/f8zlubQNI2+vj7oDUbk5uffcNbZ56Crpxd/eOZpZDkcokajQU48cDu4ERxFUYiEQwofjSrpBKGJFspHDx+GVq9TEqUKPT09GDd+fO3V1177FwGALxAERZIw6rSwZmVBFEWQabo7J574DMvCarHBbrcjOzsb4VAYF5x/weWbN27s6u3tZWI96Fv7tn/5BXxer2ItLEwpshMlCcdqaiAJQsrzUBQFgiiA02iQk+3u1mq00q6dOzF77jz5xpt/cAYTd20NOh2IQR0mZUUBz0fjosqhGgaKIECNoA9xoj9TdnZ2Ms6Y7ATaL2Y3XEfUcCiEs84+a1l5Wek3S75ejkg0gl07d2H61Km48KJF6GprxV//8pe4SxBzj1mGQVt7u5IggnSuCBkXjsYyY0RCSPqtzBw5XjTe1tx8ZV6W/acVRQVKIlmi4Tjk2K0wajVJF0cBkON246OPPrq0o6NDU15entblSucSkkRMvCvwPKwWK0pKSiDLEoxGA2bOnLH2vffelbq7u6l0cTGO49Dc3Ez29vTMnzljxns9PT3o02jQ1taeaG1NeDx9CzQaTdruDInvLSosXB70++HzeiFKEnQaDtp+MyqJEbiEZHztifizgqJp9HR3o6S4GJXjJ8Dj8cDT14eamhqQioxRJcXJtZQlCWVlZfjwww+vrqk5klNQUDDA0u5vXbW0tGDBggUrzpwza31AEGG2mHEqQI/EFE7opHp6uvHE44+DZVlodbooHR+XlOqpHVdZy3wkoqQrbk7oYGoOV2PchAkKHQ9ABoJBzJ8//349x6KhuSWZfRD5KGSeB00zCEfCQ26QROEzx7KwmI14/NFHodFwYFkWPp8Pl12y2Lt29apPv/zyyyvOnT8fTz/5RHDDps3QcFzKCSYkSUIURRyrOQJRFJThGpARJBkReV45sHcvln75BSZWTYISP/bBx0rFJROSKIJNk5SgvuWknARRJQjo28yfIwgCWU4nNm7YeNvpM2eeUVRUdMfiSxavff/dd8BRJM4/bwEmVVVCiEawZvWqIZ9PJxpMbjSShNSvHClWEkJ+6wpbq9WK2tpa+1dLliycPWvW1y2trcmpN6FQCMFAAOFEZwIAJoMBhw4duokgCBgMhrQZuPT7n4i9CAIMQ6G9rRWRSAQsy8Bms3mKCgs3Vh8+PK+goCDjA7S5uXlBKBh8LxgIQBQEWCxmOBwO7Nu3b2p9fb09Nzc3KWcYfM0Sg0EYmlq27Ouv4fV6IPAC5s6dC3txEYLBGGmPZKfE133Ao5EiSYiCgN6eblTzETA0DVu/Nj8JXzJRB/zJJ588CiCZbR28noIggGVZXHnFFb8EgIDHM3Bv6LT/PsLiOA4mswWjR4/Gxx99hJ7eXhQVF8cGGvRzMwaD53mYLBaSpGlSTKNgT1gGZ527AD6/j+R5HqFgEGNHj/ZNnjLlveamJoT8/qTh4e9VoNVqccEF5+PAwYPo6exMkkGiyry7pwd/fvZZOO12cBoNBEGAFHdF7HY7Gpua1suSdEVrSwsuu+JK+qYf/gS/+/Xd8Ho9AAqGuIQcy2Le2Wfj808+JYUMSvxwOAy9wUDc9qs7QdExa6e1uQUBnzc5op7qR16yLCMQCkGQ5fhAghQu7QiV7v1vjn+1yp6maYQjkapdu3evMVutvx01ZvRjdocd4XhL5Gf+8AcsX7UKJSWlkCQRFqMR32zeQvzj9ddSyhoGKN2lmEtAxYtuBUn6p4tu9+7de8PZZ5/9dUJpTsRdY31SyAlYzSYcP1Hr2rhx41k2m+1kU7sRrpECEGLsGiTb1zjdOWhtawOn0cBkc6CkvHzl9h075iWGrKaSNxgNBpw4cWK+LxiCxeGA2N0NgecTGqXzJElKkmmqY/N6PKgYPbr2ksuvOA6CAM/HWhtxDAufP5AMMYxU6S6kmCCduB8VigFnMEKWpAEhRkmSkF9ShrfeeOOK6urqwvz8/KTKf7B11djYiPnnnrv6jLlzD/b0eQBFxqlq/kCnyjglKuhNJhMEQcDBgwdx4MBBNDQ2QqvVgtYOz5DxBTrpQGe80U5O6o3yUTidziVer1dsaGwc0l9FgQKjwQgtx8Hn88XU8rIMu92O/IICEASB/fv3AwQBup9FpAAwm0ygKerYwf374fX5YhsEiZs8QzdLWRnReUBRIEki9AYDmhsbUXPkCKomToROp4PBYIBOq4UoimBoGl09PYhGeTAMPfxC/oeQ6NhQWFgIj8eDJV999ajVanXbr7nmNq1Wi6amJsyfPx+iomDb9u2wmC1xPZs0gkRI/+kw//zJybIMi8WCY8eOLVYUxVBVVRXweDwxa1iSYi2J41KRgvx8rFi58rpQKIT8/PyMpTiZDjse/4GG49Dn8eBEbS0sFgt8gQCcruyvjUbjI36/H4lM6ZDuDToduru7cxsa6ieNHTtujySKcLmc0Gm12L9//8KYLEOTtjwqEAyioqJiududjfaubjAsB4qmQEgyJFFMFlZ/6xMbZMVpNBxcWVkpKwC0Wg14Poq33nrzSQDJtjyprCuKJHHZ5ZffSRAEQDNgGfaU7eMhd0soFEJbWxvaWluxdOlS+AMBtLa2IhqNwma1jjhgybAsfF6PHA2HZTrDhFuB57F2xQqMq6yUGZYFRVLIcrl2d3d3o7u7O+WN0NXZBUWWUV5ejkS3BBAkgqEQ7HYbzjjjjISsYsDnHFlZYFm2IRyJwGAy4bWXXyZ27d0LnVaL7OwxQxcnLmvYsHY1+GhYzjQFRKfTIRqJ4OH77o3JKiQJbncO6mtrY72+48NQZUWG1+vDNddei9Nnz0Jvd0/6NRyhrOFUI1EHOW7cOBw6dOhn27Zt67z88ssfTui2DuzdgwfvvXcAVQ+ndGcpEsoQpTv5T7W1NBgMqK+vZ7/++uvLFy9e/HpDfT04jQZejwfNzU2gKRokReGow4FPP/nkejI+DXkkpTiDbmkl4coqRKxguKKkGJ7uLphMRjAMA+vYMXtsNltrV1dXTqK9cLpYcFtz84IF55yzJxIKoqu7F71NzbbW1tYZZnP6cpxEm+psl/Pr3Tt2oKOjHYIQG0BROXEiOO5kDCtTTDChdGcpCiJFQSYGroMkSDAaDLBazLHWR4P2w5jRo/HSiy9eeujgwcK8vLy0mcHm5mbMPeOMNbNPO21PR1dXalGqXnfqCOtITU2yRUk0GgVJktBqtbBYLMkDHKmsQKvTkYqikHK6LGFc6T5mwgQwGg0piSL8fj8mVlX1nn/++SkLkvs/ebQ6HSiCwEcff4Jrr7t2xGGJHLcboWAQc+bOJcZXVmLp0qUple6JvtSjx4xDX6+HzKQI5nkeNMPg4ksvB8MykOWYteX3+yHLckx4K4hQEMs4SYoCWUFGJbsoyyknq/y7ocTVzyzLYuzYsXj11VcfGjNmzNZbb711VU9PD6699jrs2LkLPb29cNhsaG5pQfWhQxnJYLDSXfwWSvdUx6fRaLBr167rz1248HU23tpYZzSiqKwCAAG71Yw9e/eN3b9//3iXy/Wt3cH+e0COXweKohEIhVBXXw+bzQZFUZCdnY2ioqKV27dvv3647g3HT5w4r7u7+/FIlEdWdjbWrFp5bmdnJzlq1Ki0coZwOIwsh0MYP6FyvUarhT3LGc/Am0CQJARRTD6Yv5XSvd+1IhCrZdUZjCAZDrIgDpCF6PRGdPd58bfnn38ik3WVIM4LL7nkQYKm0dfbe8qnldPpnggMy0LTz/Xrr0oeySWXJQkajZaIN8pLvfHiSvfSigp0dMSU7gxNQxAEIhF8T02GErKyHPB4vNi/dw88fR4svngxtFpNLF6VIR7X09Mjb9u2DZ6+PkyfMRMFRYVYt25dUi084ALEle4lZWXYvn1bxhuS53lotFqcs2ABzBYLwuFwegtGlmAxm9HT05NR7S0rSsa4xH/C0tJqtSgqKsLfnn/+ozFjxjhcTqdIkSTuuutu1DU2Ii/bhSVfLyN27tiRMZ0+WOkufUul+2DCslqtOHr06LyAP5A3edKk5u7ubshKbCaiogB5uW6898EHN8Z6f6VOvY9E1iArQOLFCwJycnLhdruT7YRNJhMKCgqWb9y48XpBENJm+ixmM+rq6mZ1ev12m9PV097ciNbGhnMJItadIZ315/f7UF4xatOEydN8QjQCkyBAUQCWpmLj0uSTBfPfSunev2GhJIGmGeS43bCYDNCw9ACyzXW78cqrr110YP/+stzc3JSxK4Ig0NrSgtmzZ29fsPC8DaFIBNYs1ykPadCpMmPfzvtN88WxCcxyOBRK25gvoXT/Zu1aFBQWKgzDQKPV4uD+/Vkcw6CzqyulNafRaODp68PBgwcxfcYMFJcUY9as0zFz5kxUTpyIYDCY0hLMzs7Gpm++0Z9//vkwWyz4x+uvYdfu3eB5HqmKWBMu4aaNGyBEoxkbDCZcwqceexRK3JJId7N19/Tg7t/8BhdccAHaWlvTu4TkyFxCiqIQjUbR0dEOSTr5lCdSPFwSWpqERkun02WUPAiCgJycHOzevcv83vvvP/nYE0/eQZAkvnr5Zdz+89tiQwwYRrHGwwXp0ukMRUImEy4hCZbOfG6JCUyJwufBx6fRaNDa0oKVK1dcm5uf/3hrRyeEaBQhvxdarRatjXX48tNPv8uybMpSnESNZ6ZrmlC6SyQBhSTAsTRIAmhsqAdN06ApGu1trTAa9KvsNpvi8XiI7Ozs1PIGjQZtra3U0cPVZ82dO/dDDcPgwIH953JpMtSJNQiHQphYVXXcZtShg4/GtHwEAUKSQGBg7/URKd1jcwLQnxt5SYLRoIdOw4EPh6EkS+SUWNNNnsdLL8Ssq6ysrKQma/DDTZZlXHTRxT/jKBJBWQbD/pcNUh0uTZ68XYYLusdPniAIyJKEzs7O2QVFRTDF3dD+m4ymaZSWluKWW25BfV0tFl96KWiWwYkTJ/DnP/0JV19zDaLRaMoBoQajESeOHy+P9XzXxH46+T4i4xM9fsVHZFnKSgbCkpWTAlvi1Dx+AoEAsrKymq+95ppnGI6DKIqxbsbxQZgkQSgJUSHLMFIgECB27do1pr6+flFnZ0eu3WYHmSHdLwgCyssr8M3GjbcfOLD/salTpnadc/bZsFqt6OvrG9Dqd0RPuRGcdsIdTxSpD3a1JEmC2WLGrt27r6+aOu3xaDSKUCCAcMAPl8uFHTt2zD12/HhOfn7+kPY5CTLsP6xhJAiFQnA5nTj9jLno7fNAo+FAECQsZnPXpi3bdtbVnpiWqidYfwY8dvjQ3OmTJ314sLq6srW1LTfhXqXK8EqSBL3OgGnTpr5DAKDpmFyDIElIggI5+k/kLVJ0+jMYDPB4vXjhpZcGXUsCZrMJWzZvXrB9x47ROTk5KWNXiUHJ02dM31xVVbm9vas7qbFMHYTUnzrCGomRPpL3CDwPo8lCEiRFiGl6tSeU7nPOOhsdnR0Ez/PIyspCXV3dAq/Xa8rPz/f19vYOmHUWM+1jtXx6vSGeJYmZ5rwggCBJZOfkIj8vD42NjfD7/clNmZefh9oTtaOCwSD8Ph9++rPb8LsHHsC1V10Fny9FA7+4rGH2GXPR3Nyc9jwSm9lkNuOnt98Bs9mMcCScdvEkWYbVYkZLa2vGGNVIle4Bvx8lpaX1t9x6658G5lOJlPu5o6MDLMuivLxcs3v3ngdqao7cbbFY0rpNicBvS0sLVi1b9sPi/LyHZJHHG2+9DR3HYvW6dcTTTzyBnBSzIpMKa7Gf0l2UwYuZzy0SiaBi1Kg2o9HU/s3GDZPs9qGjocxmCxpqa0d3tDRPmDZj5oG9e3Zjy+bNyC8owMaNG28gSRKpzisajSI72+0rKi46/s3GjZMTDfNSuYSiHHMzRVmBIsSSO1qdHmw4Ai5ek2h3OFBeUbFi755d0zIPWdWiuaX1gjHjxv30rbffnhsOh2GxWNKWCvl8PhSXlbZNqJq0VgHAcZo44RDgoxEIkgSy33TzESndRRmCeFLpDgUQQiFYrDZMnZ41YHALw7DQaDR47rnnnkpYV6kyrbIsIxqN4jtXXX13UVExmlrbkxn4f7uFRYyQpIeNbFMUopGwwkejA2avDfieOAvXHT8GVqMBRVHQxExnetM339z2qzvvfJgiSYCILYrbnYOPPvoI4XAEOdlueHp7ByyayWiEIIjYsmUzOotLMG36NIwePRrBYDA2IMJkxuuvvnoxQRCwWq3YvXOnsmrVSoRCoZSjwxJK97raE5AEMaO7zLIsRFHEulWrwLBssiVuKtM8EAjg/AvOR2VlZWzYabo1jFtHw621RqtFwO/Xrli9BllZDuQ4naBoCv5gCDRFJRuwKQAMOi1aWlrg8XhgMBgilVVVvz5Sc+R4Q0PD38vKytJaHInM4Z69e68+dvzEQxqNBrt2bMeunTvh8XiVRAYxnSuSEF8S/ZTumdo/S7FOF62nnTbzR5u+2bg5EonQg9tYUxQFr8+H1tbW748dNeoOkY9Cw7IIBoPsK6+88h2dToehxxUb4jBz5sy/m02mVb29vV+7XK6UHQtiSncg8VIQy/bSUNDT2pLsUNAiSyguLPhKrzf8LhAIpB3NbjQa0d7RUbRm9WpdbW1tZSKhlU7O4Pf7MaqiYgVHU6htbIwF0gDIigwdx8VbLA+wdEakdCdJAog/KwiSgEajweaNG1BfXw+D4WRywmQyo7ml5aymxsYJOTk5SMxiHBCwJwh0dnaiauLEHbNmzfpGBmC2WuMhCeLfT1in7ItjymOZj0RkMsNQAFmWcWj/foyrrJTjk2KR43ZjzerVd8+aPecpg8kU7erqgsloBEsz2L59O9zuHOhSpEZjrZJjPveqlSug1WlhdzpRUFCI0eVl+PiTT+fs3btnSm5uHlwuF9atXY0du/dAq9EglVI5oXSvPngQosjLmeId8WEN+PiD92MZQ5pK4+ooaG9vR+WE8Zg3bx4CKWoYk2sYVyUPKyFhGNA0jQ/ffRs9PT04Y+5cXH7pZbFmfmkymyRJ4vjx43Blu3Hfffe9/PeXXhq/d+/en1dVVaV0T2Ib2IS2trbRPT09RQsWLKi/7757sXJlTPWeTtbQ/1wGK91pMr2sgSAI9PX2lkyuqtqZn5e3Yc/evWdVVFQMCPbKsoysrCxs37r1uzt3br+jp6cXHMvi0KFDF/f09OhTu4MAy7HQ6fWvHT16NC/W2UNMq9FKDFggSRJQFNAkCbvNFuu+aowRFscyGDNm9A6bzdbd1dXlsFgsae+JcDiM5cuXP9TW1jbN4XAkS4XSWWQOu3357u3b0d7RDoIgEI1GYbVaMXXqNBDx5oLJYx3JfRlfezm5d2iEgkF4AkFojUaQSeImwGh1OHz48FOJzrmpYleJWOCcM874VXtLE6oPHIhZcyk8C5IkQTM0Zs6Y8d/pEprMFjJI02RGl5CiMHf+fAQCQZLn+VjLC5MJdXW1hj89++yfHnv8iR9ZbVa0tbbi5Vdegc/rxbhx49HU1JgxfuZwONDa1oYH7rsfZ8yZjUUXXay/6fs3fKSAQG5uLkLBIBacv0i59sab8cwTj6fu6S5JYFkWZ5x5Fr76/DNSGMYl1Ov1+N0DD0JvMIDno2mfdDzPo6KiHC2trRCkDC6hNLIxX9FIBCzLEt+78SZIooTOrk5IJImc7Gy0tbSk3GSyLGPy5MnIy8tHZeUEWC2WX9z8gx98r7m52ZqYN5mq9QwA7N69e7rH46mfO+9MLFp0IfbtP0C8+87bGZXuiaJbYoDSPbOsIRQK6cpGjVLmnXnWu19+9dVZZWVlQ9wtk8mEuvr67P37D8w77bTT13X19mLDhg03i6IIi8UypBQnFAqhsKAI02aefmjVypXTQ6FQUjA7+JwVgEhISxKuu0IQkEGgrrEZZrMZBBF7CLlz3FJRcfGaXTt3XpFuZJosyzAYDNi1a9cdgiCgoKAgrbo9Go3CZDLhrHPPXV1eXo683r5k5pgiyXgTvoFtxUeidBeSSvf45Co6lo03mUxgWUfSgstyZKGmpuaMo0ePTs7Ozk7Z74ogCHR0dGBiVdXR8xZduMHv94OkmaElc0pM1uFyutDS3PQvGUL/tnlkSv9Ye5oMlJLMxtEDF14U4XbnoObggR8e3Lv7nCyrFY319TDGxXrKCMe3G41GjB4zGn6fz/nAvfds9/p8zoqKCtitVvi8XnzniivIqVOnIZRBgkAgMdmGGH6qKUGA5VhwGg4sm/rFxf9OkiOsaVNG/haGYaDV6eB2u7Fn7158tWQJtFotrJbY2HONRgOtRguDwQCz2YwJEybAYNBj/759GDVqFE6bOfP948ePp9XaJdr+CIJQmpeXh9mz58Q6TY6gXYsS72mSiGsoIzg5iqIUr9eHqTNmvGMwGNDX1zfkuBJWR1NT0w/Gjh0Dn9fjPHzkyLlms3lIg0KCINDV2Ymp06YuXXTeAvT19eWGQqHM2kLl5EDbWDM/GSazCRarFTq9Hnq9AQajEQaDEfn5Bcvjg18zJiFi/fGtyb7yqdYuEAggJydnW0FBUSdJ09AaDNAaDDCYTNDpdVBkJXlrfRt1yEBxkgIx/sDMd7uQ63Ii15WFAnc2CnNzcHDv7idFUYTdbk9pXcXibF5ceNHin1WUlqCsYhQqJ03ChKoqTKiqwrjKSkyaNg1zTj8N0yZPwnsfvI/Nm77574xhsSwLn8cjR8JhmWbZtOl4geexZvkyjKucIPevsmdZFk6XC08+8cSXu3btmpFfWLQ/NycXhw4eGoF+RgZJUbEpv4HAae+///4nPb292RUVFSgsKACn0YDhOPg9vbZf3Xknuru7UVhQkFbWsG7NqpjSPc159Jc1PPi738XKE9IUSitKzCX801/+gmuuvRaNDQ3pXT2KBD2CJndcfFT9u//4B0KhUEycGRf+KqKI8887D6FIJOZm6HSoravDG2+8gbffeitZ1qHV6tDb03PMbDYjGo2m1BMleoDl5+ebFixYgL8+9xx++rOfASNSulNQ4hkolqLAjaCnO0WSckPtCUNBQWGgsqpqy4G9e09zOBwD4myyLMPlcmHr1q2XHj12DOvXrl3Q3dWFUaNGDenMoCgKWJZFRUXF02vXrYfH42EzPQAJQKEpEhJFQokbgxRJwmTQIxoMIOTzJmNfkYAfeTnu5Xa7HR6PB+nkDYl5kaksuv4kHIlGMXbs2BW+3m4cOdiafH80GoXb7UZubi6ig2pbv53SnUikraHhWDC0FSQZi0/l5ORg165dM7Zu2z7D5XLFLcmhsauuri5UTqg8OOv001aERRG8wA8wGLJtMeX/1ytW4G/PPYevvvwS99xzz39nDEsSRWi0WkKWZUJOk95MpKvLRo8GzXJE/0B1gtlFUdS8+847O89fdOGt06ZO/dBqtQY4jktaWkQ8kJtYxFg/bxKiKGgOHjjwo82bNv2B53mMqqhAaUkJDAZDTHAXm3hLnXf+Iuzdtz+l0DORWi8rr0BvTy+RNk2LuNKdprHg/PNBx6cYp/MJfX4/XG43PF5vxiyhNEiRnA6JwttJU6f2G6QK5Oa4sWbNGvzmN79JapHiwWyUV1SAoul4IzcFBp0OwVAo2XY606ipxDOrpLQMM2bMQCQaRUN9fUYrK+FW9Ve6S8O4u7KigNNqdZFQIFCQn//3bVu2nCaKAmh6YIBcr9ejtaVFs2nz5gXNra3nJQLcgxMIPp8PJaWl3aefdtrap55+GoFAQEon9Owfc0y8YtdZgFanR5bTCZ/PlxwtR5IkLFZri8Vi2dfd3T0xo7wBmRX3sixDq9Fg/PjxqzmtBkaTOelb6/QSdHoDeFE8WeOa+NxI7sv4dZDlk/W7Ot1JS48kSZjNZixbtuyZ/r3VUlpXfj9u+P6N9xYVFqCjuwdkfL9QNI0smxWd3d340Q9/iE8+/jj5maz4XNP/uhiWKEnQaHWkKElEusBvQuk+euw4tHe0E6IoDSEBp9MJlmWZjz/68NXW1ha9zWb9VBAEOhqNNuj1erhcLtAcF+vLI8vweDxZ+fn53EGPp2LpkiV/sFotKC8vR35eXrI9RiJQKMkyLr70Urz00otEKsJKDKEYNXoMdu/alfY8Eseq0WqxaPElMFvM6ZXucbfCbDKhz+OBlOkmH6HSXYxZdMS0maeBJElEIhG4XS7U19Xiiy+/RO2JEwPeP2b0aCxefCkkRUZbaytC4TBGl5ehu7e33O/3p3VnEqrsE3X1nhWr1yIc5fHMM89gybJlxNNPPJFyUyfS6ZKsQOqndBflEZ0bwfOCwrIcrr766o82b9r8QmtrG1tYWDiATBVFgSMrC++89danbW1tdGlpaUrtVW9PDxZddPEHOTk5sNhssY4EGXuEgYj31U8qw3lRgMFoRCAQxKFDh5AIsCcGZTidzuXNzc0T05XpjASBQABut9s7c9bsza7sbOiMluQ5AAT4SCjudpKDSXBYWUP/KgNJlKDRcLBYLMkSpMLCQmzYsGHKhg0bZjmdzrSZwY72dkyZPLnugosu+iwiyiApGrIkw+WwAQA2b96CW2+9FQcPHoDL5QLLsmhqakKmh/7/qEvIMAwCfl9M6Z6maDihdN+8YT1y8/OVVKllQRBgMpkwbcoUdHV2tmzcuPHqtWvWPhEOhxuNRmPHPffe206SpNzW2mr3B4M5Lzz/vHvx4sXP6/T6N0mSREF+AUqKi0FT1IDxWzRNgyJJ5enHH0NLS4tSOWFCSpeQ53ls2fRNTOmeofhZq9WCj0bxp6eezDhjUZEV9PT24o5f/QoLFi5ER1tb+jWMZXSGH/PFcRAEQfnik48RDofhdrtRV1eHP//5z+B5Hm63O7lRenp6kJuXh/Xr1qCnpxvnnHMOKkqLcaTmKNauWvWdTP3eE/MNSQKNTfW1ePPNN7F+/XpYLBbFarVmHFU/WOnOjaywW9HrtIrf50VPd7c/Pz/vswMHDlxREO/K0Z+wOI6D1+PRmkwm6HS6IcF2SZKgNxhwxuxZLzc1NWHHtm1wZWcrvgxZWoKIjfmiSAJy3HUmARCKjMrKCbDbbQM6jTqdTlAUtWzHjh13BeOB7H8GPp8Ps04/falJpxVaGhqS2ihFUZAYVMFQ1BDD4dsq3RUipnA3m00QeCFZavTRRx89AwAulyvZ1ngIqQaDuPzyy+/Qsgxa2juh1+lgsZpR19CI3/32N3j3nXdAkiSKioqGTN36r3QJE6ycqUylf5ZLyaAOlyQJWr0eCuA1GQy+jo4Owm63F0aj0cLPP/8cJIAslys53YdmmEgwEAgbjUZYEmO0Bz1NCSKmEkkIRlPdbES/uM1wRd+J8/X7fJBkacgU5/6ugKevL2EVZWZ/YoQPkPhxBQIBGPR6nDhxAi+88AJkSRpAVoNdcbPZAoZhUTZqDFauXvOXPo/HXlpaisF6p/6f43kec+fM2TN//nysWRObOh7w++EYztTv310mMe14hIp3lmXB81FUTpjw6p49e66IxHtzDd4jhjRTmBMkUFFRcbSoqGjPZ599hob6epjN5owF9oMPOxkfJUjY7Xa0tbYOkJ0Eg0GUlZVtttvt/u7ubmPCOvk2VhZBEGBZBhabY932XbvR3taWnK0ZjfIwmYyYffppYOJVAN/WkEiufeK3NDoQNAtZlFFUUoK1q1dPWrly5VyHw4FUx5/QXU2aNKl2wYIFn3V2dkLPMbCYDHjllZfxm9/8Fl1dXcjKykp2Ij6lcql/t6yBoChCGEbpPnf+fHR2dmYcVd/V0YHzFi2iGI1G2Lh+fWxQq9OJs88661h3d7ezvb3dbLVakZ+biwkTKoWqSZOlxx55OGnqprLcRFkm7vv9w9i5a3fKnu5CXOl+xrwz8X5rG5FJ1hAOhWA0m/Hb+x8YpvhZgSTJsFmtaGltTWZp0skaRqJ056NR0AxDXH311Wjv6sKVl1+OUCiE7OzsDCY4iezsbKxYsQLP/PFPPz64f99P7XY7bDZbWlfG6/WirKy8fcKkyUcCPI/bbv8lbrjh+1i9dh3xx2eeRkIOMcQVAWIK64SsQZTAixKE4ZsTEoFgkLDZ7Jg0ZRoqJ09ZvmHjxt7GhgbbqNGj0wouU6Xf+3p7cd31179fUlKCijFjQVJUrNNB5n0+QOme/D6ahsfnw+Gao7DZbCdznooCp8sVLSgoXHvo0MGLioqKvjVhCQIPnU6PM848a9e48WORW1g0IKZHkUTMpROGlp5Jw7qEIARRQuwlgKEZ2G02MCwLLcfBaDDgjTdefxqI1d0mrKvBv+PzenHJZZc/Hjv3GH70ox/jhReeB8dxSavqX3X//qMuIUlRiEYjihjvrJjye+JK96b6BlA0jUwtiLVaLRrq69Ha2kpxHIvZc+YsqSgvu6+iYtTuYChkWb9+/Y9379r1SDjWEys6fdp09tGHH0K6gD9JkiAJQtn8zTfw+XyKKcUAhcQA1uamRkhSZqU7zTCQRBFbN28CF6vnS2uaB0NBnH322XC5xsGX4Qmf6Cc+rBWiKIiEw6Fx48Yhum8fenp64HQ6U26YRAcGlysL3d3d5vb29vsP7t93u16vR6ISP5U7SJIk/H4/iouL3sx2OZVINIoVy5fj4P596O7pVdIFrxNeW3+le/+2w8M9G0mChFarwZEth0FRNPILCv6xft26X5Sn0TqlIgdRFGG2WOTKCZUv+7xeHK6ujncooJVh9rmSNAb7HarI8ygpLsHkadMGZPwAwO3ORtWUKau2bt1ykSgIYLlvN9LK0+fBuHHjDsyaffouhiSSnREAgKAoiDwPf18vgKFhByJjPWzshBJrLwoCrBYLHDYrItEoSoqLsXz58vErli8/KzEKLl1mcOy4cY3fu/aavwNAXUMDfvnLX+LTjz+G0+mERqM55VbVf8QlpGkaoWBQjobDMjWM0n3frp0YP3FiRiW5yWTC/r17caS6uqSqalJjeUXFIkJR0NvbC4IkPecuWPBoZ2fn+hXLl69oa2lxvFH9mti/x3mq4yNJEv947RUEAoGUU08okoQgCNi/dw9EPrPSndNoEI1E8PYbb4Dn+WFlDeWlpTjjjDNiLaDTreEIY1g6nQ6iIJS8+uqrd65fv0FiWVaS0sx+SnQO5Xl+4u7duxf5fD6H3W5HYmx9ugaN0WgUFqsFs2bP/mt7ayt27NiB++75XfLvmZTuBAYq3eNdKDIq3U/uEULRajiQioKG2hMYP27c65s3bfpFIBAYUYwoYV1VTZ582GZ3NB46ehwb1q1NjKQbvhNGvNpA7nduBACdRgN7PG7Xn7A4msb0aVO/flOniw1ZdTpHbGURBIEoz6OgoGClGI2gNxCE1G+4rqIADE3HYlBKqgcchiVgmiRBEQQIRUFxURFy8/IQjUZBkCT+9vzzT8VI151MWgz2rPx+P2668cZf+vx+3PfAA/jH66+jr7c3ef3lf3P/tn+zS2gmAxQ1rNL9jLPPRigcJgUhvUvY2dmJc887DxJB6KLRCJ9fUAiaouBw2BEOh9HS0gKn07kpKyvrreN1dRU2mz1jM4REr/ff3f8gbr7x+0g75otlMXvuPCz98ktyOJdQp9Ph7nvuhV6vH6KR6b960SiPUWPHorWtbVil+0hcQoPBAH8gkHPHHXc8GQgEktZVqpib1WpFQ0MDjhw5ApPJhMLCQthsNhgMhmTMaMhNS1E4cfw4Lr38OzsWX3xxQ1SSQbIc7nvgQVjNJuzeu5f4+MMPT7nSHQAhiBIRjkRRWl4Oo8kEs9myb8WKFUfr6+srKisrR0QGPr8PZ50z/+1JE2OJlcKiYhw9dhQsyw3rEkqDlO6xTKEEiqER8PsQCgXBMCf1eX29vbBZLMdLysqOtba0lDu+RRo/EVQ/bdbs5VqOQ8AfAEEObPMtSyKkNF7OiJXusgySptHZ2ZlMau3du3fsV199tdBmsyWtq8EWem93Ny5YtOjQ2QsWfjTr9NNx8OBBmEwmFBUV9Z/cM8wDiDy1hHWqEBOqkbGAYQalOwFAo9EiHIlmVOxKkgSdXg+NRhPw9vUVkSSB/MICOB0O0CwLp9OJsWPHYtOmTWPb29t7J0yoJDPu47hEOFEtn/LJEA+0x6rkM98YieSC2WKG0WhCJBpJuzCCKIBhmFgLnAz0r2BkMmZRjLmrVVVVEAQh1t10mM+RJAmapsGybLI8JF0tXV9fHywWi3DjzTdfCgCyGOuKkeV0wuWw43ht3bBPVmWQyl1RMOJq/mg0Cp1ej8KycpQVF+O8Cxa98cRjjz4iSdKw0oFwOAx3tluYNGnSswDQ7fWhqakxbpWKIyCRoWpySY61pjGZzVAIAlw/4lMUBbm5uSgvL1+2f+/e8m8jb4h3Fw2Xjxq9QVEUEDQzoBSFIEmIfASiIAAE+U/flzRFA6yCd959Nxk+WLd27SOKosDtdqfNDOp0OgQCAdvPb7ttaU1NDWW1WhmapuVgmkabKVx1LhqNPgXgi/+6GBbLsvB5++RIKKxkUrpHeB6rly/D2PHjB4yqHwy3240vPvkER44dCzEMQ7e3tWHhggXJv5uNRjz77LPjNm/ZMvvCCxc988F778oZXUKGAUVR+O3dd6GjowO5kyaldBuj0SjWrV4FPhJRMird9XpEIhE88NvfZlS6y4qM9rZ2PPf88/ju1Vejq6sr7Xdm2WzoMJvTxmZSrSdN00jXOSHdRkpHVrGyFx7tbW148MEHL58wdkxzXzgCq1aDO2+/HR9+8H7ya3JyckasdOcoChxNgaWoYWUNNEUqHMMgQpE4VF2NhuPHkOvO/ofJZHrE4/Ek3dh0x+/z+TB9+vQvhEg4ePDgQWzYuBE1hw+joLAQHR0dw+3zIUr3RACb4zQQo1G0NDQMiDPF0hkKykpKlnEazc8ikUjaIaupkhqzZ89er+OYyN69e5N94k4+vAB3Tg60Gg3EFPHJkSrdKQ2HjvY+MDSNkqIihMLhrK6ursUJ64pM08vKaDKh5vBhd3tHu7uoqChjV910YRhRFL8+pYR1qiBJEjhOQ0iSnDbwrcSfPkUlJZnV4fGUffmoUQiEw56uzk40NDS8/rvf/rbb5/PROr1B5Pko8eILL9wIAHn5Bb1Go0mujQ+ASJculxUFc886Czt270Y0Gk35HoqiUFhUhO7u7rTnkXAxKZrGnHnzQKWz2OKP7IDfD41Ggx3bt8ObQQdks9lw6NAhJRqNIl0HgFQB5xGPscrwPoIgIIoimhob8J0rrnz0yquu+sLr80Gn0+NEYxNqao5g4sSJsFgs6OnpQUtLyzBK95hgkSBOqq0lefjjlOOCU0GUoIkrrufMmdN8+umnb9q0adOsVH2y+p+fLMuYO2/eG/l5eYhEImhqbIxLXEa2jwcLRxN3vwLAmZ2NUHxS8oA4oU6H6TNmrDeZzUJXZyejLy4e1nVNuFKFhYVf9vb0oK29fYB7xfM8jEYj8gsLY0r1FN81UqV7KByGTq/HrNmz4bDbsXffvtGBQAB5eXkpY1f997hWp0NRUXHa7HsmaLVaGAwG739lDEsURWj1elKSlbQKcTmudB8/sQpt7e1EpuxCX18fLrr0MkKUlfDnn3yMN1577fqOzs4Bhct5ublgaBoV5eVMQVGxsnLFirSLGm/pSlx59TV44403iFRDKKR4w8CxEyZg3759GZXu0WgUZrMZl1/1XVgslvQF1YoCDUOjubUNb771FrQZrKH4mLJuq9UaikajupHEa5RTMADuJFk14oqrvvuPJ594/HcRUYa/rw86HYFgIIhf3nUXHI4s2ExGLPl6GfHEY49mVLqLsgxJkQEQEGUFgqxAUoaXNciKTAiCCJ1OD48/gBO1dfBHorDYHa9Eo9FZgiCkbYDn9/vhdDq98845Z6kzOxsEAE6rRSQcgazIGZXhiYjA4NKcfvEiaDSaWF0qyw24KwRBQFl5RXDatGlffb106SVFIyCscDgMg8GACxZf8vHEcWPR6/MPWUhZksCHQxBlJU3DweGV7qKsQBBEUDQFk9EIg8kMrVanJUkyNoZ+BIHzxJzNxF4Z6Z7T63WQZJk6pYR1SpXuvpEp3bd+sxHZOTlKpjFaWVlZWL1iuVJ95AhlsVpRUlyMqqoqRCKRmOkcd/8CgQA0HCcZdVpuOPOUIknl2T88g9bWVmXC+PEpCYPneezYunVESvdoNIq//vlPGddHQUzHMmv2bJx//vno31F1aNaHgCs7O7BmzZpPt23bes2YMWNOtlf+N4EkSXi9XnR1deGKyy9/5MknHr9HjLsrJqMBBEXith//CFu2bE42PRRFUbFYLCNWujMUCZYaUQZUoUhSoSkSJE2BoUgEfR60NjZg2uRJ725cu+b51tZWrqioKOXIqZ6eHsyfP/8Vs94g1Tc2gaZI1NfVwWwxJyQWmbNqKZTuyQOTJNhtNoTjD7r+11BRFFgtZlx04YWPf/Xll5f4/f4hbuNgV767uxvTp019W6/hOuoaGxEdNBRFlGJjuAxaDQaXsPXbLyNSuuu0GgQCAVTX1sJgMKCttaVmuKnmqcII397rkjN6Kf+jLmEsPS5lVroTsTxswO+DImdnzDAwDAOv14tQKASapuOKYDbZoynRQT4ajSISicDn92kyZSQSSvfWuCuT6YKJojgsSSea/bW3tsY0W+mCogQQCATxzYYNKCsvB03TSCeYFRUFPp8PP/nJT37d0dFxTVNTE/Ly80/JhOdU6yFJEpqbm2GzWv0333zzraefftq7oqyg1xdrM63XcPjDn5/F+vXrAACt/QZoZGdnD/uQS4jcE/qykbS0T2igeEFARXk5+EgEFEkiLz8/MmvWrIc/+PDDhwoLCwfEXUiShNfng16vl6684opHOYaCw2LGoUOHcPzoURiNxmGvZ7yygeJYNp58GXq99TodjEYjIpHIkP3j8Xhw5ZVXbv/kk48/W7Zs+eJzzz036aIOTWr0Qq/X4/rv33g3H4mis7FpEPkr4AURbF4uLPHi/X/WkCAIApIogqYpTJgwHgzD4swzz2zYsGHDys2bN88vKioaUdLmfwr0P+NSjOSGEQQeBqOZVECknecniyJoksS8+QvQ2ZVZ6d7W1obvXvc94ptN32DZkiUoLCiIzYsbdPH4aBRanY7S6PQZZQiCIEBSFPr3jz2Ovfv3E+lKNAiAUEAMKy8IBYMwmkzEvb9/CCazGZFIOAMBSmA5FlMnTYLI84hEo2nJmmEYmM3m5uUrVlz86SeffK7T6fDPlHykuSEhiiIikQgikQgYhsHFl1zy+uWXXXZvKBhs7uzoQDAYjLVYjj/VJ1ZV4ZXX34DJbIYsy3BYzFi+chXxpz88k1npLsd7uisEoqKE6AiV7oIoE4Iowx8IguU0qJw0GZIkwWq14jf33vfwoerD1xw4sH90ZeXE5E0eCATQ3dWF39177x2VVVU9za1tyHdn41htHZqaW1BaVgopNg4so9KSIIgISVEgGRbk4LcqCiiaRFlFBQI+HwRBGEAysizDZDLhL8/97cpLL7t034H9+0eXlZcPGDihKAq6u7vh8Xjw1DN/uG7+Oee09PqDcBcUpvBGSPChIALB4ACpwyA3dTiXkORFEVFRRCTCo2JUDnLcbhgMBjzyyCPXfv/GG6trjhyxF5cU/1s0VQRBQJIV8pQS1kjk9IqiQJbkIomUkuN9hpycrEAUeIMsyULi74lX/+CwJIpoa2kGQVF0MhguSZAHkaJGo0Fd7Ql9e1ubLTHEMdXvKjEyssuiSCP+REv8ZvL7FAWyJMFsMmH/gQPwerwuQ64+aa4mvjPehsMZ6+lN6JK/meL44hZW8Z5du6DRaCCIQkZrrK+3D9s3b8aVV14JQRTTmsosyyIQCECr030xddq0mVCUP/u83hkUTcNkMmUc0ZUpuBsKhZAI5judrsOjRlV8QQCvXXPd9TWjykvx7tvvQKeNjU+HosBmMuDt9z/AP15/DSUlJck10mk0qDl61BRr60Ok9IFJgihlaAaSKIEgACrW5wsUSWmGi9PSFEXSFAWapkASAMNpQIKALxhBQXEZ/vK350+/7Sc/+qyxseEMlysb0WgU0WgUl1922S9vuvHGZyOiDL3RBIUgcKK2FgxD918HZ7ofdjgcaGhotN9w003xJn5Db96enl5MmTwJd991J2RZHqLw7unuRkFhEX/PffdPee6Pz7wcCAS+CwB2ux2hUAgejwf5+fnVt9xyy53zF563lFcAWU6hnyMISAIPKUGKRFor1popFkEQRCHLMBAZFpIgorOjA1l2O7o6OzFv3rzOhx5+ZNLvH7j/zb4+71yOY5OtmE4ZFAUURVpPKWGNpF9NbFgE9zdFwUSD0dij1WolQRDI/sOy9GYzRwBbSSii0WR6RWcw9On0ekGUJEJJthmRCT4aJZqbmlBWVua1Wq1/1+r1IZ3BEJRlmZDkZJsxmK1W7tjRo4c6Ozp6XC7XK1q9vlen04miJBEDftdo5CiS/AqK0mQ0m/+uNRh8Or2el2WZkPs9UrNZll26dOnujz76CCzHPuXIyjLojUYPGZumS8Q7jVIand5nsVjhdDiOGAyGV3V6vVdnNIYlUSQkRTk5EIkkKUkUe1evWE5KkiQPJ5CLRMJgOQ1mzJiBsePGoa/fQI1U4KM8jEbjtsrx42cyHLfw+PHjsw4fOuTQ6fUCQRAKMcKRYZIkEbIsEzNmzuw1m811LE0fLKsYtUer1UonjtagpbkZdqt5QE96iqZB0xTeePVVrFyxPNXXHszOzn5TkqSAJEm8LMtEgkQFUWRlSWpiaApS/DtpkgRNUaApshHAPyRJioiiGFYUJfk5URQpSZLCLMsEOJaBwLKxDKMCCLwIBYjNBDSZ+s4+++y57e1tV7S0tJ7pdDq7zlu48JOc3Jy9fR4vFJKCXqdDU2s7Nm/cALvd1r/+eoWiKGZJkvyiKAr9f59mGM7j6Tt05HD1EDV7MlAeCWPXju0468wzMWfOHHR2dg55MLW3t0ESxdDFixdfTTPss0drjs7e9M3GiopRo3p+8INbdnMc+0lxcbHU3t6G/DTuPkGQkHgBBBSQFJVWm0eS5DYAb4qi6JckSRh0HThFUWpYhoHA0DAY9PD5fOjzemG32dAem6TUNGv27Hlmk/nc5uameXV1dVZ9fH+dCr4SRFFDU+Saf8lK+2/1VVWoUKFiCCmrS6BChQqVsFSoUKFCJSwVKlSohKVChQoVKmGpUKFChUpYKlSoUAlLhQoVKlTCUqFChQqVsFSoUKESlgoVKlSohKVChQoVKmGpUKFCJSwVKlSoUAlLhQoVKlTCUqFChUpYKlSoUKESlgoVKlSohKVChQqVsFSoUKFCJSwVKlSoUAlLhQoVKmGpUKFChUpYKlSoUKESlgoVKlTCUqFChQqVsFSoUKFCJSwVKlSohKVChQoVKmGpUKHi/3f8vwEAfLHx/CRDr9YAAAAASUVORK5CYII=",
            M = f, V = G + U + M + K + O, d = $(j + n[N2I7u.y8K]);
        d[P](V);
    }
    function p4(P) {
        var j = "render";
        if (S4[j3][N2I7u.m5d]()) {
            j0[j]();
            requestAnimationFrame(p4);
            TWEEN[N2I7u.W6d](P);
            S4[j3][N2I7u.g9d]();
        } else {
            requestAnimationFrame(p4);
        }
    }
    console[Y3](O3, BIMVIZ[S3]);
    var S4 = this;
    n = n || {};
    this[K3] = n[m0];
    this[A4] = z3 + n[r0] + e4 + n[b0];
    this[i0] = R0 + n[r0] + e4 + (n[b0]);
    this[n0] = N2I7u.v3d;
    this[F0] = S4[A4] + M0;
    var c1 = n[d0] + K0 + n[m0];
    $[t0]({
        cache: N2I7u.z6d,
        url: S4[A4] + V0,
        type: V4,
        async: N2I7u.z6d,
        data: {grant_type: r4, username: k4, password: c1},
        dataType: q4,
        success: function (P) {
            var j = "token", O = "/scene", K = 'S1', U = "X6u", G = "access_token";
            S4[n0] = P[G];
            if (N2I7u[U](S4[n0][N2I7u.o5d](K), N2I7u.K1d)) {
                S4[i0] = R0 + n[r0] + e4 + (n[b0]) + O;
            }
            if (n[N2I7u.z2d]) {
                console[Y3](j, S4[n0]);
            }
        },
        error: function (P, j, O) {
            var K = " is allowed by your Firewall software in Server.", U = "4. Please check if the port:",
                G = "3. Please check if the ProjectId is valid.",
                f = "2. Please check if the Dev Key in your init code is valid, Or open the admin page to check if the user is valid",
                M = "1. Please check if the RestServer is runnig.",
                V = "Error:Authorization is not finished. Please check following list:";
            console[Y3](V);
            console[Y3](M);
            console[Y3](f);
            console[Y3](G);
            console[Y3](U + n[b0] + K);
        }
    });
    this[d4] = {Authorization: C4 + S4[n0]};
    this[j3] = new BIMVIZ[N2I7u.p6d](n);
    this[d0] = n[d0];
    this[k0] = N2I7u.f2d;
    this[u0] = new BIMVIZ[u0]();
    this[F4] = n[N2I7u.y8K];
    this[G0] = n[x0];
    this[v0] = new THREE[N2I7u.y7d]();
    this[v4] = {
        transparentMode: G4,
        colorMode: M4,
        systable: {
            "IFCSLAB": [-N2I7u.W1d, -N2I7u.W1d, -N2I7u.W1d, i4],
            "IFCWALL": [-N2I7u.W1d, -N2I7u.W1d, -N2I7u.W1d, i4],
            "IFCWALLSTANDARDCASE": [-N2I7u.W1d, -N2I7u.W1d, -N2I7u.W1d, i4]
        }
    };
    var s0, j0, h0, N0 = S4[i0], l0 = x3(), V3 = t3(), r1 = N2I7u.f2d, I0, h4 = new BIMVIZ[N2I7u.F7d]();
    this[m4] = function () {
        return h4;
    };
    this[T4] = function (P, j) {
        S4[u0][T4](P, j);
    };
    this[l3] = function (P, j) {
        S4[u0][l3](P, j);
    };
    this[w4] = function () {
        var P = "OnConnectServer", j = "OverviewLoaded", O = "SYS_EVENT";
        S4[u0][T4](BIMVIZ[O][j], T0);
        S4[u0][l3](BIMVIZ[u4][P], N2I7u.v3d);
        v3();
        p4();
    };
    this[l4] = function (P, j) {
        j0[l4](P, j);
        S4[N2I7u.O1d]();
    };
    this[N2I7u.p5d] = function (P, j) {
        h4[N2I7u.g5d]();
        I0[N2I7u.p5d](P, j);
        h4[N2I7u.p5d](P, j);
        S4[N2I7u.O1d]();
    };
    this[B4] = function (P, j) {
        h4[N2I7u.g5d]();
        I0[B4](h4, P, j);
        h4[N2I7u.Y5d](P, j);
        S4[N2I7u.O1d]();
    };
    this[b4] = function (P, j) {
        I0[b4](P, j);
        S4[N2I7u.O1d]();
    };
    this[s4] = function (P) {
        I0[s4](P);
        S4[N2I7u.O1d]();
    };
    this[f4] = function (P) {
        var j = "onSelectElementById";
        r1[j](P);
        S4[N2I7u.O1d]();
    };
    this[J4] = function (K, U) {
        var G = 'Project/CreateMarker', f = K[O4]();
        f[n4] = S4[d0];
        var M = $[t0]({
            url: S4[F0] + G, type: V4, headers: S4[d4], data: f, error: function (P, j, O) {
                alert(O);
            }, success: function (P) {
                var j = "addMarkerToScene";
                s0[j](K);
                U();
                S4[N2I7u.O1d]();
            }
        });
    };
    this[K4] = function (P) {
        s0[K4](P);
        S4[N2I7u.O1d]();
    };
    this[U4] = function (K, U) {
        var G = 'Project/DeleteMarker', f = $[t0]({
            url: S4[F0] + G,
            type: x4,
            headers: S4[d4],
            data: {projId: S4[d0], id: K},
            error: function (P, j, O) {
                alert(O);
            },
            success: function (P) {
                s0[U4](K);
                U();
                S4[N2I7u.O1d]();
            }
        });
    };
    this[R4] = function (K, U) {
        var G = 'Project/SaveMarker', f = K[O4]();
        f[n4] = S4[d0];
        var M = $[t0]({
            url: S4[F0] + G, type: V4, headers: S4[d4], data: f, error: function (P, j, O) {
                alert(O);
            }, success: function (P) {
                s0[R4](K);
                U();
                S4[N2I7u.O1d]();
            }
        });
    };
    this[N2I7u.q7d] = function (P, j) {
        r1[N2I7u.q7d](P, j);
    };
    this[w8] = function (P) {
        s0[w8](P);
        S4[N2I7u.O1d]();
    };
    this[u8] = function (P, j) {
        s0[u8](P, j);
        S4[N2I7u.O1d]();
    };
    this[C8] = function (P, j) {
        h4[N2I7u.g5d]();
        h4[N2I7u.c6d](P, j);
        I0[C8](h4, P, j);
        S4[N2I7u.O1d]();
    };
    this[A8] = function (P) {
        var j = "E2u", O = "R2u", K = j0[B8];
        if (N2I7u[O](K, undefined) || N2I7u[j](K, N2I7u.f2d))return;
        h4[N2I7u.m2d](K, P);
        I0[N2I7u.m2d](h4, K, P);
        j0[Y8]();
        S4[N2I7u.O1d]();
    };
    this[j4] = function (P) {
        var j = "O2u", O = "x2u", K = j0[B8];
        if (N2I7u[O](K, undefined) || N2I7u[j](K, N2I7u.f2d))return;
        h4[N2I7u.K5d]([K]);
        I0[N2I7u.K5d](h4, K, P);
        j0[Y8]();
        S4[N2I7u.O1d]();
    };
    this[t4] = function () {
        I0[t4](h4);
        h4[N2I7u.g5d]();
        j0[Y8]();
        S4[N2I7u.O1d]();
    };
    this[k8] = function (P) {
        return j0[k8](P);
    };
    this[c8] = function (P, j, O) {
        if (O) {
            j0[c8](P, j, O);
        } else {
            j0[c8](P, j, function () {
            });
        }
        S4[N2I7u.O1d]();
    };
    this[S8] = function (P, j) {
        s0[S8](P, j);
    };
    this[e8] = function (P) {
        j0[e8](P);
    };
    this[T8] = function () {
        return j0[T8]();
    };
    this[o8] = function (P) {
        j0[o8](P);
    };
    this[X8] = function (K, U) {
        var G = '', f = $[t0]({
            url: S4[F0] + N8,
            type: x4,
            headers: S4[d4],
            data: {projId: S4[d0], text: K, mode: G},
            error: function (P, j, O) {
                alert(L8 + O);
            },
            success: function (P) {
                U(P, K);
            }
        });
    };
    this[q8] = function (K, U) {
        var G = 'adv', f = $[t0]({
            url: S4[F0] + N8,
            type: x4,
            headers: S4[d4],
            data: {projId: S4[d0], text: K, mode: G},
            error: function (P, j, O) {
                alert(L8 + O);
            },
            success: function (P) {
                U(P, K);
            }
        });
    };
    this[n8] = function (P) {
        j0[n8](P);
    };
    this[D8] = function () {
        var P = "revertMouseMode";
        j0[P]();
    };
    this[F8] = function (P) {
        S4[j3][N2I7u.s7d](P);
    };
    this[J8] = function (P) {
        S4[j3][N2I7u.y5d](P);
    };
    this[U8] = function (P) {
        S4[j3][N2I7u.d9d](P);
    };
    this[P8] = function (P) {
        S4[j3][N2I7u.z9d](P);
    };
    this[N2I7u.O1d] = function (P) {
        S4[j3][N2I7u.O1d](P);
    };
    this[r8] = function () {
        j0[Y8]();
        S4[N2I7u.O1d]();
    };
    this[x8] = function (P) {
        j0[x8](P);
    };
    this[z8] = function () {
        return j0[z8]();
    };
    this[Q8] = function (P) {
        var j = "gid2bid";
        return s0[j](P);
    };
    this[f8] = function (P) {
        var j = "bid2gid";
        return s0[j](P);
    };
    this[W8] = function (P, j, O, K, U) {
        j0[W8](P, j, O, K, U);
    };
    this[E8] = function () {
        I0[E8]();
    };
    this[O8] = function (P, j) {
        h4[N2I7u.m2d](P, j);
        I0[N2I7u.m2d](h4, P, j);
        S4[N2I7u.O1d]();
    };
    try {
        r1 = new BIMVIZ[H8]({
            socketServer: N0,
            workerJsUrl: l0,
            workerDebugJsUrl: V3,
            username: n[u],
            debug: n[N2I7u.z2d] || N2I7u.z6d,
        }, this);
        h0 = new StatStatus(this, n);
        j0 = new BIMVIZ[R8](n, this);
    } catch (P) {
    }
    ;
    if (N2I7u[B](n[C], e)) {
        function R3() {
            var P = "innerHeight", j = "innerWidth", O = window[j], K = window[P];
            S4[l4](O, K);
            S4[N2I7u.O1d]();
        };
        window[I](o, R3, N2I7u.z6d);
        R3();
    }
    if (n[k]) {
        if (n[k][S]) {
            S4[v4][S] = n[k][S];
        }
        if (n[k][m]) {
            S4[v4][m] = n[k][m];
        }
        if (n[k][i]) {
            S4[v4][i] = n[k][i];
        }
    }
    if (N2I7u[D](n[F], N2I7u.z6d)) {
        r3();
    }
};
BIMVIZ[N2I7u.b2d] = {
    GetPositionFromServerBoxDefine: function (P, j) {
        var O = "q47", K = "J47", U = "F47", G = "BackCenter", f = "n47", M = "r47", V = "f47", d = "FrontCetner",
            n = "U47", F = "O47", D = "x47", i = "RightCetner", m = "E47", S = "R47", k = "u87", o = "LeftCetner",
            I = "C87", e = "w87", C = "o87", B = "BottomCenter", R8 = "X87", u = "N87", H8 = "Z87", O8 = "TopCenter",
            E8 = "c87", W8 = "D87", f8 = "Y87", Q8 = "BottomBackCenter", z8 = "L87", x8 = "z87", r8 = "Q87",
            P8 = "BottomBackLeft", U8 = "W87", J8 = "y87", F8 = "P87", D8 = "BottomBackRight", n8 = "H87", q8 = "g5u",
            L8 = "I5u", N8 = "BottomFrontCenter", X8 = "a5u", o8 = "v5u", T8 = "h5u", e8 = "BottomFrontLeft",
            S8 = "l5u", c8 = "p5u", k8 = "m5u", t4 = "BottomFrontRight", j4 = "i5u", Y8 = "d5u", B8 = "V5u",
            A8 = "TopBackCenter", C8 = "M5u", u8 = "G5u", w8 = "K5u", R4 = "TopBackLeft", x4 = "b5u", U4 = "j5u",
            K4 = "s5u", n4 = "TopBackRight", O4 = "t5u", J4 = "A2u", f4 = "T2u", s4 = "TopFrontCenter", b4 = "e2u",
            B4 = "B2u", l4 = "k2u", w4 = "TopFrontLeft", T4 = "S2u", m4 = 0.0, i4 = "q2u", M4 = 1.0, G4 = "J2u",
            v4 = "TopFrontRight", x0 = "SizeZ", G0 = "F2u", F4 = "SizeY", C4 = "n2u", d4 = 0.5, q4 = "SizeX",
            k4 = "r2u", r4 = "BoxCenter", V4 = "BoxPosition";
        switch (j) {
            case BIMVIZ[V4][r4]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[k4](P[q4], d4), P[N2I7u.w6d] + N2I7u[C4](P[F4], d4), P[N2I7u.d6d] + N2I7u[G0](P[x0], d4));
            case BIMVIZ[V4][v4]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[G4](P[q4], M4), P[N2I7u.w6d] + N2I7u[i4](P[F4], m4), P[N2I7u.d6d] + N2I7u[T4](P[x0], M4));
            case BIMVIZ[V4][w4]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[l4](P[q4], m4), P[N2I7u.w6d] + N2I7u[B4](P[F4], m4), P[N2I7u.d6d] + N2I7u[b4](P[x0], M4));
            case BIMVIZ[V4][s4]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[f4](P[q4], d4), P[N2I7u.w6d] + N2I7u[J4](P[F4], m4), P[N2I7u.d6d] + N2I7u[O4](P[x0], M4));
            case BIMVIZ[V4][n4]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[K4](P[q4], M4), P[N2I7u.w6d] + N2I7u[U4](P[F4], M4), P[N2I7u.d6d] + N2I7u[x4](P[x0], M4));
            case BIMVIZ[V4][R4]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[w8](P[q4], m4), P[N2I7u.w6d] + N2I7u[u8](P[F4], M4), P[N2I7u.d6d] + N2I7u[C8](P[x0], M4));
            case BIMVIZ[V4][A8]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[B8](P[q4], d4), P[N2I7u.w6d] + N2I7u[Y8](P[F4], M4), P[N2I7u.d6d] + N2I7u[j4](P[x0], M4));
            case BIMVIZ[V4][t4]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[k8](P[q4], M4), P[N2I7u.w6d] + N2I7u[c8](P[F4], m4), P[N2I7u.d6d] + N2I7u[S8](P[x0], m4));
            case BIMVIZ[V4][e8]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[T8](P[q4], m4), P[N2I7u.w6d] + N2I7u[o8](P[F4], m4), P[N2I7u.d6d] + N2I7u[X8](P[x0], m4));
            case BIMVIZ[V4][N8]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[L8](P[q4], d4), P[N2I7u.w6d] + N2I7u[q8](P[F4], m4), P[N2I7u.d6d] + N2I7u[n8](P[x0], m4));
            case BIMVIZ[V4][D8]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[F8](P[q4], M4), P[N2I7u.w6d] + N2I7u[J8](P[F4], M4), P[N2I7u.d6d] + N2I7u[U8](P[x0], m4));
            case BIMVIZ[V4][P8]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[r8](P[q4], m4), P[N2I7u.w6d] + N2I7u[x8](P[F4], M4), P[N2I7u.d6d] + N2I7u[z8](P[x0], m4));
            case BIMVIZ[V4][Q8]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[f8](P[q4], d4), P[N2I7u.w6d] + N2I7u[W8](P[F4], M4), P[N2I7u.d6d] + N2I7u[E8](P[x0], m4));
            case BIMVIZ[V4][O8]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[H8](P[q4], d4), P[N2I7u.w6d] + N2I7u[u](P[F4], d4), P[N2I7u.d6d] + N2I7u[R8](P[x0], M4));
            case BIMVIZ[V4][B]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[C](P[q4], d4), P[N2I7u.w6d] + N2I7u[e](P[F4], d4), P[N2I7u.d6d] + N2I7u[I](P[x0], m4));
            case BIMVIZ[V4][o]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[k](P[q4], m4), P[N2I7u.w6d] + N2I7u[S](P[F4], d4), P[N2I7u.d6d] + N2I7u[m](P[x0], d4));
            case BIMVIZ[V4][i]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[D](P[q4], M4), P[N2I7u.w6d] + N2I7u[F](P[F4], d4), P[N2I7u.d6d] + N2I7u[n](P[x0], d4));
            case BIMVIZ[V4][d]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[V](P[q4], d4), P[N2I7u.w6d] + N2I7u[M](P[F4], m4), P[N2I7u.d6d] + N2I7u[f](P[x0], d4));
            case BIMVIZ[V4][G]:
                return new THREE[N2I7u.y7d](P[N2I7u.w5d] + N2I7u[U](P[q4], d4), P[N2I7u.w6d] + N2I7u[K](P[F4], M4), P[N2I7u.d6d] + N2I7u[O](P[x0], d4));
        }
        ;
        return N2I7u.f2d;
    },
};
var Z4X72 = {
    'i52': function (H, P) {
        return H == P;
    }, 'j52': function (H, P) {
        return H == P;
    }, 'O9U': false, 'A22': function (H, P) {
        return H == P;
    }, 'X8W': function (H, P) {
        return H / P;
    }, 'A62': function (H, P) {
        return H < P;
    }, 'k62': function (H, P) {
        return H * P;
    }, 'z92': function (H, P) {
        return H - P;
    }, 't52': function (H, P) {
        return H == P;
    }, 'C5i': 0, 'W92': function (H, P) {
        return H != P;
    }, 'y4W': function (H, P) {
        return H * P;
    }, 'd8W': function (H, P, j) {
        return H * P * j;
    }, 'g52': function (H, P) {
        return H * P;
    }, 'w8W': function (H, P) {
        return H / P;
    }, 'O62': function (H, P) {
        return H != P;
    }, 'f62': function (H, P) {
        return H == P;
    }, 'V4W': function (H, P, j) {
        return H * P / j;
    }, 'b52': function (H, P) {
        return H != P;
    }, 'I52': function (H, P) {
        return H != P;
    }, 'B62': function (H, P) {
        return H * P;
    }, 'H92': function (H, P) {
        return H !== P;
    }, 'P8W': function (H, P) {
        return H * P;
    }, 'V52': function (H, P) {
        return H < P;
    }, 'D22': function (H, P) {
        return H < P;
    }, 'Z8W': function (H, P) {
        return H * P;
    }, 'L92': function (H, P) {
        return H / P;
    }, 'a52': function (H, P) {
        return H == P;
    }, 'p52': function (H, P) {
        return H == P;
    }, 'Z92': function (H, P) {
        return H == P;
    }, 'R62': function (H, P) {
        return H * P;
    }, 'J8W': function (H, P, j) {
        return H * P * j;
    }, 'I72': function (H, P) {
        return H === P;
    }, 'n62': function (H, P) {
        return H < P;
    }, 'Z4W': function (H, P) {
        return H != P;
    }, 'Y22': function (H, P) {
        return H < P;
    }, 'c4W': function (H, P) {
        return H == P;
    }, 'K52': function (H, P) {
        return H == P;
    }, 's52': function (H, P) {
        return H == P;
    }, 'U62': function (H, P) {
        return H == P;
    }, 'R4W': function (H, P, j) {
        return H / P * j;
    }, 'F4W': function (H, P, j) {
        return H / P * j;
    }, 'L8M': (function (J8M) {
        return (function (N8M, p8M) {
            return (function (l8M) {
                return {V8M: l8M, X8M: l8M,};
            })(function (Y8M) {
                var q8M, d8M = 0;
                for (var S8M = N8M; d8M < Y8M["length"]; d8M++) {
                    var Z8M = p8M(Y8M, d8M);
                    q8M = d8M === 0 ? Z8M : q8M ^ Z8M;
                }
                return q8M ? S8M : !S8M;
            });
        })((function (c8M, D8M, F8M, m8M) {
            var i8M = 26;
            return c8M(J8M, i8M) - m8M(D8M, F8M) > i8M;
        })(parseInt, Date, (function (D8M) {
            return ('' + D8M)["substring"](1, (D8M + '')["length"] - 1);
        })('_getTime2'), function (D8M, F8M) {
            return new D8M()[F8M]();
        }), function (Y8M, d8M) {
            var n8M = parseInt(Y8M["charAt"](d8M), 16)["toString"](2);
            return n8M["charAt"](n8M["length"] - 1);
        });
    })('18fj9j22n2'), 'f22': function (H, P) {
        return H == P;
    }, 'D92': function (H, P) {
        return H > P;
    }, 'Q8W': function (H, P) {
        return H * P;
    }, 'W4W': function (H, P, j) {
        return H / P * j;
    }, 'Y3U': "onLoad", 'g72': function (H, P) {
        return H !== P;
    }, 'v52': function (H, P) {
        return H * P;
    }, 'U22': function (H, P) {
        return H == P;
    }, 'I3U': "MaterialLoadingManager", 'M52': function (H, P) {
        return H == P;
    }, 'Q92': function (H, P) {
        return H != P;
    }, 'W8W': function (H, P) {
        return H * P;
    }, 'c22': function (H, P) {
        return H * P;
    }, 'O6U': "ThreeJsRender", 'h22': function (H, P) {
        return H == P;
    }, 'p0U': true, 'l52': function (H, P) {
        return H instanceof P;
    }, 't22': function (H, P) {
        return H < P;
    }, 'z8W': function (H, P, j) {
        return H * P * j;
    }, 's0U': "MouseMode", 'N8W': function (H, P) {
        return H === P;
    }, 'H8W': function (H, P) {
        return H * P;
    }, 'p22': function (H, P) {
        return H > P;
    }, 's22': function (H, P) {
        return H < P;
    }, 'v72': function (H, P) {
        return H !== P;
    }, 'j22': function (H, P) {
        return H < P;
    }, 'v22': function (H, P) {
        return H == P;
    }, 'u8W': function (H, P) {
        return H != P;
    }, 'u92': function (H, P) {
        return H * P;
    }, 'r22': function (H, P) {
        return H == P;
    }, 'S62': function (H, P) {
        return H * P;
    }, 'G4W': function (H, P) {
        return H * P;
    }, 'o92': function (H, P) {
        return H > P;
    }, 'P4W': function (H, P) {
        return H * P;
    }, 'T5i': 1, 'y92': function (H, P) {
        return H == P;
    }, 'd52': function (H, P) {
        return H < P;
    }, 'y8W': function (H, P) {
        return H * P;
    }, 'M4W': function (H, P) {
        return H * P;
    }, 'T22': function (H, P) {
        return H == P;
    }, 'm52': function (H, P) {
        return H == P;
    }, 'C8W': function (H, P) {
        return H != P;
    }, 'h72': function (H, P) {
        return H === P;
    }, 'l22': function (H, P) {
        return H == P;
    }, 'w5i': 2, 'O22': function (H, P) {
        return H < P;
    }, 'V8W': function (H, P) {
        return H * P;
    }, 'G52': function (H, P) {
        return H != P;
    }, 'E62': function (H, P) {
        return H * P;
    }, 'Y92': function (H, P) {
        return H / P;
    }, 'h52': function (H, P) {
        return H instanceof P;
    }, 'w92': function (H, P) {
        return H * P;
    }, 'r62': function (H, P) {
        return H == P;
    }, 'P92': function (H, P) {
        return H == P;
    }, 'X92': function (H, P) {
        return H > P;
    }, 'T62': function (H, P) {
        return H > P;
    }, 'J62': function (H, P) {
        return H < P;
    }, 'F62': function (H, P) {
        return H > P;
    }, 'C92': function (H, P) {
        return H * P;
    }, 'N92': function (H, P) {
        return H > P;
    }, 'a72': function (H, P) {
        return H !== P;
    }, 'q62': function (H, P) {
        return H * P;
    }, 'x62': function (H, P) {
        return H < P;
    }, 'o8W': function (H, P) {
        return H * P;
    }, 'c92': function (H, P) {
        return H < P;
    }, 'e62': function (H, P) {
        return H < P;
    }
};
Z4X72.S4M = function (n) {
    for (; Z4X72;)return Z4X72.L8M.X8M(n);
};
Z4X72.p4M = function (b) {
    while (b)return Z4X72.L8M.X8M(b);
};
Z4X72.Z4M = function (j) {
    while (j)return Z4X72.L8M.V8M(j);
};
Z4X72.q4M = function (l) {
    for (; Z4X72;)return Z4X72.L8M.X8M(l);
};
Z4X72.m4M = function (a) {
    while (a)return Z4X72.L8M.X8M(a);
};
Z4X72.c4M = function (j) {
    for (; Z4X72;)return Z4X72.L8M.X8M(j);
};
Z4X72.J4M = function (k) {
    if (Z4X72 && k)return Z4X72.L8M.X8M(k);
};
Z4X72.i4M = function (n) {
    while (n)return Z4X72.L8M.X8M(n);
};
Z4X72.D4M = function (a) {
    if (Z4X72 && a)return Z4X72.L8M.X8M(a);
};
Z4X72.d4M = function (a) {
    for (; Z4X72;)return Z4X72.L8M.X8M(a);
};
Z4X72.Y4M = function (d) {
    if (Z4X72 && d)return Z4X72.L8M.X8M(d);
};
Z4X72.n4M = function (c) {
    while (c)return Z4X72.L8M.V8M(c);
};
Z4X72.V4M = function (a) {
    for (; Z4X72;)return Z4X72.L8M.V8M(a);
};
Z4X72.L4M = function (b) {
    while (b)return Z4X72.L8M.V8M(b);
};
Z4X72.r4M = function (b) {
    for (; Z4X72;)return Z4X72.L8M.V8M(b);
};
Z4X72.M4M = function (g) {
    while (g)return Z4X72.L8M.X8M(g);
};
Z4X72.z4M = function (b) {
    for (; Z4X72;)return Z4X72.L8M.X8M(b);
};
Z4X72.U4M = function (c) {
    if (Z4X72 && c)return Z4X72.L8M.V8M(c);
};
Z4X72.K4M = function (d) {
    for (; Z4X72;)return Z4X72.L8M.X8M(d);
};
Z4X72.W4M = function (h) {
    while (h)return Z4X72.L8M.X8M(h);
};
Z4X72.b4M = function (b) {
    while (b)return Z4X72.L8M.V8M(b);
};
Z4X72.y4M = function (l) {
    while (l)return Z4X72.L8M.X8M(l);
};
Z4X72.x4M = function (a) {
    for (; Z4X72;)return Z4X72.L8M.V8M(a);
};
Z4X72.t4M = function (k) {
    while (k)return Z4X72.L8M.X8M(k);
};
Z4X72.u8M = function (l) {
    for (; Z4X72;)return Z4X72.L8M.X8M(l);
};
Z4X72.T8M = function (b) {
    while (b)return Z4X72.L8M.X8M(b);
};
Z4X72.v8M = function (l) {
    if (Z4X72 && l)return Z4X72.L8M.V8M(l);
};
Z4X72.o8M = function (c) {
    if (Z4X72 && c)return Z4X72.L8M.V8M(c);
};
Z4X72.h8M = function (i) {
    for (; Z4X72;)return Z4X72.L8M.V8M(i);
};
BIMVIZ[Z4X72.I3U] = Z4X72.h8M("63") ? function (K, U, G) {
    Z4X72.j4M = function (c) {
        if (Z4X72 && c)return Z4X72.L8M.X8M(c);
    };
    Z4X72.A8M = function (j) {
        for (; Z4X72;)return Z4X72.L8M.X8M(j);
    };
    Z4X72.I8M = function (h) {
        if (Z4X72 && h)return Z4X72.L8M.V8M(h);
    };
    Z4X72.C8M = function (d) {
        if (Z4X72 && d)return Z4X72.L8M.X8M(d);
    };
    Z4X72.a8M = function (g) {
        for (; Z4X72;)return Z4X72.L8M.X8M(g);
    };
    Z4X72.w8M = function (e) {
        for (; Z4X72;)return Z4X72.L8M.V8M(e);
    };
    Z4X72.e8M = function (e) {
        for (; Z4X72;)return Z4X72.L8M.V8M(e);
    };
    Z4X72.B8M = function (b) {
        if (Z4X72 && b)return Z4X72.L8M.X8M(b);
    };
    var f = Z4X72.B8M("28") ? "setValue1iv" : "itemError", M = Z4X72.o8M("4a63") ? "itemEnd" : "FUNC_SUBTRACT",
        V = Z4X72.v8M("36") ? "itemStart" : "T", d = Z4X72.e8M("8351") ? "onError" : "_mouseup",
        n = Z4X72.w8M("14") ? "onProgress" : "Vector2", F = Z4X72.a8M("d5d4") ? "onStart" : "maxCubemapSize",
        D = Z4X72.T8M("aea") ? "crossFadeFrom" : this,
        i = Z4X72.C8M("de") ? Z4X72.O9U : "return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;",
        m = Z4X72.j4M("7a") ? Z4X72.C5i : 'TorusGeometry',
        S = Z4X72.I8M("dad") ? "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif" : Z4X72.C5i;
    this[F] = Z4X72.x4M("eaf") ? undefined : "low";
    this[Z4X72.Y3U] = Z4X72.b4M("f7b") ? K : "IFCCOLUMN";
    this[n] = U;
    this[d] = Z4X72.A8M("da8") ? G : "ahole";
    this[V] = Z4X72.u8M("6bf") ? 'contextmenu' : function (H) {
        Z4X72.O4M = function (i) {
            while (i)return Z4X72.L8M.V8M(i);
        };
        Z4X72.g8M = function (n) {
            if (Z4X72 && n)return Z4X72.L8M.X8M(n);
        };
        var P = Z4X72.O4M("81") ? "v72" : 'string', j = Z4X72.g8M("56c7") ? 0.870588 : "h72";
        S++;
        if (Z4X72[j](i, Z4X72.O9U)) {
            if (Z4X72[P](D[F], undefined)) {
                D[F](H, m, S);
            }
        }
        i = Z4X72.y4M("6d") ? Z4X72.p0U : "with undefined Event Name";
    };
    this[M] = Z4X72.t4M("77") ? 'modelMatrix' : function (H) {
        Z4X72.s4M = function (g) {
            while (g)return Z4X72.L8M.X8M(g);
        };
        Z4X72.H4M = function (f) {
            while (f)return Z4X72.L8M.V8M(f);
        };
        Z4X72.R4M = function (f) {
            for (; Z4X72;)return Z4X72.L8M.X8M(f);
        };
        var P = Z4X72.R4M("4a2") ? '), and skinWeights (' : "g72",
            j = Z4X72.H4M("5dd") ? "I72" : "] undefined in .playAnimation()", O = Z4X72.s4M("fe3") ? 1011 : "a72";
        m++;
        if (Z4X72[O](D[n], undefined)) {
            D[n](H, m, S);
        }
        if (Z4X72[j](m, S)) {
            Z4X72.E4M = function (g) {
                while (g)return Z4X72.L8M.X8M(g);
            };
            i = Z4X72.E4M("37") ? 37 : Z4X72.O9U;
            if (Z4X72[P](D[Z4X72.Y3U], undefined)) {
                D[Z4X72.Y3U]();
            }
        }
    };
    this[f] = function (H) {
        Z4X72.P4M = function (a) {
            for (; Z4X72;)return Z4X72.L8M.X8M(a);
        };
        var P = Z4X72.P4M("65") ? "H92" : "attribute vec2 position;";
        if (Z4X72[P](D[d], undefined)) {
            D[d](H);
        }
    };
} : 'gl.getProgramInfoLog';
BIMVIZ[Z4X72.s0U] = {Roaming: Z4X72.C5i, RoamingAndPickElement: Z4X72.T5i, RoamingAndPickOnePoint: Z4X72.w5i,};
BIMVIZ[Z4X72.O6U] = function (m4, i4) {
    Z4X72.F4M = function (n) {
        if (Z4X72 && n)return Z4X72.L8M.V8M(n);
    };
    Z4X72.f4M = function (k) {
        while (k)return Z4X72.L8M.X8M(k);
    };
    Z4X72.G4M = function (i) {
        while (i)return Z4X72.L8M.V8M(i);
    };
    Z4X72.Q4M = function (g) {
        for (; Z4X72;)return Z4X72.L8M.V8M(g);
    };
    var M4 = "OnRmeshLoaded", G4 = "DataServerBigMeshLoaded",
        v4 = Z4X72.W4M("37e2") ? "thetaLength" : "DataServerTreeLoaded",
        x0 = Z4X72.K4M("2db") ? "bindRenderbuffer" : "ProjectOverviewLoaded",
        G0 = Z4X72.U4M("7fe") ? "rotateOnAxis" : "EVENT", F4 = Z4X72.Q4M("5bff") ? "toggle" : "addListener",
        C4 = Z4X72.G4M("42f5") ? 'sRGB' : "add3dModelObj", d4 = Z4X72.f4M("4337") ? "u8W" : 'logdepthbuf_vertex',
        q4 = "C8W", k4 = "selectSettings", r4 = Z4X72.z4M("c851") ? 101 : 0.15, V4 = "AlwaysDepth",
        V0 = Z4X72.M4M("2ab") ? "depthFunc" : "textureNeedsPowerOfTwo",
        t0 = Z4X72.r4M("6d83") ? "handleTouchStartPan" : "depthWrite", K0 = "depthTest", d0 = 200,
        M0 = Z4X72.L4M("83e") ? "BoxBufferGeometry" : "DepthTexture", F0 = 24, n0 = "w8W", R0 = "rollSpeed",
        i0 = Z4X72.V4M("ef") ? "KeyControls" : "planes", b0 = 0.75, e4 = "o8W", r0 = "maxPolarAngle",
        z3 = "OrbitControls", A4 = 20750, m0 = Z4X72.n4M("6d") ? "up" : "openEnded",
        K3 = Z4X72.Y4M("847") ? 5000000 : 'AudioContext', S3 = Z4X72.d4M("d14") ? 1048576 : "X8W",
        O3 = Z4X72.F4M("22") ? '		attribute vec3 morphTarget5;' : 45,
        Y3 = Z4X72.D4M("36e5") ? "inPolygon" : "PerspectiveCamera", j3 = "domElement", u4 = "appendChild",
        l3 = "colorFilter", u0 = "N8W", v0 = "colorTable", k0 = "autoClear", J3 = "gammaOutput",
        J1 = Z4X72.i4M("27") ? "gammaInput" : "m23", S1 = Z4X72.J4M("41d") ? "setValue4fv" : "devicePixelRatio",
        i1 = Z4X72.c4M("a4a8") ? "DEPTH_TEST" : "setPixelRatio", p1 = "setClearColor", E1 = "WebGLRenderer",
        X3 = "AxisHelper", f0 = 0.8, p0 = Z4X72.m4M("17") ? "FLOAT" : "DirectionalLight", w3 = "AmbientLight",
        x3 = "Scene", t3 = Z4X72.q4M("8121") ? "getStyle" : "clientHeight", z1 = "clientWidth", v3 = "contextmenu",
        T0 = "addEventListener", r3 = "getElementById", p4 = Z4X72.Z4M("2a") ? "IfcFlowController" : "setLookBoxFrom",
        S4 = "setLookFrom", c1 = "toScreenPosition", s0 = "setKeyControlMovementSpeed", j0 = "movementSpeed",
        h0 = "getKeyControlMovementSpeed", N0 = 10000, l0 = Z4X72.p4M("da2c") ? "createMarker" : "maxVertexUniforms",
        V3 = "TextureLoader", r1 = Z4X72.S4M("ca") ? "idbok" : "updateMarkerMeshIcon", I0 = "set", h4 = 1000,
        R3 = "animateMarker", v1 = "resetCameraLook", B3 = "renderDomId", e3 = "onProjectInfoLoaded",
        Z0 = "OnSelectElementGeometryList", F3 = "OnRaySelectNone", c3 = "addSelectDataList", E9 = "showType",
        D7 = "flyViewPoint", X1 = "OnPickElementGeometry", q0 = "acquireSpacePoint", I3 = "grayScene",
        Q1 = "addSelectData", l1 = "MeshBasicMaterial", M9 = "BufferGeometry", e0 = "opacity", P1 = "Mesh", T3 = '',
        E0 = "defines", q3 = "Color", U0 = "DoubleSide", t1 = "MeshLambertMaterial", B7 = "VertexColors", X6 = 'color',
        v7 = 1.0, Q7 = "IFCWALLSTANDARDCASE", w7 = "a", y2 = "b", V2 = "g", J9 = "r", L6 = "DEFAULT",
        x2 = "GlobalMaterials_Sketcup", K7 = "IFCSITE", B9 = "color", m9 = "elementId", l6 = "matrix",
        j9 = "toUpperCase", H7 = "ifctype", t7 = 4, f1 = "units", S9 = "setIndex", u2 = 'normal',
        B1 = "BufferAttribute", L9 = 'position', i3 = "addAttribute", V1 = "edgeindices", w1 = "edgepositions",
        y9 = "indices", Q6 = "normals", n9 = "positions", B6 = "addRmesh", n6 = "onRmeshLoaded",
        v6 = "addMeshDataOriganal", O2 = "onBigMeshLoaded", d6 = "attachBimScene", f7 = "args", K6 = "georoot",
        E4 = "Z", Z9 = "Y", T9 = "X", l9 = "SizeY", s1 = "SizeX", R1 = "onTreeLoaded", n2 = "setSize", M7 = "resize",
        J7 = "render", J6 = "requestOneUpdate", v9 = "overrideMaterialInst", D6 = "overrideMaterial",
        O9 = "clearSelection", y7 = "SYS_EVENT", E7 = "center", b1 = "sub", T7 = "RoamingAndPickOnePoint",
        w9 = "onPickEvent", d1 = "Roaming", F1 = "revertMouseMode", O1 = "switchMouseMode",
        W2 = "getPickWithCameraMove", m7 = "cameraMove", d2 = "setPickWithCameraMove", I9 = "TopFrontRight",
        u9 = "BoxPosition", u7 = "RoamingAndPickElement", s3 = "Raycaster", I7 = "Clock", p2 = "selectedElementId",
        t9 = "camera", E3 = null, L7 = "scene", N2 = 0.7, Z6 = "transparent", U2 = "material", i2 = "LineSegments",
        I6 = "forEach", m6 = "children", K2 = "LineBasicMaterial", d9 = "tempScene", T6 = "multiplyScalar",
        t6 = "SizeZ", q1 = "position", e2 = 'block.obj', p3 = "setMaterials", w6 = "OBJLoader", D2 = "preload",
        n7 = '% downloaded', a1 = "round", Q2 = "log", k2 = 100, X2 = "total", d7 = "loaded", R2 = "lengthComputable",
        w2 = 'block.mtl', H6 = "setPath", y1 = "ResourcePath", Z7 = "setBaseUrl", I1 = "MTLLoader", o0 = 3,
        f6 = "theme", u6 = "copy", t2 = "Vector3", o1 = 0.1, x1 = "add", f9 = "backScene", Q9 = "z", K9 = "y", j6 = 5,
        Q3 = 0.5, l7 = "PI", K1 = "x", c2 = "rotation";
    function g2() {
        var H = "sunPosition", P = "J8W", j = "sin", O = "d8W", K = "cos", U = "V8W", G = "azimuth", f = "z8W",
            M = "inclination", V = "Q8W", d = "mieDirectionalG", n = "mieCoefficient", F = "luminance", D = "reileigh",
            i = "value", m = "turbidity", S = "uniforms", k = 4000000, o = 0.38, I = 0.25, e = 0.12, C = 0.6, B = "W8W",
            R8 = "mesh", u = "Sky", H8 = new THREE[u]();
        H8[R8][c2][K1] = Z4X72[B](Math[l7], Q3);
        H8[R8].scale[K1] = j6;
        H8[R8].scale[K9] = j6;
        H8[R8].scale[Q9] = j6;
        w0[f9][x1](H8[R8]);
        var O8 = {
            turbidity: Z4X72.T5i,
            reileigh: C,
            mieCoefficient: Z4X72.C5i,
            mieDirectionalG: e,
            luminance: o1,
            inclination: I,
            azimuth: o
        }, E8 = k, W8 = H8[S];
        W8[m][i] = O8[m];
        W8[D][i] = O8[D];
        W8[F][i] = O8[F];
        W8[n][i] = O8[n];
        W8[d][i] = O8[d];
        var f8 = Z4X72[V](Math[l7], (O8[M] - Q3)), Q8 = Z4X72[f](Z4X72.w5i, Math[l7], (O8[G] - Q3)),
            z8 = new THREE[t2]();
        z8[K1] = Z4X72[U](E8, Math[K](Q8));
        z8[Q9] = Z4X72[O](E8, Math[j](Q8), Math[j](f8));
        z8[K9] = Z4X72[P](E8, Math[j](Q8), Math[K](f8));
        H8[S][H][i][u6](z8);
    }
    function E6(H, P) {
        var j = "colorMode", O = "table", K = "custom", U = "systable", G = "auto", f = "transparentMode",
            M = "ColorTable", V = i4[M];
        switch (V[f]) {
            case f6:
                break;
            case G:
                var d = V[U][P];
                if (d) {
                    H[o0] = d[o0];
                }
                break;
            case K:
                var d = V[O][P];
                if (d) {
                    H[o0] = d[o0];
                }
                break;
        }
        ;
        switch (V[j]) {
            case f6:
                break;
            case K:
                var d = V[O][P];
                if (d) {
                    H[Z4X72.C5i] = d[Z4X72.C5i];
                    H[Z4X72.T5i] = d[Z4X72.T5i];
                    H[Z4X72.w5i] = d[Z4X72.w5i];
                }
                break;
        }
        ;
    }
    function h2(k) {
        var o = '/models/land/', I = new THREE[I1](S6);
        I[Z7](i4[y1] + o);
        I[H6](i4[y1] + o);
        I.load(w2, function (D) {
            var i = function (H) {
            }, m = function (H) {
                var P = "W4W";
                if (H[R2]) {
                    var j = Z4X72[P](H[d7], H[X2], k2);
                    console[Q2](Math[a1](j, Z4X72.w5i) + n7);
                }
            };
            D[D2]();
            var S = new THREE[w6]();
            S[p3](D);
            S[H6](i4[y1] + o);
            S.load(e2, function (U) {
                var G = 100000, f = 2.5, M = "V4W", V = "M4W", d = "G4W";
                U[q1][Q9] -= Z4X72[d](k[t6], Q3);
                U[c2][K1] = Z4X72[V](Math[l7], Q3);
                var n = Z4X72[M](E2, f, G);
                U.scale[T6](n);
                w0[d9][x1](U);
                var F = new THREE[K2]({color: 0x111111, linewidth: Z4X72.T5i});
                U[m6][I6](function (H) {
                    var P = "geometry", j = "EdgesGeometry", O = new THREE[j](H[P]), K = new THREE[i2](O, F);
                    H[x1](K);
                });
            }, m, i);
        });
    }
    function I2(d) {
        var n = '/images/land/', F = new THREE[I1](S6);
        F[Z7](i4[y1] + n);
        F[H6](i4[y1] + n);
        F.load(w2, function (G) {
            var f = function (H) {
                var P = "R4W";
                if (H[R2]) {
                    var j = Z4X72[P](H[d7], H[X2], k2);
                    console[Q2](Math[a1](j, Z4X72.w5i) + n7);
                }
            }, M = function (H) {
            };
            G[D2]();
            var V = new THREE[w6]();
            V[p3](G);
            V[H6](i4[y1] + n);
            V.load(e2, function (j) {
                var O = 500, K = "y4W", U = "P4W";
                j[m6][I6](function (H) {
                    var P = "alphaTest";
                    {
                        H[U2][Z6] = Z4X72.p0U;
                        H[U2][P] = N2;
                    }
                });
                j[q1][Q9] -= Z4X72[U](d[t6], Q3);
                j[c2][K1] = Z4X72[K](Math[l7], Q3);
                j.scale[T6](O);
                w0[d9][x1](j);
            }, f, M);
        });
    }
    this[L7] = E3;
    this[t9] = E3;
    this[f6] = Z4X72.T5i;
    this[d9] = E3;
    this[f9] = E3;
    this[p2] = E3;
    var j7 = E3, H9 = E3, M6 = E3, z2 = E3, a2 = new THREE[I7](), T2 = new THREE[s3](), S7 = E3, G2 = E3, f2 = E3,
        O6 = E3, y6 = E3, D9 = E3, E2 = Z4X72.C5i, Z2 = BIMVIZ[Z4X72.s0U][u7], H5 = BIMVIZ[Z4X72.s0U][u7], w0 = this,
        s2 = E3, X7 = Z4X72.O9U, f3 = BIMVIZ[u9][I9], S6 = E3, X9 = {grayScene: Z4X72.p0U, cameraMove: Z4X72.p0U};
    this[d2] = function (H) {
        X9[m7] = H;
    };
    this[W2] = function () {
        return X9[m7];
    };
    this[O1] = function (H) {
        var P = "P92";
        if (Z4X72[P](H, Z2))return;
        H5 = Z2;
        Z2 = H;
        s2 = E3;
    };
    this[F1] = function () {
        Z2 = H5;
        H5 = BIMVIZ[Z4X72.s0U][d1];
        s2 = E3;
    };
    this[w9] = function (H) {
        var P = "PickElementByRay", j = "fire", O = "EventManager", K = "RayIntersection", U = "direction",
            G = "origin", f = "ray", M = "setFromCamera", V = "offsetY", d = "L92", n = "offsetX", F = "z92",
            D = "Vector2", i = "Q92", m = "W92", S = "y92";
        if (Z4X72[S](S7, E3)) {
            return;
        }
        if (Z4X72[m](Z2, BIMVIZ[Z4X72.s0U][u7]) && Z4X72[i](Z2, BIMVIZ[Z4X72.s0U][T7]))return;
        var k = new THREE[D](Z4X72.C5i, Z4X72.C5i);
        k[K1] = Z4X72[F]((H[n] / w0.width) * Z4X72.w5i, Z4X72.T5i);
        k[K9] = -(Z4X72[d](H[V], w0.height)) * Z4X72.w5i + Z4X72.T5i;
        T2[M](k, w0[t9]);
        var o = T2[f][G], I = T2[f][U], e = S7[K](T2);
        o[b1](S7[E7]);
        i4[O][j](BIMVIZ[y7][P], {pos: o, dir: I, markers: e, event: H});
    };
    this[O9] = function () {
        var H = "ClearTempMesh";
        S7[H]();
        w0[L7][D6] = E3;
        w0[L7][v9] = E3;
        w0[p2] = E3;
        i4[J6]();
    };
    this[J7] = function () {
        var H = "updateCamera", P = "update", j = "getDelta";
        if (j7) {
            var O = a2[j]();
            if (M6) {
                if (M6[P](O)) {
                    H9[H]();
                }
            }
            j7[J7](w0[L7], w0[t9], E3, Z4X72.p0U);
            j7[J7](w0[f9], w0[t9], E3, Z4X72.O9U);
            j7[J7](w0[d9], w0[t9], E3, Z4X72.O9U);
        }
    };
    this[M7] = function (H, P) {
        var j = "updateProjectionMatrix", O = "Y92", K = "aspect";
        w0.width = H;
        w0.height = P;
        w0[t9][K] = Z4X72[O](H, P);
        w0[t9][j]();
        j7[n2](H, P, Z4X72.O9U);
    };
    this[R1] = function (M) {
        var V = "ChildNodes";
        function d(H) {
            F(H[V][Z4X72.C5i], Z4X72.T5i);
        }
        function n(H) {
            var P = "BoxHelper", j = "Box3", O = "o92", K = "X92", U = "N92";
            if (Z4X72[U](H[s1], Z4X72.C5i) || Z4X72[K](H[l9], Z4X72.C5i) || Z4X72[O](H[t6], Z4X72.C5i)) {
                var G = new THREE[j](new THREE[t2](H[T9], H[Z9], H[E4]), new THREE[t2](H[T9] + H[s1], H[Z9] + H[l9], H[E4] + H[t6])),
                    f = new THREE[P](G);
                f[U2] = new THREE[K2]({color: 0xcccccc});
                S7[K6][x1](f);
            }
        }
        function F(H) {
            var P = "Z92", j = "c92", O = "Box", K = "Level", U = "D92";
            if (Z4X72[U](H[K], Z4X72.T5i)) {
                return;
            }
            n(H[O]);
            for (var G = Z4X72.C5i; Z4X72[j](G, H[V].length); G++) {
                var f = H[V][G];
                if (Z4X72[P](f, E3))continue;
                F(f);
            }
        }
        var D = M[f7];
        ;
        ;
    };
    this[d6] = function (H, P) {
        var j = "overlayGeoRoot";
        S7 = H;
        G2 = P;
        w0[L7][x1](S7[K6]);
        w0[L7][x1](G2[K6]);
        w0[d9][x1](S7[j]);
    };
    this[O2] = function (H) {
        w0[v6](H[f7]);
    };
    this[n6] = function (H) {
        w0[B6](H[f7], w0[f6]);
    };
    ;
    this[B6] = function (H, P) {
        var j = "addRefMesh", O = 0.4, K = "e62", U = "B62", G = "k62", f = "S62", M = "q62", V = "J62", d = "F62",
            n = "inst", F = "frustumCulled", D = 'mcol3', i = 'mcol2', m = 'mcol1', S = 'mcol0', k = "n62",
            o = "setXYZW", I = 14, e = 13, C = 12, B = 10, R8 = 9, u = 8, H8 = 6, O8 = "setXYZ", E8 = "r62", W8 = "f62",
            f8 = "U62", Q8 = "push", z8 = "O62", x8 = "x62", r8 = "E62", P8 = "R62", U8 = "u92", J8 = "C92", F8 = "w92",
            D8 = "InstancedBufferAttribute", n8 = "InstancedBufferGeometry", q8 = H[n9], L8 = H[Q6], N8 = H[y9],
            X8 = H[w1], o8 = H[V1], T8 = new THREE[n8]();
        T8[i3](L9, new THREE[B1](q8, o0));
        T8[i3](u2, new THREE[B1](L8, o0));
        T8[S9](new THREE[B1](N8, Z4X72.T5i));
        var e8 = H[f1].length, S8 = new THREE[D8](new Float32Array(Z4X72[F8](e8, o0)), o0, Z4X72.T5i),
            c8 = new THREE[D8](new Float32Array(Z4X72[J8](e8, o0)), o0, Z4X72.T5i),
            k8 = new THREE[D8](new Float32Array(Z4X72[U8](e8, o0)), o0, Z4X72.T5i),
            t4 = new THREE[D8](new Float32Array(Z4X72[P8](e8, o0)), o0, Z4X72.T5i),
            j4 = new THREE[D8](new Float32Array(Z4X72[r8](e8, t7)), t7, Z4X72.T5i), Y8 = Z4X72.O9U, B8 = [];
        for (var A8 = Z4X72.C5i; Z4X72[x8](A8, e8); A8++) {
            var C8 = H[f1][A8], u8 = C8[H7][j9](), w8 = C8[l6], R4 = C8[m9], x4 = C8[B9];
            if (Z4X72[z8](u8, K7)) {
                B8[Q8](C8);
            }
            if (Z4X72[f8](w0[f6], Z4X72.w5i)) {
                var U4 = BIMVIZ[x2][u8];
                if (Z4X72[W8](U4, E3)) {
                    U4 = BIMVIZ[x2][L6];
                }
                x4[Z4X72.C5i] = U4[J9];
                x4[Z4X72.T5i] = U4[V2];
                x4[Z4X72.w5i] = U4[y2];
                x4[o0] = U4[w7];
            }
            E6(x4, u8);
            if (Z4X72[E8](u8, Q7)) {
                x4[o0] = x4[o0];
            }
            S8[O8](A8, w8[Z4X72.C5i], w8[Z4X72.T5i], w8[Z4X72.w5i]);
            c8[O8](A8, w8[t7], w8[j6], w8[H8]);
            k8[O8](A8, w8[u], w8[R8], w8[B]);
            t4[O8](A8, w8[C], w8[e], w8[I]);
            j4[o](A8, x4[Z4X72.C5i], x4[Z4X72.T5i], x4[Z4X72.w5i], x4[o0]);
            if (Z4X72[k](x4[o0], v7)) {
                Y8 = Z4X72.p0U;
            }
            C8[B9] = x4;
        }
        T8[i3](S, S8);
        T8[i3](m, c8);
        T8[i3](i, k8);
        T8[i3](D, t4);
        T8[i3](X6, j4);
        var K4 = THREE[B7], n4 = new THREE[t1]({side: THREE[U0], vertexColors: K4, color: new THREE[q3](0xffffff)});
        n4[E0] = {INSTI: T3, USE_COLOR_OPACITY: T3};
        if (Y8) {
            n4[Z6] = Z4X72.p0U;
        }
        var O4 = new THREE[P1](T8, n4);
        O4[F] = Z4X72.O9U;
        O4[n] = Z4X72.p0U;
        var J4 = E3;
        if (Z4X72[d](B8.length, Z4X72.C5i)) {
            var f4 = S8, s4 = c8, b4 = k8, B4 = t4;
            if (Z4X72[V](B8.length, e8)) {
                var l4 = B8.length;
                f4 = new THREE[D8](new Float32Array(Z4X72[M](l4, o0)), o0, Z4X72.T5i);
                s4 = new THREE[D8](new Float32Array(Z4X72[f](l4, o0)), o0, Z4X72.T5i);
                b4 = new THREE[D8](new Float32Array(Z4X72[G](l4, o0)), o0, Z4X72.T5i);
                B4 = new THREE[D8](new Float32Array(Z4X72[U](l4, o0)), o0, Z4X72.T5i);
                for (var A8 = Z4X72.C5i; Z4X72[K](A8, l4); A8++) {
                    var C8 = B8[A8], u8 = C8[H7][j9](), w8 = C8[l6], x4 = C8[B9];
                    f4[O8](A8, w8[Z4X72.C5i], w8[Z4X72.T5i], w8[Z4X72.w5i]);
                    s4[O8](A8, w8[t7], w8[j6], w8[H8]);
                    b4[O8](A8, w8[u], w8[R8], w8[B]);
                    B4[O8](A8, w8[C], w8[e], w8[I]);
                }
            }
            var w4 = new THREE[n8]();
            w4[i3](L9, new THREE[B1](X8, o0));
            w4[S9](new THREE[B1](o8, Z4X72.T5i));
            w4[i3](S, f4);
            w4[i3](m, s4);
            w4[i3](i, b4);
            w4[i3](D, B4);
            var T4 = new THREE[K2]({color: 0x101010});
            if (Y8) {
                T4[Z6] = Z4X72.p0U;
                T4[e0] = O;
            }
            T4[E0] = {INSTI: T3};
            var J4 = new THREE[i2](w4, T4);
            J4[F] = Z4X72.O9U;
            J4[n] = Z4X72.p0U;
        }
        G2[j](O4, J4, H[f1]);
    };
    this[v6] = function (H) {
        var P = "addBatMesh", j = "j52", O = "IFCREINFORCINGBAR", K = "s52", U = 0.2, G = "t52", f = "A22", M = "T22",
            V = "v22", d = "IFCWALL", n = "h22", F = "IFCSLAB", D = "l22", i = "p22", m = "c22", S = "D22",
            k = "indexCount", o = "indicesCopy", I = "Y22", e = "r22", C = "f22", B = "U22", R8 = "O22", u = "j22",
            H8 = "s22", O8 = 0.001, E8 = "t22", W8 = "A62", f8 = "T62", Q8 = "colorbuf", z8 = "colors", x8 = "fileId",
            r8 = "meshId", P8 = H[r8], U8 = H[x8], J8 = H[n9], F8 = H[Q6], D8 = H[y9], n8 = H[w1], q8 = H[V1],
            L8 = H[z8], N8 = H[Q8], X8 = new THREE[M9]();
        X8[i3](L9, new THREE[B1](J8, o0));
        if (F8 && Z4X72[f8](F8.length, Z4X72.C5i)) {
            X8[i3](u2, new THREE[B1](F8, o0));
        }
        X8[S9](new THREE[B1](D8, Z4X72.T5i));
        var o8 = new THREE[M9]();
        o8[i3](L9, new THREE[B1](n8, o0));
        o8[S9](new THREE[B1](q8, Z4X72.T5i));
        var T8 = Z4X72.O9U, e8 = H[f1].length;
        for (var S8 = Z4X72.C5i; Z4X72[W8](S8, e8); S8++) {
            var c8 = H[f1][S8], k8 = c8[l6], t4 = c8[B9], j4 = c8[m9], Y8 = c8[H7][j9]();
            if (Z4X72[E8](t4[Z4X72.C5i], O8) && Z4X72[H8](t4[Z4X72.T5i], O8) && Z4X72[u](t4[Z4X72.w5i], O8) && Z4X72[R8](t4[o0], O8)) {
                t4[Z4X72.C5i] = N2;
                t4[Z4X72.T5i] = N2;
                t4[Z4X72.w5i] = N2;
                t4[o0] = Q3;
            }
            if (Z4X72[B](w0[f6], Z4X72.w5i)) {
                var B8 = BIMVIZ[x2][Y8];
                if (Z4X72[C](B8, E3)) {
                    B8 = BIMVIZ[x2][L6];
                }
                t4[Z4X72.C5i] = B8[J9];
                t4[Z4X72.T5i] = B8[V2];
                t4[Z4X72.w5i] = B8[y2];
                t4[o0] = B8[w7];
            }
            E6(t4, Y8);
            if (Z4X72[e](Y8, Q7)) {
                t4[o0] = t4[o0];
            }
            if (Z4X72[I](t4[o0], v7)) {
                T8 = Z4X72.p0U;
            }
            c8[B9] = t4;
            var A8 = c8[o], C8 = Z4X72.C5i, u8 = c8[k], w8 = C8 + u8, R4 = N8;
            for (var x4 = C8; Z4X72[S](x4, w8); x4++) {
                var U4 = Z4X72[m](A8[x4], t7);
                R4[U4] = t4[Z4X72.C5i];
                R4[U4 + Z4X72.T5i] = t4[Z4X72.T5i];
                R4[U4 + Z4X72.w5i] = t4[Z4X72.w5i];
                R4[U4 + o0] = t4[o0];
            }
        }
        if (N8 && Z4X72[i](N8.length, Z4X72.C5i)) {
            X8[i3](X6, new THREE[B1](N8, t7));
        }
        var K4 = THREE[B7], n4 = new THREE[q3](0xffffff), O4 = E3;
        if (Z4X72[D](Y8, F) || Z4X72[n](Y8, d) || Z4X72[V](Y8, Q7)) {
            O4 = new THREE[l1]({color: n4, side: THREE[U0], vertexColors: K4});
            T8 = Z4X72.p0U;
        } else {
            O4 = new THREE[t1]({color: n4, side: THREE[U0], vertexColors: K4});
        }
        if (T8) {
            O4[Z6] = Z4X72.p0U;
        }
        O4[E0] = {USE_COLOR_OPACITY: T3};
        var J4 = new THREE[P1](X8, O4);
        J4[H7] = Y8;
        var f4 = new THREE[K2]({color: 0x101010});
        if (Z4X72[M](Y8, F) || Z4X72[f](Y8, d) || Z4X72[G](Y8, Q7)) {
            f4[Z6] = Z4X72.p0U;
            f4[e0] = U;
        }
        if (Z4X72[K](Y8, O) || Z4X72[j](Y8, K7)) {
            G2[P](J4, E3, H[f1]);
        } else {
            var s4 = new THREE[i2](o8, f4);
            s4[H7] = Y8;
            G2[P](J4, s4, H[f1]);
        }
    };
    this[Q1] = function (H) {
        var P = "K52", j = "b52", O = "AddTempMesh", K = "edges", U = H[H7][j9](), G = H[n9], f = H[y9], M = H[K],
            V = new THREE[M9]();
        V[i3](L9, new THREE[B1](G, o0));
        V[S9](new THREE[B1](f, Z4X72.T5i));
        var d = new THREE[P1](V, z2);
        S7[O](d);
        if (Z4X72[j](U, K7)) {
            var n = new THREE[M9]();
            n[i3](L9, new THREE[B1](M, o0));
            var F = new THREE[i2](n, y6);
            S7[O](F);
        }
        if (Z4X72[P](X9[I3], Z4X72.p0U)) {
            w0[L7][D6] = f2;
            w0[L7][v9] = O6;
        }
    };
    this[q0] = function (H) {
        this[O1](BIMVIZ[Z4X72.s0U][T7]);
        s2 = H;
    };
    this[X1] = function (H) {
        var P = "distance", j = "point", O = "G52";
        w0[O9]();
        var K = H[f7];
        if (Z4X72[O](K[m9], undefined)) {
            w0[p2] = K[m9];
        }
        switch (Z2) {
            case BIMVIZ[Z4X72.s0U][d1]:
                break;
            case BIMVIZ[Z4X72.s0U][u7]:
                w0[Q1](K);
                if (X9[m7]) {
                    H9[D7](K[j], S7[E7]);
                }
                break;
            case BIMVIZ[Z4X72.s0U][T7]:
                if (s2) {
                    var U = {ifctype: K[H7], elementId: K[m9], point: K[j], distance: K[P]};
                    s2(U);
                    s2 = E3;
                }
                w0[F1]();
                break;
        }
    };
    this[E9] = function (H, P) {
        var j = "visible", O = "V52", K = "M52", U = "FindBigMeshByType", G = S7[U](H);
        if (Z4X72[K](G, E3))return;
        for (var f = Z4X72.C5i; Z4X72[O](f, G.length); f++) {
            G[f][j] = P;
        }
    };
    this[c3] = function (H) {
        var P = "sphere", j = "d52";
        w0[O9]();
        for (var O = Z4X72.C5i; Z4X72[j](O, H.length); O++) {
            w0[Q1](H[O]);
        }
        if (X9[m7]) {
            var K = H[P], U = new THREE[t2](K[Z4X72.C5i], K[Z4X72.T5i], K[Z4X72.w5i]), G = K[o0];
            H9[D7](U, S7[E7], G);
        }
    };
    this[F3] = function (H) {
        w0[O9]();
    };
    this[Z0] = function (H) {
        w0[c3](H[f7]);
    };
    this[e3] = function (H) {
        var P = "greenland2", j = "p52", O = "greenland", K = "groundstyle", U = "m52", G = "addClass",
            f = "singlebackground", M = "removeClass", V = '#', d = "bimviz_gradbackground",
            n = "bimviz_singlebackgroundblack", F = "bimviz_singlebackground", D = "background", i = "i52", m = "max",
            S = "box", k = H[f7];
        w0[f6] = k[f6];
        var o = new THREE[t2](-k[E7][T9], -k[E7][Z9], -k[E7][E4]);
        w0[f9][q1][u6](o);
        D9 = {X: k[S][T9], Y: k[S][Z9], Z: k[S][E4], SizeX: k[S][s1], SizeY: k[S][l9], SizeZ: k[S][t6]};
        D9[T9] += o[K1];
        D9[Z9] += o[K9];
        D9[E4] += o[Q9];
        E2 = Math[m](D9[s1], D9[l9]);
        E2 = Math[m](E2, D9[t6]);
        if (Z4X72[i](k[D], t7)) {
            g2();
        } else {
            var I = [F, F, n, d], e = I[k[D]];
            $(V + m4[B3])[M](f)[G](e);
        }
        if (Z4X72[U](k[K], O)) {
            I2(D9);
        }
        if (Z4X72[j](k[K], P)) {
            h2(D9);
        }
        X7 = Z4X72.p0U;
        w0[v1](Z4X72.O9U);
    };
    this[R3] = function (P) {
        var j = "chain", O = "onComplete", K = "start", U = "onUpdate", G = 250, f = 2000, M = "to", V = "Tween",
            d = 'animateMarker', n = "requestHighSpeed";
        i4[n](d);
        var F = {x: h4}, D = new TWEEN[V](F)[M]({x: f}, G)[U](function () {
            P.scale[I0](Z4X72.T5i, Z4X72.T5i, Z4X72.T5i);
            P.scale[T6](F[K1]);
        })[K](), i = new TWEEN[V](F)[M]({x: h4}, G)[U](function () {
            P.scale[I0](Z4X72.T5i, Z4X72.T5i, Z4X72.T5i);
            P.scale[T6](F[K1]);
        })[O](function () {
            var H = "removeHighSpeed";
            i4[H](d);
        })[K]();
        TWEEN[x1](D);
        D[j](i);
    };
    this[r1] = function (H, P) {
        var j = "needsUpdate", O = "map", K = new THREE[V3](), U = i4[y1] + P;
        H[U2][O] = K.load(U);
        H[U2][j] = Z4X72.p0U;
    };
    this[l0] = function (H, P) {
        var j = "v52", O = "Sprite", K = 20000, U = "SpriteMaterial", G = "h52", f = "l52", M = H;
        if (Z4X72[f](H, Array) || Z4X72[G](H, Float32Array)) {
            M = new THREE[t2](H[Z4X72.C5i], H[Z4X72.T5i], H[Z4X72.w5i]);
        }
        var V = new THREE[V3](), d = i4[y1] + P, n = V.load(d), F = new THREE[U]({
            map: n,
            color: 0xffffff,
            polygonOffset: Z4X72.p0U,
            polygonOffsetFactor: -N0,
            polygonOffsetUnits: -K
        }), D = new THREE[O](F), i = h4;
        D[q1][I0](M[K1], M[K9], M[Q9] + Z4X72[j](i, Q3));
        D.scale[T6](i);
        return D;
    };
    this[h0] = function () {
        var H = "a52";
        if (Z4X72[H](M6, E3))return Z4X72.C5i; else return M6[j0];
    };
    this[s0] = function (H) {
        var P = "I52";
        if (Z4X72[P](M6, E3)) {
            M6[j0] = H;
        }
    };
    this[c1] = function (H) {
        var P = "y8W", j = "P8W", O = "project", K = "clone", U = "H8W", G = "g52", f = Z4X72[G](Q3, w0.width),
            M = Z4X72[U](Q3, w0.height), V = H[K]();
        V[x1](S7[E7]);
        V[O](w0[t9]);
        V[K1] = (Z4X72[j](V[K1], f)) + f;
        V[K9] = -(Z4X72[P](V[K9], M)) + M;
        V[Q9] = Z4X72.C5i;
        return V;
    };
    this[S4] = function (H, P, j) {
        if (X7) {
            this[p4](D9, H, P, j);
        } else {
            f3 = H;
            if (j) {
                j();
            }
        }
    };
    this[v1] = function (H) {
        this[p4](D9, f3, H);
    };
    this[p4] = function (H, P, j, O) {
        var K = "lookFromTo", U = "flyFromTo", G = "setLength", f = 1.5, M = "Z8W", V = "BoxCenter",
            d = "GetPositionFromServerBoxDefine", n = "ConvertUtil", F = BIMVIZ[n][d](H, BIMVIZ[u9][V]),
            D = BIMVIZ[n][d](H, P), i = Z4X72[M](E2, f);
        D = D[b1](F)[G](i)[x1](F);
        if (j) {
            H9[U](D, F, O);
        } else {
            H9[K](D, F);
        }
    };
    try {
        var Z8 = document[r3](m4[B3]);
        Z8[T0](v3, function (H) {
            var P = "preventDefault";
            H[P]();
        });
        this.width = Z8[z1];
        this.height = Z8[t3];
        this[L7] = new THREE[x3]();
        this[L7][x1](new THREE[w3](new THREE[q3](Q3, Q3, Q3)));
        var o2 = new THREE[p0](new THREE[q3](Z4X72.T5i, Z4X72.T5i, Z4X72.T5i), f0);
        o2[q1][I0](Q3, Q3, Z4X72.T5i);
        this[L7][x1](o2);
        var B2 = new THREE[p0]([Z4X72.T5i, Z4X72.T5i, Z4X72.T5i], f0);
        B2[q1][I0](Q3, -Q3, Z4X72.T5i);
        this[L7][x1](B2);
        var n1 = new THREE[X3](h4);
        this[L7][x1](n1);
        this[d9] = new THREE[x3]();
        this[d9][x1](new THREE[w3](new THREE[q3](Q3, Q3, Q3)));
        o2 = new THREE[p0](new THREE[q3](Z4X72.T5i, Z4X72.T5i, Z4X72.T5i), o1);
        o2[q1][I0](Q3, Q3, Z4X72.T5i);
        this[d9][x1](o2);
        B2 = new THREE[p0]([Z4X72.T5i, Z4X72.T5i, Z4X72.T5i], o1);
        B2[q1][I0](Q3, -Q3, Z4X72.T5i);
        this[d9][x1](B2);
        j7 = new THREE[E1]({antialias: Z4X72.p0U, alpha: Z4X72.p0U});
        j7[p1](0x000000, Z4X72.C5i);
        j7[i1](window[S1]);
        j7[n2](this.width, this.height);
        j7[J1] = Z4X72.p0U;
        j7[J3] = Z4X72.p0U;
        j7[k0] = Z4X72.O9U;
        if (m4[v0] && Z4X72[u0](m4[v0][l3], Z4X72.O9U)) {
            j7[J1] = Z4X72.O9U;
            j7[J3] = Z4X72.O9U;
        }
        Z8[u4](j7[j3]);
        this[t9] = new THREE[Y3](O3, Z4X72[S3](this.width, this.height), h4, K3);
        this[t9][m0][I0](Z4X72.C5i, Z4X72.C5i, Z4X72.T5i);
        this[t9][q1][Q9] = A4;
        H9 = new THREE[z3](this[t9], j7[j3], this[L7], this[w9], i4);
        H9[r0] = Z4X72[e4](Math[l7], b0);
        M6 = new THREE[i0](this[t9], j7[j3], i4);
        M6[R0] = Z4X72[n0](Math[l7], F0);
        M6[j0] = N0;
        var H2 = new THREE[M0](d0, d0, d0), O0 = new THREE[l1]({color: 0xaaaaaa}), u3 = new THREE[P1](H2, O0);
        u3[q1][I0](Z4X72.C5i, Z4X72.C5i, Z4X72.C5i);
        this[L7][x1](u3);
        z2 = new THREE[t1]({color: 0x0033FF, side: THREE[U0]});
        z2[Z6] = Z4X72.p0U;
        z2[e0] = Q3;
        z2[K0] = Z4X72.O9U;
        z2[t0] = Z4X72.O9U;
        z2[V0] = THREE[V4];
        f2 = new THREE[t1]({color: 0x6c6c6c});
        f2[Z6] = Z4X72.p0U;
        f2[e0] = r4;
        O6 = new THREE[t1]({color: 0x6c6c6c});
        O6[Z6] = Z4X72.p0U;
        O6[e0] = r4;
        O6[E0] = {INSTI: T3};
        y6 = new THREE[K2]({color: 0x000000});
        y6[K0] = Z4X72.O9U;
        y6[t0] = Z4X72.O9U;
        y6[V0] = THREE[V4];
        this[f9] = new THREE[x3]();
        if (m4[k4]) {
            if (Z4X72[q4](m4[k4][I3], undefined)) {
                X9[I3] = m4[k4][I3];
            }
            if (Z4X72[d4](m4[k4][m7], undefined)) {
                X9[m7] = m4[k4][m7];
            }
        }
        S6 = new BIMVIZ[Z4X72.I3U]();
        S6[Z4X72.Y3U] = function () {
            i4[J6]();
        };
    } catch (H) {
    }
    this[C4] = function (V, d, n, F, D) {
        var i = "", m = "Z4W";
        function S(O, K, U) {
            var G = function (H) {
                var P = "F4W";
                if (H[R2]) {
                    var j = Z4X72[P](H[d7], H[X2], k2);
                    console[Q2](Math[a1](j, Z4X72.w5i) + n7);
                }
            }, f = function (H) {
            }, M = new THREE[w6]();
            if (U) {
                M[p3](U);
            }
            M[H6](O);
            M.load(K, function (H) {
                var P = "CenterPosition", j = "c4W";
                if (Z4X72[j](F, Z4X72.O9U)) {
                    H[q1][b1](i4[P]);
                }
                w0[d9][x1](H);
                H.parent = E3;
                i4[J6]();
                if (D) {
                    D(H);
                }
            }, G, f);
        }
        if (n && Z4X72[m](n, i)) {
            var k = new THREE[I1](S6);
            k[Z7](V);
            k[H6](V);
            k.load(n, function (H) {
                H[D2]();
                S(V, d, H);
            });
        } else {
            S(V, d, E3);
        }
    };
    i4[F4](BIMVIZ[G0][x0], this[e3]);
    i4[F4](BIMVIZ[y7][v4], this[R1]);
    i4[F4](BIMVIZ[y7][G4], this[O2]);
    i4[F4](BIMVIZ[y7][X1], this[X1]);
    i4[F4](BIMVIZ[y7][Z0], this[Z0]);
    i4[F4](BIMVIZ[y7][F3], this[F3]);
    i4[F4](BIMVIZ[y7][M4], this[n6]);
};
var c9w4 = {
    'c0': function (H, P) {
        return H == P;
    }, 'P0': function (H, P) {
        return H < P;
    }, 'D0': function (H, P) {
        return H == P;
    }, 's9K': (function (W9K) {
        return (function (M9K, f9K) {
            return (function (r9K) {
                return {E9K: r9K, V9K: r9K,};
            })(function (j9K) {
                var Q9K, x9K = 0;
                for (var z9K = M9K; x9K < j9K["length"]; x9K++) {
                    var G9K = f9K(j9K, x9K);
                    Q9K = x9K === 0 ? G9K : Q9K ^ G9K;
                }
                return Q9K ? z9K : !z9K;
            });
        })((function (K9K, b9K, y9K, U9K) {
            var O9K = 27;
            return K9K(W9K, O9K) - U9K(b9K, y9K) > O9K;
        })(parseInt, Date, (function (b9K) {
            return ('' + b9K)["substring"](1, (b9K + '')["length"] - 1);
        })('_getTime2'), function (b9K, y9K) {
            return new b9K()[y9K]();
        }), function (j9K, x9K) {
            var P9K = parseInt(j9K["charAt"](x9K), 16)["toString"](2);
            return P9K["charAt"](P9K["length"] - 1);
        });
    })('pfn1pjdb0'), 'L0': function (H, P) {
        return H != P;
    }, 'H0': function (H, P) {
        return H < P;
    }, 'Y0': function (H, P) {
        return H > P;
    }, 'z0': function (H, P) {
        return H <= P;
    }, 'W0': function (H, P) {
        return H != P;
    }, 'a4': function (H, P) {
        return H == P;
    }, 'Q0': function (H, P) {
        return H > P;
    }, 'y0': function (H, P) {
        return H != P;
    }, 'g4': function (H, P) {
        return H > P;
    }, 'I4': function (H, P) {
        return H > P;
    }, 'B39': "DataLoader"
};
c9w4.z6K = function (d) {
    for (; c9w4;)return c9w4.s9K.E9K(d);
};
c9w4.U6K = function (j) {
    for (; c9w4;)return c9w4.s9K.E9K(j);
};
c9w4.K6K = function (k) {
    while (k)return c9w4.s9K.E9K(k);
};
c9w4.W6K = function (c) {
    if (c9w4 && c)return c9w4.s9K.V9K(c);
};
c9w4.E6K = function (g) {
    if (c9w4 && g)return c9w4.s9K.V9K(g);
};
c9w4.s6K = function (g) {
    for (; c9w4;)return c9w4.s9K.V9K(g);
};
c9w4.H6K = function (d) {
    while (d)return c9w4.s9K.E9K(d);
};
c9w4.R6K = function (e) {
    for (; c9w4;)return c9w4.s9K.E9K(e);
};
c9w4.I9K = function (j) {
    if (c9w4 && j)return c9w4.s9K.V9K(j);
};
c9w4.C9K = function (h) {
    while (h)return c9w4.s9K.E9K(h);
};
c9w4.T9K = function (g) {
    if (c9w4 && g)return c9w4.s9K.V9K(g);
};
c9w4.a9K = function (f) {
    if (c9w4 && f)return c9w4.s9K.V9K(f);
};
c9w4.w9K = function (k) {
    for (; c9w4;)return c9w4.s9K.E9K(k);
};
c9w4.e9K = function (j) {
    for (; c9w4;)return c9w4.s9K.V9K(j);
};
c9w4.v9K = function (n) {
    if (c9w4 && n)return c9w4.s9K.E9K(n);
};
c9w4.X9K = function (l) {
    if (c9w4 && l)return c9w4.s9K.E9K(l);
};
c9w4.k9K = function (c) {
    for (; c9w4;)return c9w4.s9K.E9K(c);
};
c9w4.l9K = function (a) {
    while (a)return c9w4.s9K.V9K(a);
};
c9w4.N9K = function (d) {
    if (c9w4 && d)return c9w4.s9K.E9K(d);
};
c9w4.S9K = function (m) {
    for (; c9w4;)return c9w4.s9K.E9K(m);
};
c9w4.Z9K = function (l) {
    for (; c9w4;)return c9w4.s9K.E9K(l);
};
c9w4.q9K = function (c) {
    while (c)return c9w4.s9K.V9K(c);
};
c9w4.J9K = function (i) {
    if (c9w4 && i)return c9w4.s9K.E9K(i);
};
c9w4.D9K = function (c) {
    while (c)return c9w4.s9K.V9K(c);
};
c9w4.F9K = function (f) {
    while (f)return c9w4.s9K.V9K(f);
};
c9w4.d9K = function (k) {
    for (; c9w4;)return c9w4.s9K.E9K(k);
};
c9w4.n9K = function (c) {
    if (c9w4 && c)return c9w4.s9K.E9K(c);
};
BIMVIZ[c9w4.B39] = c9w4.n9K("ce8") ? 'springgreen' : function (z8, x8) {
    c9w4.Q6K = function (j) {
        while (j)return c9w4.s9K.V9K(j);
    };
    c9w4.b6K = function (j) {
        for (; c9w4;)return c9w4.s9K.E9K(j);
    };
    c9w4.P6K = function (h) {
        while (h)return c9w4.s9K.E9K(h);
    };
    c9w4.t6K = function (j) {
        while (j)return c9w4.s9K.E9K(j);
    };
    c9w4.A9K = function (g) {
        for (; c9w4;)return c9w4.s9K.E9K(g);
    };
    c9w4.o9K = function (b) {
        while (b)return c9w4.s9K.V9K(b);
    };
    c9w4.B9K = function (k) {
        if (c9w4 && k)return c9w4.s9K.V9K(k);
    };
    c9w4.h9K = function (j) {
        while (j)return c9w4.s9K.V9K(j);
    };
    c9w4.p9K = function (m) {
        if (c9w4 && m)return c9w4.s9K.E9K(m);
    };
    c9w4.m9K = function (m) {
        while (m)return c9w4.s9K.V9K(m);
    };
    c9w4.c9K = function (a) {
        for (; c9w4;)return c9w4.s9K.E9K(a);
    };
    c9w4.i9K = function (d) {
        for (; c9w4;)return c9w4.s9K.V9K(d);
    };
    c9w4.Y9K = function (n) {
        while (n)return c9w4.s9K.V9K(n);
    };
    var r8 = c9w4.Y9K("b55") ? "ProjectOverviewLoaded" : "LuminanceFormat",
        P8 = c9w4.d9K("4bef") ? "iw" : "PickElementByRay", U8 = c9w4.F9K("1f") ? "seek" : "addListener",
        J8 = c9w4.D9K("2bbd") ? "onProjectInfoLoaded" : "uvCopy", F8 = c9w4.i9K("55f") ? "getElementById" : "console",
        D8 = c9w4.J9K("13") ? "intersectionPoint" : "onSelectElementById",
        n8 = c9w4.c9K("5d21") ? "onPickFromServer" : "makeBasis", q8 = c9w4.m9K("f66") ? "connect" : "skipTransform",
        L8 = c9w4.h9K("34a5") ? "CullFaceNone" : "debug", N8 = "element",
        X8 = c9w4.B9K("d7") ? "floatVertexTextures" : "projectId",
        o8 = c9w4.q9K("47") ? "RequestHeaders" : "PlaneGeometry", T8 = 'GET',
        e8 = c9w4.Z9K("386") ? 'Project/GetElementById' : 2.5, S8 = c9w4.p9K("8d8f") ? "intersectsSphere" : "APIURL",
        c8 = c9w4.S9K("45a4") ? "ajax" : "IFCWINDOW", k8 = "args",
        t4 = c9w4.w9K("574a") ? "byClipCacheIndex" : "markers",
        j4 = c9w4.o9K("1426") ? "WORKDEFINE" : "attributeArray2", Y8 = c9w4.N9K("571b") ? "rootNode" : "current",
        B8 = c9w4.l9K("1c18") ? "zLength" : "total", A8 = "OnLoadProgressStep", C8 = null,
        u8 = c9w4.k9K("2c") ? "wait cache" : 2, w8 = "SYS_EVENT",
        R4 = c9w4.X9K("8f") ? "EVENT" : "IfcDistributionFlowElement",
        x4 = c9w4.v9K("cb21") ? "checkBufferGeometryIntersection" : "fire",
        U4 = c9w4.e9K("75") ? "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n" : 1,
        K4 = 0;
    function n4(H) {
        c9w4.f6K = function (g) {
            while (g)return c9w4.s9K.V9K(g);
        };
        c9w4.G6K = function (j) {
            for (; c9w4;)return c9w4.s9K.E9K(j);
        };
        c9w4.O6K = function (l) {
            while (l)return c9w4.s9K.E9K(l);
        };
        c9w4.y6K = function (j) {
            while (j)return c9w4.s9K.E9K(j);
        };
        c9w4.x6K = function (n) {
            for (; c9w4;)return c9w4.s9K.V9K(n);
        };
        c9w4.j6K = function (k) {
            for (; c9w4;)return c9w4.s9K.V9K(k);
        };
        c9w4.g9K = function (h) {
            if (c9w4 && h)return c9w4.s9K.E9K(h);
        };
        c9w4.u9K = function (n) {
            while (n)return c9w4.s9K.V9K(n);
        };
        var P = "OnRmeshLoaded", J0 = c9w4.E6K("dc7") ? "zoom" : "rmesh",
            j = c9w4.f6K("bb6") ? "movementSpeedMultiplier" : "instcount",
            O = c9w4.P6K("7124") ? "lineFirstChar" : "nodecount", u1 = c9w4.a9K("d853") ? "OverviewLoaded" : "rollLeft",
            T1 = c9w4.j6K("c2d") ? "files" : "_updateTimeScale", K = c9w4.T9K("8be") ? "spaces" : "cachedUniforms",
            U = c9w4.C9K("2d") ? "domains" : "jsonTracks", G = c9w4.I9K("e4db") ? "forceContextLoss" : "scene",
            f = c9w4.A9K("dc") ? "parse" : "_onStopCallback", M = c9w4.u9K("58") ? "overview" : "EventArg",
            V = c9w4.x6K("de48") ? "OnSelectElementGeometryList" : "stencilWrite",
            M2 = c9w4.y6K("65c4") ? "queryelement" : "_targetGroup", d = c9w4.z6K("6d6c") ? "select" : "moved",
            n = c9w4.g9K("f8f") ? "box3d" : "DataServerDataBlockReceived",
            F = c9w4.t6K("6e84") ? "subscribe_" : "progress", D = "DataServerBigMeshLoaded",
            i = c9w4.b6K("dad") ? "edgePositionFloatCount" : "data", m = c9w4.O6K("c2") ? "onPickFromServer" : "close",
            v2 = c9w4.W6K("2b2") ? "ErrorMessage" : "createMarker", S = "error",
            P2 = c9w4.K6K("a528") ? 3 : 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
            j2 = "timelog", k = c9w4.U6K("46f2") ? "DataServerTreeLoaded" : "cube2DViewPorts",
            O7 = c9w4.R6K("3e") ? "tree" : "buildingStoreyId", o = c9w4.Q6K("f81e") ? "s3" : "DataServerConnectedError",
            y8 = "connecterror", I = c9w4.H6K("eaf") ? "DataServerConnected" : "pageX",
            e = c9w4.G6K("bf") ? "setDefaultGLState" : "connected", C = c9w4.s6K("ff") ? 307 : H.data[K4];
        switch (C) {
            case e:
                l4 = U4;
                x8[x4](BIMVIZ[R4][I]);
                break;
            case y8:
                var r2 = H.data[U4];
                x8[x4](BIMVIZ[R4][o], r2);
                break;
            case O7:
                var L2 = H.data[U4];
                x8[x4](BIMVIZ[w8][k], L2);
                B4(L2);
                break;
            case j2:
                var B = H.data[U4], R8 = B[K4], u = B[U4], b5 = B[u8], H8 = B[P2];
                break;
            case S:
                x8[x4](BIMVIZ[R4][v2]);
                break;
            case m:
                i4.postMessage([m]);
                i4 = C8;
                l4 = K4;
                break;
            case i:
                var O8 = H.data[U4];
                x8[x4](BIMVIZ[w8][D], O8);
                break;
            case F:
                var O8 = H.data[U4];
                x8[x4](BIMVIZ[w8][n], O8);
                break;
            case d:
                var O8 = H.data[U4];
                J4(O8);
                break;
            case M2:
                var E8 = H.data[U4];
                x8[x4](BIMVIZ[w8][V], E8);
                break;
            case M:
                var O8 = H.data[U4], W8 = O8[M], f8 = JSON[f](O8[G]);
                W8[U] = f8[U];
                W8[K] = f8[K];
                W8[T1] = f8[T1];
                x8[x4](BIMVIZ[w8][u1], W8);
                break;
            case O:
                var Q8 = H.data[U4];
                x8[x4](BIMVIZ[R4][A8], {total: w4, current: Q8});
                break;
            case j:
                var O8 = H.data[U4];
                x8[x4](BIMVIZ[R4][A8], {total: O8[B8], current: O8[Y8]});
                break;
            case J0:
                var O8 = H.data[U4];
                x8[x4](BIMVIZ[w8][P], O8);
                break;
        }
    }
    function O4(H) {
        var P = "GetElementData";
        i4.postMessage([BIMVIZ[j4][P], H]);
    }
    function J4(H) {
        var P = "OnRaySelectNone", J0 = "D0", j = "Y0", O = "L0", u1 = "OnPickElementGeometry", T1 = "elementId",
            K = "ifctype", U = "OnPickElement", G = "userdata", f = "OnPickMarker", M = "distance", V = "z0", M2 = "Q0",
            d = "W0", n = "Vector3", F = "point", D = "y0";
        if (c9w4[D](H, C8)) {
            H[F] = new THREE[n](H[F][K4], H[F][U4], H[F][u8]);
        }
        if (c9w4[d](H, C8) && c9w4[M2](G4[t4].length, K4)) {
            var i = G4[t4][K4], m = H;
            if (c9w4[V](i[M], m[M])) {
                x8[x4](BIMVIZ[R4][f], {userdata: i[G]});
            } else {
                x8[x4](BIMVIZ[R4][U], {ifctype: H[K], elementId: H[T1], point: H[F], distance: H[M]});
                x8[x4](BIMVIZ[w8][u1], H);
                b4(H[T1]);
            }
        } else if (c9w4[O](H, C8)) {
            x8[x4](BIMVIZ[R4][U], {ifctype: H[K], elementId: H[T1], point: H[F], distance: H[M]});
            x8[x4](BIMVIZ[w8][u1], H);
            b4(H[T1]);
        } else if (c9w4[j](G4[t4].length, K4)) {
            var i = G4[t4][K4];
            x8[x4](BIMVIZ[R4][f], {userdata: i[G]});
        }
        if (c9w4[J0](H, C8)) {
            x8[x4](BIMVIZ[w8][P], K4);
        }
    }
    function f4(H) {
        var P = 'scene onLoadProgress', J0 = "removeNormalSpeed", j = "c0", O = H[k8];
        if (c9w4[j](O[Y8], O[B8])) {
            x8[J0](P);
        }
    }
    function s4(H) {
    }
    function b4(j) {
        var O = $[c8]({
            url: x8[S8] + e8,
            type: T8,
            headers: x8[o8],
            data: {projId: x8[X8], globalId: j},
            success: function (H) {
                var P = "OnSelectElementPropertyList";
                if (H[N8]) {
                    x8[x4](BIMVIZ[R4][P], H[N8]);
                }
            },
            error: function (H, P, J0) {
                alert(J0);
            }
        });
    }
    function B4(H) {
        var P = "LoadTreeNodeMesh", J0 = "push", j = "P0", O = "min", u1 = "H0", T1 = 10, K = "g4", U = "I4",
            G = "hasOwnProperty", f = 100, M = "a4", V = 9, M2 = "levelIdListDict", d = "ChildNodes", n = H[d][K4],
            F = H[M2], D = V;
        if (c9w4[M](m4, U4)) {
            D = f;
        }
        for (var i in F) {
            if (F[G](i)) {
                if (c9w4[U](i, D))continue;
                var m = F[i];
                if (m) {
                    w4 += m.length;
                }
            }
        }
        var v2 = [];
        for (var i in F) {
            if (F[G](i)) {
                if (c9w4[K](i, D))continue;
                var m = F[i], S = T1;
                for (var P2 = K4; c9w4[u1](P2, m.length); P2 += S) {
                    var j2 = Math[O](P2 + S, m.length), k = [];
                    for (var O7 = P2; c9w4[j](O7, j2); O7++) {
                        k[J0](m[O7]);
                        v2[J0](m[O7]);
                    }
                    i4.postMessage([BIMVIZ[j4][P], k]);
                }
            }
        }
        x8[x4](BIMVIZ[A8], {total: w4, current: K4});
    }
    var l4 = K4, w4 = K4, T4 = K4, m4 = u8, i4, M4 = z8[L8];
    this[q8] = function () {
        var J0 = 'connect', j = "requestNormalSpeed", O = "username", u1 = "socketServer", T1 = "Start",
            K = "onbeforeunload", U = "workerJsUrl", G = "workerDebugJsUrl";
        if (M4) {
            i4 = new Worker(z8[G]);
        } else {
            i4 = new Worker(z8[U]);
        }
        i4.onmessage = n4;
        i4.onerror = s4;
        window[K] = function (H) {
            var P = "Close";
            if (i4) i4.postMessage([BIMVIZ[j4][P]]);
        };
        i4.postMessage([BIMVIZ[j4][T1], z8[u1], x8[X8], z8[O]]);
        x8[j](J0);
    };
    var G4 = {};
    this[n8] = function (H) {
        var P = "dir", J0 = "pos", j = "PickByRay", O = "getText", u1 = "getInvisibleSet", T1 = "event", K = "mouse",
            U = H[k8];
        G4 = {};
        G4[t4] = U[t4];
        G4[K] = U[T1];
        var G = x8[u1](), f = G[O]();
        i4.postMessage([BIMVIZ[j4][j], U[J0], U[P], f]);
    };
    ;
    this[D8] = function (H) {
        O4(H);
        b4(H);
    };
    this[F8] = function (j, O) {
        var u1 = $[c8]({
            url: x8[S8] + e8,
            type: T8,
            headers: x8[o8],
            data: {projId: x8[X8], globalId: j},
            success: function (H) {
                var P = false, J0 = true;
                if (H[N8]) {
                    O(J0, H[N8]);
                } else {
                    O(P, H[N8]);
                }
            },
            error: function (H, P, J0) {
                alert(J0);
            }
        });
    };
    this[J8] = function (H) {
        var P = "LoadTree", J0 = "loadingmethod", j = H[k8];
        m4 = j[J0];
        i4.postMessage([BIMVIZ[j4][P], m4]);
    };
    x8[U8](BIMVIZ[w8][P8], this[n8]);
    x8[U8](BIMVIZ[R4][r8], this[J8]);
    x8[U8](BIMVIZ[R4][A8], f4);
};
var L8S6l = {
    'G0d': 18,
    'X0d': "fromJsonObject",
    'y0d': 5,
    'F0d': 12,
    'r0d': 14,
    'u0d': 6,
    's0d': 2,
    'f0d': "Entity",
    'j0d': "Marker",
    'A0d': 15,
    'S0d': "Convert",
    'a0d': 7,
    'R0d': 4,
    'x0d': 9,
    'Z0d': "BoxPosition",
    'k0d': 11,
    'B0d': 3,
    'I0d': 8,
    'z0d': 16,
    'W0d': 13,
    'e0d': 0,
    'D3k': (function (X3k) {
        return (function (e3k, E3k) {
            return (function (S3k) {
                return {k3k: S3k, u3k: S3k,};
            })(function (H3k) {
                var c3k, O3k = 0;
                for (var f3k = e3k; O3k < H3k["length"]; O3k++) {
                    var q3k = E3k(H3k, O3k);
                    c3k = O3k === 0 ? q3k : c3k ^ q3k;
                }
                return c3k ? f3k : !f3k;
            });
        })((function (B3k, v3k, g3k, s3k) {
            var b3k = 26;
            return B3k(X3k, b3k) - s3k(v3k, g3k) > b3k;
        })(parseInt, Date, (function (v3k) {
            return ('' + v3k)["substring"](1, (v3k + '')["length"] - 1);
        })('_getTime2'), function (v3k, g3k) {
            return new v3k()[g3k]();
        }), function (H3k, O3k) {
            var F3k = parseInt(H3k["charAt"](O3k), 16)["toString"](2);
            return F3k["charAt"](F3k["length"] - 1);
        });
    })('18fj9j22n2'),
    'E0d': 1,
    'N0d': 17,
    'c0d': 10
};
L8S6l.k2k = function (k) {
    if (L8S6l && k)return L8S6l.D3k.k3k(k);
};
L8S6l.D2k = function (c) {
    while (c)return L8S6l.D3k.k3k(c);
};
L8S6l.W2k = function (g) {
    if (L8S6l && g)return L8S6l.D3k.u3k(g);
};
L8S6l.z2k = function (e) {
    if (L8S6l && e)return L8S6l.D3k.u3k(e);
};
L8S6l.A2k = function (f) {
    for (; L8S6l;)return L8S6l.D3k.u3k(f);
};
L8S6l.N2k = function (c) {
    for (; L8S6l;)return L8S6l.D3k.k3k(c);
};
L8S6l.V2k = function (e) {
    for (; L8S6l;)return L8S6l.D3k.u3k(e);
};
L8S6l.o2k = function (h) {
    for (; L8S6l;)return L8S6l.D3k.u3k(h);
};
L8S6l.T3k = function (c) {
    while (c)return L8S6l.D3k.k3k(c);
};
L8S6l.p3k = function (c) {
    while (c)return L8S6l.D3k.u3k(c);
};
L8S6l.P3k = function (m) {
    if (L8S6l && m)return L8S6l.D3k.k3k(m);
};
L8S6l.i3k = function (j) {
    if (L8S6l && j)return L8S6l.D3k.u3k(j);
};
L8S6l.U3k = function (k) {
    for (; L8S6l;)return L8S6l.D3k.u3k(k);
};
L8S6l.I3k = function (d) {
    if (L8S6l && d)return L8S6l.D3k.k3k(d);
};
L8S6l.x3k = function (k) {
    while (k)return L8S6l.D3k.u3k(k);
};
L8S6l.M3k = function (e) {
    for (; L8S6l;)return L8S6l.D3k.k3k(e);
};
L8S6l.j3k = function (e) {
    for (; L8S6l;)return L8S6l.D3k.u3k(e);
};
L8S6l.m3k = function (h) {
    if (L8S6l && h)return L8S6l.D3k.u3k(h);
};
L8S6l.y3k = function (j) {
    while (j)return L8S6l.D3k.u3k(j);
};
L8S6l.n3k = function (m) {
    while (m)return L8S6l.D3k.u3k(m);
};
BIMVIZ[L8S6l.f0d] = L8S6l.n3k("ac12") ? {} : '		attribute vec3 morphNormal0;';
BIMVIZ[L8S6l.f0d][L8S6l.j0d] = L8S6l.y3k("835") ? 'rotation' : function (A, K, D, k8, k, H) {
    L8S6l.G2k = function (f) {
        while (f)return L8S6l.D3k.k3k(f);
    };
    L8S6l.Q2k = function (j) {
        while (j)return L8S6l.D3k.u3k(j);
    };
    L8S6l.C3k = function (n) {
        while (n)return L8S6l.D3k.k3k(n);
    };
    L8S6l.l3k = function (j) {
        if (L8S6l && j)return L8S6l.D3k.u3k(j);
    };
    L8S6l.L3k = function (k) {
        for (; L8S6l;)return L8S6l.D3k.u3k(k);
    };
    L8S6l.w3k = function (a) {
        while (a)return L8S6l.D3k.k3k(a);
    };
    L8S6l.Z3k = function (a) {
        for (; L8S6l;)return L8S6l.D3k.k3k(a);
    };
    L8S6l.R3k = function (d) {
        if (L8S6l && d)return L8S6l.D3k.k3k(d);
    };
    var O = L8S6l.m3k("c5f") ? "edgemesh" : "toJsonObject", B = L8S6l.R3k("a125") ? "addColors" : "userdata",
        I8 = L8S6l.j3k("7f") ? "DEPTH_STENCIL" : "description", l8 = L8S6l.Z3k("f3e4") ? "maxlevel" : "title",
        E = L8S6l.M3k("8e3") ? "Vector3" : 'Object3D.toJSON', p8 = L8S6l.x3k("fb") ? "vertexCounter" : "clone",
        i8 = L8S6l.I3k("d171") ? "trans" : "point", e = L8S6l.P3k("58") ? "icon" : "_vertexCount",
        S = L8S6l.w3k("c8d3") ? "euclideanModulo" : "", u = L8S6l.L3k("e8") ? "WebGLRenderTargetCube" : "id";
    this[u] = L8S6l.l3k("c6") ? 'name' : A || S;
    this[e] = L8S6l.z2k("f285") ? 'ENVMAP_TYPE_SPHERE' : K || S;
    this[i8] = L8S6l.V2k("3f") ? 0x40E0D0 : D ? D[p8]() : new THREE[E]();
    this[l8] = L8S6l.C3k("54") ? k8 || S : 'ProjectOverviewLoaded';
    this[I8] = L8S6l.N2k("22fb") ? 'rgb' : k || S;
    this[B] = L8S6l.p3k("ac") ? "number" : H || S;
    var n = L8S6l.T3k("1d") ? "currinst" : this;
    this[L8S6l.X0d] = function (o) {
        L8S6l.t2k = function (f) {
            if (L8S6l && f)return L8S6l.D3k.u3k(f);
        };
        L8S6l.Y3k = function (f) {
            if (L8S6l && f)return L8S6l.D3k.u3k(f);
        };
        var N = L8S6l.Y3k("1f") ? "textBaseline" : "fromArray";
        n[u] = L8S6l.A2k("ac3") ? o[u] : "threshold";
        n[e] = L8S6l.G2k("da3") ? "animateMarker" : o[e];
        n[i8][N](o[i8]);
        n[l8] = L8S6l.U3k("586f") ? 'uniform float opacity;' : o[l8];
        n[I8] = L8S6l.t2k("36c") ? o[I8] : "vec3 Fex = exp(-(betaR * sR + betaM * sM));";
        n[B] = L8S6l.o2k("6e") ? "deltaX" : o[B];
    };
    this[O] = L8S6l.i3k("ba") ? function () {
        L8S6l.d2k = function (e) {
            while (e)return L8S6l.D3k.u3k(e);
        };
        L8S6l.h2k = function (k) {
            for (; L8S6l;)return L8S6l.D3k.u3k(k);
        };
        L8S6l.J3k = function (g) {
            for (; L8S6l;)return L8S6l.D3k.k3k(g);
        };
        var o = L8S6l.Q2k("d6") ? "z" : "colorbuf", N = L8S6l.h2k("5e4") ? "y" : "Array",
            d = L8S6l.d2k("673e") ? "renderBufferDirect" : "x", G = L8S6l.J3k("8e2") ? "opacity" : {
                id: n[u],
                icon: n[e],
                x: n[i8][d],
                y: n[i8][N],
                z: n[i8][o],
                title: n[l8],
                description: n[I8],
                userdata: n[B]
            };
        return G;
    } : "// constants for atmospheric scattering";
};
BIMVIZ[L8S6l.Z0d] = {
    BoxCenter: L8S6l.e0d,
    TopFrontRight: L8S6l.E0d,
    TopFrontLeft: L8S6l.s0d,
    TopFrontCenter: L8S6l.B0d,
    TopBackRight: L8S6l.R0d,
    TopBackLeft: L8S6l.y0d,
    TopBackCenter: L8S6l.u0d,
    BottomFrontRight: L8S6l.a0d,
    BottomFrontLeft: L8S6l.I0d,
    BottomFrontCenter: L8S6l.x0d,
    BottomBackRight: L8S6l.c0d,
    BottomBackLeft: L8S6l.k0d,
    BottomBackCenter: L8S6l.F0d,
    TopCenter: L8S6l.W0d,
    BottomCenter: L8S6l.r0d,
    LeftCetner: L8S6l.A0d,
    RightCetner: L8S6l.z0d,
    FrontCetner: L8S6l.N0d,
    BackCenter: L8S6l.G0d
};
BIMVIZ[L8S6l.f0d][L8S6l.S0d] = L8S6l.W2k("681") ? {
    MarkJsonObjToEntity: function (G) {
        L8S6l.K2k = function (k) {
            while (k)return L8S6l.D3k.k3k(k);
        };
        var A = L8S6l.K2k("e7f3") ? "forEach" : "_viewport", K = L8S6l.k2k("33c") ? "removeAll" : [];
        G[A](function (o) {
            L8S6l.r2k = function (a) {
                while (a)return L8S6l.D3k.u3k(a);
            };
            var N = L8S6l.r2k("6d") ? "push" : "MAX_FRAGMENT_UNIFORM_VECTORS",
                d = L8S6l.D2k("81") ? new BIMVIZ[L8S6l.f0d][L8S6l.j0d]() : 'gold';
            d[L8S6l.X0d](o);
            K[N](d);
        });
        return K;
    },
} : '#define USE_SHADOWMAP';
var n6H3C = {
    'Q3C': function (P, k) {
        return P / k;
    }, 'O3C': function (P, k) {
        return P == k;
    }, 'B3C': function (P, k, A) {
        return P / k / A;
    }, 'z5H': (function (u5H) {
        return (function (Y6H, r5H) {
            return (function (E6H) {
                return {T5H: E6H, k6H: E6H,};
            })(function (L5H) {
                var K5H, I5H = 0;
                for (var d5H = Y6H; I5H < L5H["length"]; I5H++) {
                    var i5H = r5H(L5H, I5H);
                    K5H = I5H === 0 ? i5H : K5H ^ i5H;
                }
                return K5H ? d5H : !d5H;
            });
        })((function (N5H, X5H, f5H, w5H) {
            var l5H = 29;
            return N5H(u5H, l5H) - w5H(X5H, f5H) > l5H;
        })(parseInt, Date, (function (X5H) {
            return ('' + X5H)["substring"](1, (X5H + '')["length"] - 1);
        })('_getTime2'), function (X5H, f5H) {
            return new X5H()[f5H]();
        }), function (L5H, I5H) {
            var x5H = parseInt(L5H["charAt"](I5H), 16)["toString"](2);
            return x5H["charAt"](x5H["length"] - 1);
        });
    })('ecr3hcrjl')
};
n6H3C.d6H = function (i) {
    while (i)return n6H3C.z5H.k6H(i);
};
n6H3C.r6H = function (f) {
    if (n6H3C && f)return n6H3C.z5H.k6H(f);
};
n6H3C.K6H = function (b) {
    while (b)return n6H3C.z5H.k6H(b);
};
n6H3C.w6H = function (h) {
    if (n6H3C && h)return n6H3C.z5H.k6H(h);
};
n6H3C.u6H = function (c) {
    if (n6H3C && c)return n6H3C.z5H.k6H(c);
};
n6H3C.I6H = function (i) {
    if (n6H3C && i)return n6H3C.z5H.T5H(i);
};
n6H3C.x6H = function (a) {
    while (a)return n6H3C.z5H.T5H(a);
};
n6H3C.z6H = function (l) {
    while (l)return n6H3C.z5H.k6H(l);
};
n6H3C.n6H = function (n) {
    while (n)return n6H3C.z5H.T5H(n);
};
n6H3C.p6H = function (c) {
    while (c)return n6H3C.z5H.k6H(c);
};
n6H3C.v6H = function (k) {
    if (n6H3C && k)return n6H3C.z5H.T5H(k);
};
n6H3C.b6H = function (m) {
    while (m)return n6H3C.z5H.T5H(m);
};
n6H3C.Q6H = function (c) {
    if (n6H3C && c)return n6H3C.z5H.T5H(c);
};
n6H3C.H6H = function (l) {
    for (; n6H3C;)return n6H3C.z5H.k6H(l);
};
n6H3C.F6H = function (i) {
    while (i)return n6H3C.z5H.T5H(i);
};
n6H3C.R6H = function (n) {
    while (n)return n6H3C.z5H.k6H(n);
};
n6H3C.D6H = function (g) {
    if (n6H3C && g)return n6H3C.z5H.k6H(g);
};
n6H3C.s6H = function (j) {
    for (; n6H3C;)return n6H3C.z5H.k6H(j);
};
n6H3C.U6H = function (e) {
    if (n6H3C && e)return n6H3C.z5H.T5H(e);
};
n6H3C.h6H = function (h) {
    while (h)return n6H3C.z5H.T5H(h);
};
n6H3C.J6H = function (n) {
    if (n6H3C && n)return n6H3C.z5H.T5H(n);
};
n6H3C.S6H = function (e) {
    if (n6H3C && e)return n6H3C.z5H.T5H(e);
};
n6H3C.W6H = function (n) {
    if (n6H3C && n)return n6H3C.z5H.k6H(n);
};
n6H3C.M6H = function (a) {
    if (n6H3C && a)return n6H3C.z5H.T5H(a);
};
n6H3C.a6H = function (b) {
    for (; n6H3C;)return n6H3C.z5H.k6H(b);
};
function StatStatus(i, E3) {
    n6H3C.i6H = function (g) {
        if (n6H3C && g)return n6H3C.z5H.T5H(g);
    };
    n6H3C.f6H = function (n) {
        while (n)return n6H3C.z5H.k6H(n);
    };
    n6H3C.L6H = function (j) {
        for (; n6H3C;)return n6H3C.z5H.T5H(j);
    };
    n6H3C.V6H = function (h) {
        while (h)return n6H3C.z5H.T5H(h);
    };
    n6H3C.O6H = function (a) {
        for (; n6H3C;)return n6H3C.z5H.T5H(a);
    };
    n6H3C.j6H = function (d) {
        while (d)return n6H3C.z5H.T5H(d);
    };
    n6H3C.g6H = function (b) {
        for (; n6H3C;)return n6H3C.z5H.k6H(b);
    };
    n6H3C.G6H = function (d) {
        if (n6H3C && d)return n6H3C.z5H.k6H(d);
    };
    n6H3C.c6H = function (a) {
        if (n6H3C && a)return n6H3C.z5H.k6H(a);
    };
    n6H3C.t6H = function (l) {
        while (l)return n6H3C.z5H.T5H(l);
    };
    n6H3C.Z6H = function (g) {
        while (g)return n6H3C.z5H.T5H(g);
    };
    n6H3C.y6H = function (l) {
        if (n6H3C && l)return n6H3C.z5H.T5H(l);
    };
    n6H3C.A6H = function (f) {
        for (; n6H3C;)return n6H3C.z5H.T5H(f);
    };
    var K = n6H3C.a6H("51") ? "itemSize" : "OnRmeshLoaded", I = n6H3C.A6H("d1d") ? "OnConnectServer" : "WebGLState",
        a3 = n6H3C.M6H("e6") ? "negRadius" : "OnLoadProgressStep",
        Y3 = n6H3C.y6H("bae") ? "DataServerDataBlockReceived" : "instmesh",
        k3 = n6H3C.W6H("6e4b") ? "DataServerBigMeshLoaded" : "updateAttribute",
        S3 = n6H3C.S6H("af24") ? "SYS_EVENT" : "generateMipmaps",
        M3 = n6H3C.J6H("f81") ? "LoopPingPong" : "addListener", Z3 = n6H3C.h6H("625") ? null : "shadowCamera",
        c3 = n6H3C.G6H("a2f4") ? "0%" : 0.537255, t3 = n6H3C.c6H("ce") ? "BOTTOM" : "percent", G3 = 0,
        J3 = n6H3C.Z6H("dc") ? "EVENT" : "radiusTop", R3 = n6H3C.d6H("674") ? "meshCount" : "updateCubeMap",
        y3 = n6H3C.U6H("ec") ? "getActiveAttrib" : "count",
        U3 = n6H3C.F6H("fe8") ? "elemetCount" : "tempOverlayGeoRoot", O3 = n6H3C.s6H("86") ? "LatheGeometry" : "face",
        H3 = n6H3C.D6H("f3c") ? "ThreeJsRender" : "triCount", V3 = n6H3C.R6H("72") ? "rmeshCount" : "findStoreyData",
        n3 = n6H3C.g6H("2e4") ? "mipmapCount" : "receivedDataSize", p3 = n6H3C.t6H("e5c") ? "args" : "bones";
    function m3(P) {
        var k = n6H3C.H6H("274f") ? "hp" : "hide", A = n6H3C.Q6H("2b") ? '#bv_div_debugMessage' : 2302,
            M = n6H3C.b6H("31b8") ? "debug" : "createBufferSource", W = "total", S = "current", D = "O3C",
            R = n6H3C.v6H("8e") ? 'encodings_fragment' : P[p3];
        if (n6H3C[D](R[S], R[W])) {
            if (!E3[M]) {
                $(A)[k]();
            }
        }
    }
    function L3(P) {
        n6H3C.N6H = function (b) {
            while (b)return n6H3C.z5H.k6H(b);
        };
        var k = P[p3];
        e3[n3] += n6H3C.N6H("32c") ? k : "y2";
        K3();
    }
    function u3(P) {
        n6H3C.B6H = function (k) {
            if (n6H3C && k)return n6H3C.z5H.k6H(k);
        };
        var k = n6H3C.B6H("f11") ? P[p3] : 'TorusKnotBufferGeometry';
        e3[V3]++;
        e3[H3] += k[O3];
        e3[U3] += k[y3];
        K3();
    }
    function N3(P) {
        x3 = new Date();
    }
    function d3(P) {
        var k = P[p3];
        e3[R3]++;
        e3[H3] += n6H3C.w6H("37fc") ? k[O3] : "if ( renderType == 2 ) {";
        e3[U3] += n6H3C.p6H("1fbb") ? 'EXT_blend_minmax' : k[y3];
        K3();
    }
    function K3() {
        n6H3C.l6H = function (c) {
            for (; n6H3C;)return n6H3C.z5H.k6H(c);
        };
        n6H3C.X6H = function (f) {
            while (f)return n6H3C.z5H.k6H(f);
        };
        n6H3C.T6H = function (l) {
            for (; n6H3C;)return n6H3C.z5H.T5H(l);
        };
        n6H3C.o6H = function (h) {
            while (h)return n6H3C.z5H.T5H(h);
        };
        n6H3C.C6H = function (d) {
            if (n6H3C && d)return n6H3C.z5H.k6H(d);
        };
        n6H3C.m6H = function (n) {
            if (n6H3C && n)return n6H3C.z5H.T5H(n);
        };
        n6H3C.q6H = function (d) {
            for (; n6H3C;)return n6H3C.z5H.k6H(d);
        };
        n6H3C.e6H = function (g) {
            while (g)return n6H3C.z5H.k6H(g);
        };
        var P = n6H3C.T6H("653") ? "RGBEEncoding" : "OnShowDebugInfo", k = n6H3C.n6H("33") ? "EdgeMesh" : "fire",
            A = n6H3C.X6H("d35") ? '<div> Time: ' : 'mousedown', M = n6H3C.j6H("65d") ? "vUV = uv;" : '<div> RC2: ',
            W = '<div> RC1: ', S = n6H3C.O6H("f8c") ? '<div> Elements: ' : 'papayawhip',
            D = n6H3C.x6H("5c5b") ? '<div> Triangles: ' : 'WebGLRenderer: trying to use ',
            R = n6H3C.e6H("77dd") ? 'Sprite' : '</div>',
            F = n6H3C.q6H("8d") ? '<div> Size: ' : 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',
            Q = n6H3C.m6H("fe35") ? " MB" : "verts", j = n6H3C.L6H("a78e") ? 1024 : 1008,
            B = n6H3C.C6H("7ce3") ? "tFlip" : "B3C", O = n6H3C.o6H("8d") ? 1 : " but it wasn't found.",
            e = n6H3C.l6H("6ef") ? "toFixed" : "screenPosition", m = n6H3C.V6H("fe17") ? 1000 : 'dodgerblue',
            V = n6H3C.u6H("2553") ? "getTime" : "easing", C = n6H3C.I6H("2461") ? "Q3C" : 0.9,
            L = n6H3C.z6H("b6") ? (n6H3C[C](((new Date())[V]() - x3[V]()), m))[e](O) : 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.',
            u = n6H3C.K6H("25d") ? "varying vec2 vUV;" : (n6H3C[B](e3[n3], j, j))[e](O) + Q,
            d = n6H3C.f6H("c746") ? F + u + R + D + e3[H3] + R + S + e3[U3] + R + W + e3[R3] + R + M + e3[V3] + R + A + L + R : 65535;
        i[k](BIMVIZ[J3][P], d);
    }
    this[H3] = G3, this[R3] = n6H3C.i6H("675d") ? G3 : 0xFF00FF, this[V3] = G3;
    this[U3] = G3, this[n3] = G3;
    this[t3] = n6H3C.r6H("a17f") ? c3 : 'lowp';
    var x3 = Z3, e3 = this;
    ;
    i[M3](BIMVIZ[S3][k3], d3);
    i[M3](BIMVIZ[S3][Y3], L3);
    i[M3](BIMVIZ[J3][a3], m3);
    i[M3](BIMVIZ[J3][I], N3);
    i[M3](BIMVIZ[S3][K], u3);
}